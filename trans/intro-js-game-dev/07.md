© Graeme Stuart 2017 Graeme StuartIntroducing JavaScript Game Development [https://doi.org/10.1007/978-1-4842-3252-1_7](07.html)

# 7.动画小行星

Graeme Stuart<sup class="calibre7">1 </sup> (1)Market Harborough, Leicestershire, UK   In this chapter we’re going to introduce some critical structure into our code. The previous few chapters introduced the requirement to store data tied to our game elements. This chapter introduces the use of objects as a solution to the explosion in complexity this brings. Objects are a great solution because they enable data and code to be intimately connected. Now that we can animate, we can start to build out the main parts of the game. We’ll start by getting some asteroids on the screen, floating about. Asteroids float in space, and they keep going until they’re shot or the game ends. Their velocity and rotation are randomly initialized and never changes.

## 一个稳定的游戏循环

The window.requestAnimationFrame API allows developers to specifically make a request of the browser to draw the next frame of an animation. It benefits from many optimizations, such as working at the refresh rate of the system and ensuring rendering is synchronized with the browser’s own repaint cycle. It also benefits from not rendering frames when the page is minimized or when another browser tab is selected. This saves processing power and battery life. In this exercise, we’ll implement a robust game loop to control an animated asteroid. Create a new folder and copy the drawing.js library and the stylesheet. Copy the template from the previous example and save the file as exercise7.html. Rename the page title and header and replace the script with the code from Listing [7-1](#Par5). var context = document.getElementById("asteroids").getContext("2d"); // asteroid shape var segments = 24; var shape = []; for(var i = 0; i < segments; i++) {   shape.push(Math.random() - 0.5); } var radius = 50; var noise = 0.2; // asteroid state var x = context.canvas.width * Math.random(); var y = context.canvas.height * Math.random(); var angle = 0; // asteroid movement var x_speed = context.canvas.width * (Math.random() - 0.5); var y_speed = context.canvas.height * (Math.random() - 0.5); var rotation_speed = 2 * Math.PI * (Math.random() - 0.5); Listing 7-1Setting Up an Asteroid This code defines the global variables we’re using for this animation. The context is accessed as usual. We define variables to store the number of segments in the asteroid, and we set up the asteroid shape data. We also store the radius as a variable and the asteroid noise. All this should be fairly self-explanatory from the previous asteroid drawing example. The asteroid is given a randomized position, and its angle is initialized to 0 (since its shape is randomized anyway). It’s also given an x_speed and a y_speed, which determine its velocity. The rotation_speed variable is also randomized, indicating how fast the asteroid should spin and in what direction. These movement variables are all randomized to be either positive or negative using Math.random() – 0.5. Now add the draw function from Listing [7-2](#Par9) to render the scene. function draw(ctx, guide) {   if(guide) {     draw_grid(ctx);   }   ctx.save();   ctx.translate(x, y);   ctx.rotate(angle);   draw_asteroid(ctx, radius, shape, {     guide: guide,     noise: noise   });   ctx.restore(); } Listing 7-2A Function to Draw the Scene We’re taking a new guide argument because we want to be able to switch the grid and guide lines as well as our other guides on and off for the whole scene. First we draw the grid, but only if the guide argument is set to true. Then between save and restore calls we prepare the context and call draw_asteroid with our stored parameters. The asteroid options are constructed as a new object literal which is passed directly into the draw_asteroid function. The state of the asteroid is determined by the global variables, which are continuously changed in the update function. This determines the asteroid’s behavior. Add the update function from Listing [7-3](#Par12). function update(elapsed) {   if(x - radius + elapsed * x_speed > context.canvas.width) {x = -radius;}   if(x + radius + elapsed * x_speed < 0) {x = context.canvas.width + radius;}   if(y - radius + elapsed * y_speed > context.canvas.height) {y = -radius;}   if(y + radius + elapsed * y_speed < 0) {y = context.canvas.height + radius;}   x += elapsed * x_speed;   y += elapsed * y_speed;   angle = (angle + elapsed * rotation_speed) % (2 * Math.PI); } Listing 7-3A Function to Update the Asteroid Variables The first difference we see here is that the update function receives an argument. This represents the elapsed time (in seconds) since the last frame was rendered. It allows us to maintain consistent game speed even if performance and refresh rate fall. Our x_speed and y_speed variables are defined in units of pixels per second. We can calculate the exact number of pixels to move our asteroid each frame by multiplying these values by the elapsed time. Most of the code in the update function ensures that the asteroid wraps correctly around the canvas. When it goes completely off one edge, it’s moved seamlessly to just beyond the opposite edge. Each edge of the canvas is checked with an if statement. If the asteroid is about to pass over the edge, then its position is flipped to the opposite edge. The last line increments the angle variable. With this, we can finally implement the actual game loop . Add the code from Listing [7-4](#Par16) to your script. var previous, elapsed; function frame(timestamp) {   context.clearRect(0, 0, context.canvas.width, context.canvas.height);   if (!previous) previous = timestamp;   elapsed = timestamp - previous;   update(elapsed / 1000);   draw(context, true);   previous = timestamp;   window.requestAnimationFrame(frame); } window.requestAnimationFrame(frame); Listing 7-4The Game Loop Here we introduce some more global variables , define the frame function, and make a call to window.requestAnimationFrame. The last line in the script triggers the first frame and begins the infinite loop. The frame function is the callback, which is passed to window.requestAnimationFrame. Its main job is just like in the previous exercise: to call the update and draw functions. The requestAnimationFrame API specifies that the callback will be passed a single argument containing a timestamp accurate to at least 1 ms. We make use of this timestamp to calculate the elapsed time between this frame and the previous frame. To do that, we store a global variable containing the previous value of the timestamp argument. On the first invocation the previous timestamp isn’t set, so we initialize it to the given timestamp, and the elapsed time is 0 (zero). In subsequent frames the previous timestamp is known, and the elapsed time is indeed the time that has elapsed since the previous frame was calculated and drawn. The last line in the frame function is a call to window.requestAnimationFrame with the frame function itself as an argument. This call is a request to the browser to “please run this function when you’re ready to do so.” It simply adds the function to a list of functions that will be called during the page refresh. So, although it looks like a recursion, it isn’t. The frame function isn’t calling itself directly. This call ensures that once a frame has completed, the next frame is queued for rendering. The browser will usually try to achieve 60 frames per second, and as long as the calls to update and draw don’t take too long to run this will usually be achieved. Study the frame function and make sure you understand every line. We’ll use a version of this function in every exercise from now on and in the final game. You should see something like Figure [7-1](#Fig1).![A455241_1_En_7_Fig1_HTML.jpg](img/A455241_1_En_7_Fig1_HTML.jpg) Figure 7-1An animated asteroid floating in space This exercise has animated an asteroid. What if we wanted to include two asteroids in our game? How would we do it? What about five or ten asteroids?

## 重构成简单的对象

In the preceding code we keep all the data associated with the asteroid in the global scope. The shape, position, and velocity of the asteroid are declared as simple variables at the top of the script. This doesn't scale well—imagine managing this data for ten asteroids. What we need is some structure . We can use objects to represent a game element. Objects can store a collection of data related to a given game object. Replace the variable declarations between segments and rotation_speed with the code from Listing [7-5](#Par24). var asteroid = {   segments: 24,   shape: [],   radius: 50,   noise: 0.5,   x: context.canvas.width * Math.random(),   y: context.canvas.height * Math.random(),   angle: 0,   x_speed: context.canvas.width * (Math.random() - 0.5),   y_speed: context.canvas.height * (Math.random() - 0.5),   rotation_speed: 2 * Math.PI * (Math.random() - 0.5) }; Listing 7-5An Object Literal Here we’re defining a single object called asteroid and storing our variables inside it. JavaScript objects allow related variables to be stored together. The syntax is straightforward. We specify comma-separated key: value pairs between curly braces. Object properties can then be accessed either with dotted syntax (asteroid.radius) or with square brackets and a string index (asteroid["radius"]). We can assign data to object parameters as normal. Randomize the asteroid.shape array with the code in Listing [7-6](#Par27). for(var i = 0; i < asteroid.segments; i++) {   asteroid.shape.push(Math.random() - 0.5); } Listing 7-6Getting in Shape Now we need to upgrade our draw function to use data from the new object. Replace the draw function with the code in Listing [7-7](#Par29). function draw(ctx, guide) {   if(guide) {     draw_grid(ctx);   }   ctx.save();   ctx.translate(asteroid.x, asteroid.y);   ctx.rotate(asteroid.angle);   draw_asteroid(ctx, asteroid.radius, asteroid.shape, {     noise: asteroid.noise,     guide: guide   });   ctx.restore(); } Listing 7-7Use the Object Data Do the same to the update function. Wherever a variable has been moved into the asteroid object, add the prefix to access the data. Refresh the page, and the animation should work as before. If nothing happens, check the console for error messages—they should be clear enough to debug your code. If you miss a variable, then it will complain of an “uncaught reference error” and should tell you which variable and on which line in the code the problem was found. Note Most browsers feature built-in developer tools. These can usually be accessed by pressing F12, but see your browser documentation for details. The JavaScript console is an extremely useful tool—it shows error messages and allows you to interact directly with your program. Now type the word asteroid in the browser console and press Enter. You should see the asteroid parameters as they were the moment your command was handled. All the asteroid data is held in a single object. This is good. But the object literal syntax is pretty unwieldy for our purposes. If there were a neater way to create asteroids, we could simplify our code considerably.

## 使用对象构造函数

Object constructors are a great way to create multiple similar objects and they’re easy to create. Simply define a function and assign data to a special this keyword when inside the function. Listing [7-8](#Par35) is a handy object constructor for creating asteroids just like in the previous example. Place this in a new library file objects.js and add a new <script> element into the <head> element of the page. function Asteroid(segments, radius, noise) {   this.x = context.canvas.width * Math.random();   this.y = context.canvas.height * Math.random();   this.angle = 0;   this.x_speed = context.canvas.width * (Math.random() - 0.5);   this.y_speed = context.canvas.height * (Math.random() - 0.5);   this.rotation_speed = 2 * Math.PI * (Math.random() - 0.5);   this.radius = radius;   this.noise = noise;   this.shape = [];   for(let i = 0; i < segments; i++) {     this.shape.push(Math.random() - 0.5);   } } Listing 7-8An Object Constructor It’s good practice but not obligatory to capitalize object constructors in order to identify them in code. In this case we’ve called the constructor Asteroid. We’ve assigned all the variables to properties of the this keyword within the function. Notice that we take three arguments: the number of segments, radius, and noise. All the other variables are defined randomly, have default values, or are derived from the provided arguments. We don’t even store the segments argument as a property. It is only used to allocate the correct number of items in the shape property. To use a constructor to create an instance of an object, we must use the new keyword, like so: var asteroid = new Asteroid(24, 50, 0.2); Update your code by replacing the object literal with the preceding one-liner. Make sure you include the link to the constructor function in your page. See your asteroid continue inexorably on its journey though deep space. Feel satisfied that your code is now far better organized than it was. But so what? Why do we bother with organizing code like this?

## 扩展小行星原型

JavaScript is a prototype-based system. All objects created with our constructor will share a common prototype. A huge benefit of objects in JavaScript is that any properties or methods we define on that prototype will be available to all instances of our object type. This is our route to drawing and updating multiple asteroids with ease. Let’s say we create a lot of asteroids, in an array. If we define an update and draw function on the Asteroid.prototype, we’ll be able to update or draw any asteroid with a single method call. Looping over our Asteroid objects and calling the appropriate methods will be trivial, and all the intelligence about how an asteroid behaves will be located in one place on the Asteroid.prototype. Listing [7-9](#Par43) shows an update function on the Asteroid.prototype. Add the function into objects.js, making sure to add it after the constructor is defined. Asteroid.prototype.update = function(elapsed) {   if(this.x - this.radius + elapsed * this.x_speed > context.canvas.width) {     this.x = -this.radius;   }   if(this.x + this.radius + elapsed * this.x_speed < 0) {     this.x = context.canvas.width + this.radius;   }   if(this.y - this.radius + elapsed * this.y_speed > context.canvas.height) {     this.y = -this.radius;   }   if(this.y + this.radius + elapsed * this.y_speed < 0) {     this.y = context.canvas.height + this.radius;   }   this.x += elapsed * this.x_speed;   this.y += elapsed * this.y_speed;   this.angle = (this.angle + this.rotation_speed * elapsed) % (2 * Math.PI); } Listing 7-9A Prototype Method This is almost identical to our original update function except now we’re referring to the instance properties of the object. For now, we can replace our global update function with the simple one-liner from Listing [7-10](#Par45). function update(elapsed) {   asteroid.update(elapsed); } Listing 7-10A Simplified update Function Refreshing the page should show our asteroid is still going. Nothing has changed except our code quality. Now add the draw function from Listing [7-11](#Par47) to the Asteroid.prototype in the same way. Asteroid.prototype.draw = function(ctx, guide) {   ctx.save();   ctx.translate(this.x, this.y);   ctx.rotate(this.angle);   draw_asteroid(ctx, this.radius, this.shape, {     guide: guide,     noise: this.noise   });   ctx.restore(); } Listing 7-11Another Prototype Method Again, we’re simply transferring existing code into the function and specifying the instance variables. We’ve also specified two arguments: a context, ctx, and the optional guide. Our global draw function now looks like Listing [7-12](#Par49). function draw(ctx, guide) {   if(guide) {     draw_grid(ctx);   }   asteroid.draw(ctx, guide); } Listing 7-12A Simplified draw Function This hasn’t changed much. We just replaced all the asteroid drawing code with a single call to the preceding function. The guide drawing is still here as it’s a global concern and not related to this individual asteroid .

## 研究多个小行星

Now that our basic Asteroid “class” is complete, we can try working with multiple asteroid instances. Update your code in line with Listing [7-13](#Par52). var asteroids = [   new Asteroid(24, 50, 0.2),   new Asteroid(24, 50, 0.5),   new Asteroid(5, 50, 0.2) ]; function draw(ctx, guide) {   if(guide) {     draw_grid(ctx);   }   asteroids.forEach(function(asteroid) {     asteroid.draw(context, guide);   }); } function update(elapsed) {   asteroids.forEach(function(asteroid) {     asteroid.update(elapsed);   }); } Listing 7-13Three Asteroids We’ve replaced the asteroid variable with an array of Asteroid objects. In our draw function, we replace the call to the asteroid.draw function with a loop that calls draw on each item in the asteroids array. Finally, we replace the call to the asteroid.update function in a similar way. Figure [7-2](#Fig2) shows the result. Refresh the page and behold the three quite different asteroids you’ve brought into being!![A455241_1_En_7_Fig2_HTML.jpg](img/A455241_1_En_7_Fig2_HTML.jpg) Figure 7-2Three asteroids floating about

## 摘要

In this chapter we transformed the structure of our code. We now store and update asteroid data and render the asteroid to the canvas all within a new object type. The logic we employ in the code is pretty much identical to before. We haven't changed the way the asteroid is drawn or updated; we’ve simply added structure to the code. This additional structure allows us to create asteroids with a simple call to a constructor. We can then call methods on the asteroid objects in a very convenient way. In Listing [7-13](#Par52), a few small changes allowed us to add any number of asteroids to our scene in parallel. Without the restructuring, this would have been much more difficult to manage.