© Graeme Stuart 2017 Graeme StuartIntroducing JavaScript Game Development [https://doi.org/10.1007/978-1-4842-3252-1_13](13.html)

# 13.死亡或荣耀

Graeme Stuart<sup class="calibre7">1 </sup> (1)Market Harborough, Leicestershire, UK   Our game is nearly finished. In this chapter we’ll add the finishing touches. We’ll add a “game over” state that will end the game when our health reduces to zero. We’ll then add the ability to restart the game without reloading the page. Finally, we’ll add levels that will allow us to play the game continuously, with increasing difficulty and an increasing score multiplier. Copy your code into a new folder for the final time. Save a copy of your exercise12.html file and rename it to exercise13.html.

## 游戏结束

When the ship runs out of health, nothing happens. We need to change it so the game ends. We’ll indicate the game has ended by setting a game_over property . First, we need to add the property to our AsteroidsGame constructor: this.game_over = false; Now, when we’re in our “game over” state, we want to show the remaining asteroids still moving through space, but everything else can stop updating and won’t be drawn. Add the following lines into the AsteroidsGame.prototype.update method, just after we finish updating the asteroids, before the ship and projectiles are updated: if(this.ship.health <= 0) {   this.game_over = true;   return; } Here we’re setting the “game over” state if the ship’s health drops to 0\. We also return from the method so nothing beyond this line will be processed. Similarly, in the AsteroidsGame.prototype.draw method, add the following lines after we’ve drawn the asteroids and before we draw the ship: if(this.game_over) {   return; } This ensures that we don’t draw the ship when the game is up. The asteroids will continue to float about. Refresh your browser and try it. If you lose all your health, your ship will disappear, and the remaining asteroids will arrogantly celebrate their victory. Anything you want to show all the time should be above the if block containing the return statement. Anything you want to show only during “game over” state should be placed inside the if block and before the return statement. Anything you want to show only during a running game should be placed after the if block. We need to tell the user the game is over. Change it as shown in Listing [13-1](#Par13). if(this.game_over) {   this.message.draw(this.c, "GAME OVER", "Press space to play again");   return; } Listing 13-1Send a Message Now add the Message object from listing [13-2](#Par15) into objects.js. function Message(x, y, options) {   options = options || {};   this.x = x;   this.y = y;   this.main_pt = options.main_pt || 28;   this.sub_pt = options.sub_pt || 18;   this.fill = options.fill || "white";   this.textAlign = options.align || 'center'; } Message.prototype.draw = function(c, main, sub) {   c.save();   c.fillStyle = this.fill;   c.textAlign = this.textAlign;   c.font = this.main_pt + "pt Arial";   c.fillText(main, this.x, this.y);   c.font = this.sub_pt + "pt Arial";   c.fillText(sub, this.x, this.y + this.main_pt);   c.restore(); } Listing 13-2Deliver a Message Finally, update the game object constructor to set up the message object : this.message = new Message(this.canvas.width / 2, this.canvas.height * 0.4); Now refresh the page and admire the nice “GAME OVER” message that appears when you run out of health. You should see something like Figure [13-1](#Fig1).![A455241_1_En_13_Fig1_HTML.jpg](Images/A455241_1_En_13_Fig1_HTML.jpg) Figure 13-1Introducing jeopardy

## 重新开始游戏

We need to handle a spacebar press to reset the game. We’ll implement a reset_game method so we need to update the AsteroidsGame.prototype.key_handler method to call this if the game_over property is set when the spacebar is pressed. case " ": case 32: //spacebar   if(this.game_over) {     this.reset_game();   } else {     this.ship.trigger = value;   }   break; Listing 13-3 Restarting the Game with the Spacebar Now we need to divide the game constructer into one-off things that can remain in the constructor and things that need to be called every time the game restarts. We now call the AsteroidsGame.prototype.reset_game method at the end of the constructor, as shown in Listing [13-4](#Par22). var AsteroidsGame = function(id) {   this.canvas = document.getElementById(id);   this.c = this.canvas.getContext("2d");   this.canvas.focus();   this.guide = false;   this.ship_mass = 10;   this.ship_radius = 15;   this.asteroid_mass = 10000; // Mass of asteroids   this.asteroid_push = 5000000; // max force to apply in one frame   this.mass_destroyed = 500;   this.health_indicator = new Indicator("health", 5, 5, 100, 10);   this.score_indicator = new NumberIndicator("score", this.canvas.width - 10, 5);   this.message = new Message(this.canvas.width / 2, this.canvas.height * 0.4);   this.canvas.addEventListener("keydown", this.keyDown.bind(this), true);   this.canvas.addEventListener("keyup", this.keyUp.bind(this), true);   window.requestAnimationFrame(this.frame.bind(this));   this.reset_game(); } AsteroidsGame.prototype.reset_game = function() {   this.game_over = false;   this.score = 0;   this.ship = new Ship(     this.canvas.width / 2,     this.canvas.height / 2,     1000, 200   );   this.projectiles = [];   this.asteroids = [];   this.asteroids.push(this.moving_asteroid()); } Listing 13-4Separate out the AsteroidsGame.prototype.reset_game Method This is just a simple reorganization of preexisting code. Try refreshing the browser and losing all your health. Pressing space now calls our new method, and the game restarts! Nice .

## 实施级别

Currently, when we destroy all the asteroids, nothing happens. We just keep floating around in empty space with nothing to do. What we want to happen is that we progress to the next level and more asteroids appear. As the levels progress, we should face more and more asteroids. First things first: add a level property to the game. We set the level in the new reset_game method: this.level = 1 We also want a level indicator, so add one in the constructor, based on Listing [13-5](#Par28). this.level_indicator = new NumberIndicator("level", this.canvas.width / 2, 5, {   align: "center" }); Listing 13-5A Level Indicator Don’t forget to draw it to the canvas in the AsteroidsGame.prototype.draw method: this.level_indicator.draw(this.c, this.level); Now we need to update the level property when the asteroids array is empty. Add this to the beginning of the AsteroidsGame.prototype.update method: if(this.asteroids.length == 0) {   this.level_up(); } The new AsteroidsGame.prototype.level_up method will increment the level property and set up more asteroids. Add the new method shown in Listing [13-6](#Par34). AsteroidsGame.prototype.level_up = function() {   this.level += 1;   for(var i = 0; i < this.level; i++) {     this.asteroids.push(this.moving_asteroid());   } } Listing 13-6The AsteroidsGame.prototype.level_up Method Now we can tidy up our AsteroidsGame.prototype.reset_game method by initializing the level to 0 and calling level_up. Listing [13-7](#Par36) shows the new method. AsteroidsGame.prototype.reset_game = function() {   this.score = 0;   this.level = 0;   this.game_over = false;   this.ship = new Ship(     this.canvas.width / 2,     this.canvas.height / 2   );   this.projectiles = [];   this.asteroids = [];   this.level_up(); } Listing 13-7A Tidy AsteroidsGame.prototype.reset_game Method Refresh the browser and play your fully featured game. When all the asteroids are destroyed, they’re replaced with a larger batch. The game starts out easy but quickly gets harder. Once you lose all your health, the “game over” state shows, and the game restarts when the spacebar is pressed. Sit back and contemplate what you’ve done. By my calculations, you now have over 700 lines of code and a really solid, extendable game. The code is beautifully organized, and adding features such as a particle system for explosions and thruster trails, powerups, and sounds would be easy.

## 摘要

In this chapter we’ve refined our game into a complete user experience by introducing states. Our game previously had two dead-ends. If the player was killed, the game continued as if nothing had happened. If the player destroyed the last asteroid, the game simply continued with nothing to shoot at. By adding a “game over” state, we introduced jeopardy. By adding a level system and bringing more asteroids into the game, we introduced ambition and potential. There are now no longer any states in the game where the user gets stuck. Of course, the game is still very simple, and other than challenging friends to achieve the highest score there’s little long-term playability here. That situation can be improved by introducing features such as powerups (especially if rare powerups enable progression in later levels). You could also make improvements such as a scoreboard to record precisely who the best player is, which can make the game more attractive. The look and feel of the game can be improved by adding a snazzy particle system for the thruster trails and explosions when asteroids are hit. Finally, adding sounds can make a huge difference to a game like this, making the experience richer and more immersive. The improvements just mentioned are just suggestions but would make excellent projects for an enthusiastic and creative reader to develop their knowledge further.

## 结论

JavaScript is a great tool for building games and game-like systems. The web provides a perfect means to put your creations into the hands of millions of waiting users. Of course, other technology stacks are also available; there’s great benefit to be had from gaining experience with multiple languages and systems. Hopefully, some of the key points I’ve covered in this book will prove useful to you in the future, whatever path you choose. You’ve been through a long process and I hope you’ve learned a few things about structuring code and the kinds of logic necessary for building games. This puts you in a good position to open a blank text file and get creative with your own project. If I were to offer any parting advice, it would be this: try to view software engineering as a process of managing complexity. Any non-trivial software will be complex. It’s important to design our code one step at a time, gradually building the complexity and restructuring all the time as we go. This means starting with no structure and only adding functions and classes and inheritance when you’re sure they will help. When we create new code, we need the freedom to be creative. Too much structure in the early stages will limit the options and reduce the chance for us to find good solutions. The real trick is balancing this with the absolute necessity of building structure to enable the complexity to grow. We should allow structure to emerge naturally by a process of trial and error. Adding structure should simplify the code that uses that structure. It should create an interface you can use effectively for the problem at hand. I want to mention some pointers you can use to get started. Write code into global scope while you experiment. Always start simple. Identify the components you’ll need (in our case, we started with asteroids and a ship) and develop them one at a time. Try to start with the individual behavior of the simplest components and don’t worry about how they’ll interact until later. Only add structure such as functions and objects when the code looks good. Don’t change code inside functions and objects too often. Study messy code and try to simplify it. Add more functions to break up large pieces of code into smaller pieces. Experimentation is important. Once you have something you’re happy with, add structure to crystalize the component down into the functionality it provides. Move good code into libraries—quality control is important. Build all your low-level components in this way. At each stage, move your best code from the global scope into function and objects, and move your best functions and objects into libraries. Refactor early, refactor often. Develop your instincts by confidently experimenting with how you do things (always save a copy just in case). Use version control and commit every incremental improvement. Experiment with your components to see what they can do. Once your objects are stable, start to consider their interactions. Compose component interactions experimentally. Once you’re happy, build more structure—perhaps a master object. Refactor again and improve the structure of your components to meet the needs you’re identifying. Great developers manage the interplay between chaos and order. True mastery comes when we develop instincts that can guide us towards structures at multiple levels that are helpful rather than harmful to the whole. These instincts can only come with practice. Remember, code doesn’t appear fully formed with perfect structure. Blindly copying structure from examples in a book won’t help you to understand how those examples came about. The secret is to have a goal in mind while you experiment. Develop your instincts by experimenting with many different structures until you hit upon one you consider to be good for your current goal. Do this enough times, and it will become easier. With that, I have to leave it. Thank you for taking the time to read my book. If you liked it, tell someone about it. If you didn’t like it, tell me about it. Graeme