© Graeme Stuart 2017 Graeme StuartIntroducing JavaScript Game Development [https://doi.org/10.1007/978-1-4842-3252-1_8](08.html)

# 8.练习对象

Graeme Stuart<sup class="calibre7">1 </sup> (1)Market Harborough, Leicestershire, UK   The benefits of the object-oriented approach should be clear by now. We can design our objects (Asteroid, Ship, and so on) with a simple and intuitive API. Our objects track their own state and update themselves when we ask them to (in their update functions). They can also easily be drawn to the canvas in the correct position with a simple function call (their draw functions). The game loop itself can update all our objects in turn and then draw them all. We should be able to read the high-level code without too much trouble. All the nitty-gritty details are delegated to the objects themselves. In this chapter, we’ll practice using objects in this way with a familiar example.

## 为什么是对象？

It’s an important point of modern development practice that there’s often a trade-off between the efficiency of an implementation and the clarity of the code we produce. With the computing power available in low-end machines being more than enough for a simple game like this, we should focus our attention on making our code easily understandable. Although efficiency of an implementation is very important, and we should always strive to be efficient by default, we shouldn’t allow this to affect the overall design of our code. Indeed, we may actively choose to sacrifice efficiency for clarity on occasion. By pushing the low-level code into objects (and moving this code into library modules), we keep the low-level implementation details out of sight. Our top-level scope (we’re currently coding in the global scope) is then easy to follow and can focus on the higher-level game logic. We can work on this code without needing to think about how the asteroid behavior is implemented or how asteroids are drawn, maintaining a separation of concerns and allowing us to focus on the job at hand.

## 被鬼魂追逐的吃豆人

In the next few chapters we’ll get stuck into coding the asteroid game in detail. Before we do that, though, we’ll spend a bit of time reviewing our game design and see how the principles we applied in the previous chapter can be applied to another pseudo-game involving Pac-Man. We’ll define behaviors for our Pac-Man and create a new object to represent the Pac-Man ghosts. Pac-Man will be allowed to move horizontally and vertically across the canvas and will wrap around the canvas as in the previous Pac-Man and Asteroids examples. Occasionally, he’ll randomly decide to turn left or right (clockwise or anti-clockwise). He’ll be pursued by ghosts. The ghosts will have the advantage of being able to move in any direction and will be programmed to head straight for Pac-Man. We’ll ensure the ghosts have a hard time by making Pac-Man faster. Create a new folder called exercise8 and copy the usual libraries and stylesheets into the new folder. Add a new template called exercise8.html, and include a link to drawing.js and objects.js as before. Begin with the code in Listing [8-1](#Par8). This instantiates a PacMan object, updates it and draws it in the respective functions and controls everything with the main game loop function, frame. <!doctype html> <html>   <head>     <title>Animation</title>     <link rel="stylesheet" href="styles.css">     <script src="drawing.js"></script>     <script src="objects.js"></script>   </head>   <body>     <h1>Animation</h1>     <canvas id="pacman" width="300" height="300"></canvas>     <script>       var context = document.getElementById("pacman").getContext("2d");       pacman = new PacMan(150, 150, 20, 120);       function draw(ctx, guide) {         pacman.draw(ctx);       }       function update(elapsed) {         pacman.update(elapsed, 300, 300);       }       var previous, elapsed;       function frame(timestamp) {         context.clearRect(0, 0, context.canvas.width, context.canvas.height);         if (!previous) previous = timestamp;         elapsed = timestamp - previous;         update(elapsed / 1000);         draw(context, true);         previous = timestamp;         window.requestAnimationFrame(frame);       }       window.requestAnimationFrame(frame);     </script>   </body> </html> Listing 8-1A Simple Template

## PacMan 对象

Now we need to define the PacMan constructor in objects.js. PacMan is pretty simple: we’ll allow his radius and speed to be configurable with arguments. We initialize his location to the center of the canvas. Internally, PacMan has x_speed and y_speed (initially he’s moving to the right). He also has an angle property that determines the direction he’s pointing and a mouth_angle property to record where his mouth is in its chomping cycle. Add Listing [8-2](#Par10) to your objects.js library. Note that no default values are provided. function PacMan(x, y, radius, speed) {   this.x = x;   this.y = y;   this.radius = radius;   this.speed = speed;   this.angle = 0;   this.x_speed = speed;   this.y_speed = 0;   this.time = 0;   this.mouth = 0; } Listing 8-2The PacMan Constructor The PacMan. prototype.draw method should look fairly familiar. It’s the same as that for Asteroid. Add Listing [8-3](#Par12) after the constructor. PacMan.prototype.draw = function(ctx) {   ctx.save();   ctx.translate(this.x, this.y);   ctx.rotate(this.angle);   draw_pacman(ctx, this.radius, this.mouth);   ctx.restore(); } Listing 8-3The Pacman. prototype.draw Method Now, before we code the behavior of our Pac-Man in the PacMan.prototype.update function, we need a few helper functions. The main helper function we need is one that will turn our Pac-Man through 90 degrees, either left or right. Listing [8-4](#Par14) shows the new function; add it to your library. PacMan.prototype.turn = function(direction) {   if(this.y_speed) {     // if we are travelling vertically     // set the horizontal speed and apply the direction     this.x_speed = -direction * this.y_speed;     // clear the vertical speed and rotate     this.y_speed = 0;     this.angle = this.x_speed > 0 ? 0 : Math.PI;   } else {     // if we are travelling horizontally     // set the vertical speed and apply the direction     this.y_speed = direction * this.x_speed;     // clear the horizontal speed and rotate     this.x_speed = 0;     this.angle = this.y_speed > 0 ? 0.5 * Math.PI : 1.5 * Math.PI;   } } Listing 8-4The Pacman. prototype.turn Method This function relies on the restriction that our Pac-Man can only move on the horizontal and vertical. That is, we rely on the fact that either the x_speed or the y_speed will always be 0\. The first thing the function does is test whether we’re moving vertically or horizontally. It then changes the direction of travel accordingly and moves the angle so Pac-Man always faces in the correct direction. The function takes an argument that’s used to select whether it’s a left turn or a right turn. To make the API clearer, we can add a few intermediate methods, as shown in Listing [8-5](#Par17). PacMan.prototype.turn_left = function() {   this.turn(-1); } PacMan.prototype.turn_right = function() {   this.turn(1); } Listing 8-5Supporting Methods Make the API Nice With these, we don’t need to remember the helper function API rules, we can simply call the appropriate function to turn Pac-Man left or right. Now we can use the functions in a very clear way in our PacMan.prototype.update function, keeping the code clear and concise. Add the code from Listing [8-6](#Par19). PacMan.prototype.update = function(elapsed, width, height) {   // an average of once per 100 frames   if(Math.random() <= 0.01) {     if(Math.random() < 0.5) {       this.turn_left();     } else {       this.turn_right();     }   }   if(this.x - this.radius + elapsed * this.x_speed > width) {     this.x = -this.radius;   }   if(this.x + this.radius + elapsed * this.x_speed < 0) {     this.x = width + this.radius;   }   if(this.y - this.radius + elapsed * this.y_speed > height) {     this.y = -this.radius;   }   if(this.y + this.radius + elapsed * this.y_speed < 0) {     this.y = height + this.radius;   }   this.x += this.x_speed * elapsed;   this.y += this.y_speed * elapsed;   this.time += elapsed;   this.mouth = Math.abs(Math.sin(2 * Math.PI * this.time)); } Listing 8-6The Pacman. prototype.update Method The first code block only runs, on average, once per 100 frames. It randomly chooses either the turn_left or turn_right functions to call. This controls the x_speed and y_speed properties as well as the angle property. The next four code blocks should be familiar from the Asteroid.prototype.update function mentioned earlier. In each block we check to see if we’re about to cross one edge of the canvas. If we do cross the edge, then we’re positioned on the opposite side of the canvas. With this move done, we update the x and y coordinates as usual. Notice we’ve removed any reliance on the global context object. We take width and height arguments and use these to determine where the x and y attributes will wrap. Finally, we have two lines that update the mouth value, which determines how open the mouth is. The first line increments the time by the elapsed time. The second line updates the mouth to the absolute value of the sine of the time value. This causes mouth to progress in a sine wave that opens and shuts the mouth twice per second. Create a global PacMan object and update your global draw and update functions to draw and update it. You should see when you open the file in your browser that Pac-Man is chomping away and taking random turns. Figure [8-1](#Fig1) shows the result.![A455241_1_En_8_Fig1_HTML.jpg](Images/A455241_1_En_8_Fig1_HTML.jpg) Figure 8-1Pac-Man snapping and turning

## 幽灵物体

The ghosts will move in a straight line directly towards Pac-Man. They will be different colors and have different speeds. They won’t need to wrap around the canvas because they’ll always be moving towards Pac-Man. Because Pac-Man wraps around the canvas, they turn around to follow him. Drawing Pac-Man ghosts is pretty tricky. Here is a basic approach. Copy Listing [8-7](#Par26) into drawing.js. function draw_ghost(ctx, radius, options) {   options = options || {}   var feet = options.feet || 4;   var head_radius = radius * 0.8;   var foot_radius = head_radius / feet;   ctx.save();   ctx.strokeStyle = options.stroke || "white";   ctx.fillStyle = options.fill || "red";   ctx.lineWidth = options.lineWidth || radius * 0.05;   ctx.beginPath();   for(foot = 0; foot < feet; foot++) {     ctx.arc(       (2 * foot_radius * (feet - foot)) - head_radius - foot_radius,       radius - foot_radius,       foot_radius, 0, Math.PI      );   }   ctx.lineTo(-head_radius, radius - foot_radius);   ctx.arc(0, head_radius - radius, head_radius, Math.PI, 2 * Math.PI);   ctx.closePath();   ctx.fill();   ctx.stroke();   ctx.restore(); } Listing 8-7Drawing a Ghost We draw a series of upside-down half-circles for the “feet,” draw a line up to the head, and draw another half-circle for the head. Then we close the path to finish. Working out the positioning of all this stuff is tricky, but once you have it, everything works and you can forget about it. Figure [8-2](#Fig2) shows a ghost with added eyes.![A455241_1_En_8_Fig2_HTML.jpg](Images/A455241_1_En_8_Fig2_HTML.jpg) Figure 8-2A big red ghost with five “feet” Try adding eyes to your ghost. Filled black circles will do, but white circles with black circles inside them gives more character. For the Ghost constructor, we specify the radius, speed, and colour as arguments. Copy Listing [8-8](#Par30) into your objects.js file. function Ghost(x, y, radius, speed, colour) {   this.x = x;   this.y = y;   this.radius = radius;   this.speed = speed;   this.colour = colour; } Listing 8-8 Ghost Constructor We simply store the given arguments as properties—no default values are provided. The Ghost.prototype.draw method in Listing [8-9](#Par32) is again familiar. We transform the context to the correct location and call the draw_ghost function, passing in the colour attribute as required. Copy it into your objects.js file after the constructor. Ghost.prototype.draw = function(ctx) {   ctx.save();   ctx.translate(this.x, this.y);   draw_ghost(ctx, this.radius, {     fill: this.colour   });   ctx.restore(); } Listing 8-9The Ghost. prototype.draw Method The Ghost.prototype.update method in Listing [8-10](#Par34) defines the ghost behavior. We take an extra argument called target. The method calculates the angle between the ghost and the target and then sets the x_speed and y_speed properties so the ghost moves towards the target at its given speed. The ghost coordinates are then updated to reflect the velocity. Ghost.prototype.update = function(target, elapsed) {   var angle = Math.atan2(target.y - this.y, target.x - this.x);   var x_speed = Math.cos(angle) * this.speed;   var y_speed = Math.sin(angle) * this.speed;   this.x += x_speed * elapsed;   this.y += y_speed * elapsed; } Listing 8-10The Ghost. prototype.update Method Instantiate an array of four Ghost objects in the global scope. Initialize their positions to random locations on the canvas. Loop over each ghost in the draw and update functions and call the appropriate ghost method. You should see the ghosts chasing Pac-Man all over the canvas, as in Figure [8-3](#Fig3).![A455241_1_En_8_Fig3_HTML.jpg](Images/A455241_1_En_8_Fig3_HTML.jpg) Figure 8-3Ghosts chasing Pac-Man You should end up with something like the code shown in Listing [8-11](#Par37). <!doctype html> <html>   <head>     <title>Animation</title>     <link rel="stylesheet" href="styles.css">     <script src="drawing.js"></script>     <script src="objects.js"></script>   </head>   <body>     <h1>Animation</h1>     <canvas id="pacman" width="300" height="300"></canvas>     <script>       let context = document.getElementById("pacman").getContext("2d");       let pacman = new PacMan(150, 150, 20, 120);       let ghosts = [         new Ghost(Math.random() * 300, Math.random() * 300, 20, 70, 'red'),         new Ghost(Math.random() * 300, Math.random() * 300, 20, 60, 'pink'),         new Ghost(Math.random() * 300, Math.random() * 300, 20, 50, 'cyan'),         new Ghost(Math.random() * 300, Math.random() * 300, 20, 40, 'orange')       ]       function draw(ctx, guide) {         pacman.draw(ctx);         ghosts.forEach(function(ghost) {           ghost.draw(context, guide);         });       }       function update(elapsed) {         pacman.update(elapsed, 300, 300);         ghosts.forEach(function(ghost) {           ghost.update(pacman, elapsed);         });       }       var previous, elapsed;       function frame(timestamp) {         context.clearRect(0, 0, context.canvas.width, context.canvas.height);         if (!previous) previous = timestamp;         elapsed = timestamp - previous;         update(elapsed / 1000);         draw(context, true);         previous = timestamp;         window.requestAnimationFrame(frame);       }       window.requestAnimationFrame(frame);     </script>   </body> </html> Listing 8-11 Control ling Pac-Man and Ghosts

## 摘要

Hopefully this chapter has gone some ways towards establishing a clear pattern here. The “things” we want on the screen must all be updated and drawn in every frame. We can do this in a very organized way by defining objects with constructors and defining methods on the object prototype for drawing and updating. This makes our global draw and update functions very straightforward—they simply draw and update each object in turn. Enough practice! Let’s get back to working on our game. In the next chapter, we’ll make another few steps towards building a solid infrastructure of objects.