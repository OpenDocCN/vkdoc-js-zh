© Graeme Stuart 2017 Graeme StuartIntroducing JavaScript Game Development [https://doi.org/10.1007/978-1-4842-3252-1_6](06.html)

# 6.基础动画

Graeme Stuart<sup class="calibre7">1 </sup> (1)Market Harborough, Leicestershire, UK   In previous chapters we’ve looked at the nuts and bolts of drawing to the canvas. Now that we have a bit of experience, we can turn our attention to animating a scene. Animation is quite easy—simply draw a changing scene multiple times per second. In this chapter we’ll learn to do this in a very simplistic way in order to understand the basics. When drawing ships and asteroids, we need data about their location, size, shape, and so on. This data will be used to translate and rotate the context so everything appears in the right place. To animate a scene, we update the data each frame and redraw the scene over and over as the data changes.

## 从简单开始

Let’s start off with a very simple scene: a single moving circle . The circle has a position on the canvas (x- and y-coordinates), which we will move. Create a new folder in the usual way: copy over the drawing.js library and stylesheet. Create a new file exercise6.html with the code in Listing [6-1](#Par4). <!doctype html> <html>   <head>     <title>Animation</title>     <link rel="stylesheet" href="styles.css">     <script src="drawing.js"></script>   </head>   <body>     <h1>Animation</h1>     <canvas id="asteroids" width="300" height="300"></canvas>     <script>       var context = document.getElementById("asteroids").getContext("2d");       context.strokeStyle = "white";       context.lineWidth = 1.5;       var x = 0, y = context.canvas.height / 2;       function frame() {         context.clearRect(0, 0, context.canvas.width, context.canvas.height);         draw(context);         update();       }       function update() {         x += 1;       }       function draw(ctx) {         draw_grid(ctx);         ctx.beginPath();         ctx.arc(x, y, 40, 0, 2 * Math.PI);         ctx.fill();         ctx.stroke();       }       setInterval(frame, 1000.0/60.0); // 60 fps     </script>   </body> </html> Listing 6-1A Moving Circle The code is mostly familiar, but there are a few new things to notice. First, we’re storing the x- and y-coordinates as global variables . We’ve also restructured our code into a series of functions: frame, update, and draw. The frame function does three distinct things. It clears the canvas using the context.clearRect method. Then it calls the draw function, which draws a circle at position x, y, and it calls the update function, which moves the x-coordinate one pixel to the right. The final new thing is the call to setInterval, which schedules the frame function to be called 60 times per second. The result is that each time the frame function is called, it clears the canvas, draws a grid, draws a circle at the current position, and moves the position to the right. The call to setInterval passes in the function to be called (frame) and the time interval in milliseconds between calls (1000.0 / 60.0). So, the frame function is called every sixtieth of a second, and the circle moves to the right at 60 pixels per second. Once the circle moves beyond the end of the canvas, it’s no longer visible, but the value of x continues to increment. Try experimenting with the update function to change the behavior of our circle. Here are a few simple ideas:

*   将 x 坐标增加不同的值(例如，5)
*   也增加 y 坐标
*   减少坐标
*   将 y 坐标设置为一个随机数(介于 0 和画布高度之间)

## 一个更复杂的例子

Let’s focus on the update function and give our circle some more complicated behavior. For example, we can add a gravity effect to make the circle accelerate downwards. Add a line after the x and y definitions to define the variables we’ll need: var yspeed = 0, gravity = 0.1; Update your update function like so: function update() {   x += 1;   y += yspeed;   yspeed += gravity; } Here we’re moving the y coordinate according to the yspeed and incrementing yspeed by the value of gravity. The circle accelerates off the bottom of the canvas pretty quickly. Let’s make the circle bounce when it hits the bottom of the screen. Bouncing is simply switching the direction of travel, like this: function update() {   x += 1;   y += yspeed;   yspeed += gravity;   if(y >= context.canvas.height) { // if you hit the bottom     yspeed *= -1;                  // move up instead of down   } } If you want to lose a bit of energy on every bounce, then multiply by less than –1 (for example, –0.8). Note Be careful about this. Consider what would happen if the yspeed were +10 (pixels per frame) and the y coordinate were just 1 pixel short of the canvas height.

1.  1.y 坐标增加到超出画布高度 9 个像素，yspeed 更新为–8。
2.  2.y 坐标减少到超出画布高度 1 个像素，yspeed 设置为+6.4。

The position then never gets below the canvas height because yspeed is updated (reversed and shrunk) in every frame. To fix this problem, make sure the circle is moved to the canvas height whenever yspeed is reversed. Now we would like to see the circle “wrap” around the canvas horizontally. Add the following lines to your update function: if(x <= 0 || x >= context.canvas.width) {   x = (x + context.canvas.width) % context.canvas.width; } Now we can take this a bit further by adding more variables and optionally drawing a Pac-Man instead of a ball. This shows the benefit of keeping the updating and drawing code separate and having handy drawing functions available. Update your code to reflect Listing [6-2](#Par29). <!doctype html> <html>   <head>     <title>Animation</title>     <link rel="stylesheet" href="styles.css">     <script src="drawing.js"></script>   </head>   <body>     <h1>Animation</h1>     <canvas id="asteroids" width="300" height="300"></canvas>     <script>       var context = document.getElementById("asteroids").getContext("2d");       context.strokeStyle = "white";       context.lineWidth = 1.5;       let x = 0, y = context.canvas.height / 5, radius = 20;       let xspeed = 1.5, yspeed = 0, gravity = 0.1;       let mouth = 0;       function frame() {         context.clearRect(0, 0, context.canvas.width, context.canvas.height);         draw(context);         update();       }       function update() {         x += xspeed;         y += yspeed;         yspeed += gravity;         if(y >= context.canvas.height - radius) {           y = context.canvas.height - radius; // add an extra radius           yspeed *= -0.6;                                // reverse and slow down           xspeed *= 0.95;                               // just slow down a bit         }         if(x <= 0 || x >= context.canvas.width) {           x = (x + context.canvas.width) % context.canvas.width;         }         mouth = Math.abs(Math.sin(6 * Math.PI * x / (context.canvas.width)));       }       function draw(ctx) {         draw_grid(ctx);         // draw a simple circle         ctx.beginPath();         ctx.arc(x, y, radius, 0, 2 * Math.PI);         ctx.fill();         ctx.stroke();         // or try this instead         // ctx.save();         // ctx.translate(x, y);         // draw_pacman(ctx, radius, mouth);         // ctx.restore();       }       setInterval(frame, 1000.0/60.0); // 60 fps     </script>   </body> </html> Listing 6-2A Bouncing Ball/Pac-Man We’ve gone to town here by keeping track of another variable to control the mouth angle . The mouth angle is now tied to the x coordinate and follows a sine wave that opens and closes the mouth six times each time Pac-Man crosses the canvas. The mouth position is tightly tied to the position in the x coordinate. This is just for fun. Feel free to update the mouth variable however you like. Notice the other major changes relate to adding an xspeed variable and a radius and also adapting the code that bounces our item off the bottom of the canvas. We no longer sink halfway through the canvas. The draw_pacman function will need to be updated to draw at the context origin, as in Listing [6-3](#Par33). function draw_pacman(ctx, radius, mouth) {   angle = 0.2 * Math.PI * mouth;   ctx.save();   ctx.fillStyle = "yellow";   ctx.strokeStyle = "black";   ctx.lineWidth = 0.5;   ctx.beginPath();   ctx.arc(0, 0, radius, angle, -angle);   ctx.lineTo(0, 0);   ctx.closePath()   ctx.fill();   ctx.stroke();   ctx.restore(); } Listing 6-3Draw Pac-Man at the Origin To clarify what’s going on here, we can follow the code in the other direction. The call to setInterval is causing frame to be called 60 times per second. The repeated calls to frame clear the canvas, call update, and then call draw. The update function updates the variables x, y, yspeed, xspeed, and mouth. The draw function renders the circle (or Pac-Man) using the variables to determine its position and mouth angle. The end result is that the circle/Pac-Man bounces across the canvas. You should see something like Figure [6-1](#Fig1). Try removing the call to context.clearRect to see why it needs to be there.![A455241_1_En_6_Fig1_HTML.jpg](img/A455241_1_En_6_Fig1_HTML.jpg) Figure 6-1Pac-Man chomping his way across the canvas

## 摘要

In this chapter we looked at the basic principles of animation: we render a scene frame by frame and control the data associated with our game elements. Dividing these two basic tasks of drawing the scene and updating the data into two distinct functions is the first step in maintaining a structured approach. How we manage this data is a critical aspect of how our game will be able to grow in complexity as it develops. I should be clear that animating based on setInterval is not best practice. Modern browsers implement a mechanism specifically designed for animating on the web. We should quickly move to using the window.requestAnimationFrame method to control our game loop. So let’s do it.