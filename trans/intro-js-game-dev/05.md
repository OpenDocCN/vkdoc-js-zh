© Graeme Stuart 2017 Graeme StuartIntroducing JavaScript Game Development [https://doi.org/10.1007/978-1-4842-3252-1_5](05.html)

# 5.画一颗小行星

Graeme Stuart<sup class="calibre7">1 </sup> (1)Market Harborough, Leicestershire, UK   Asteroids, like ships, can be approximated to a circle for the purposes of collision detection. However, they should be irregular shapes, and each one should be unique. To achieve this we’ll make extensive use of the Math.random method to define the shape of our asteroids.

## 绘制基本形状

As a first stab, we’ll divide our circle into segments and draw a straight line from each segment to the next. We can do that by rotating the canvas in steps and drawing a line at each step before closing the path. We’ll want some randomness in the distance of the point from the origin. We can manage the rotation in a loop. We can rotate the same amount at every step: this is 2π radians divided by the number of segments. We can then pick a random point near the circumference, directly to the right of the origin. The origin of the rotation will be the center of the asteroid, so although we keep our pen to the right of the circle, our drawing rotates under the pen. In this way, we draw our asteroid, one segment at a time and we should be able to close the path at the end. Add the function from Listing [5-1](#Par5) into drawing. js . function draw_asteroid(ctx, radius, segments, options) {   options = options || {};   ctx.strokeStyle = options.stroke || "white";   ctx.fillStyle = options.fill || "black";   ctx.save();   ctx.beginPath();   for(let i = 0; i < segments; i++) {     ctx.rotate(2 * Math.PI / segments);     ctx.lineTo(radius, 0);   }   ctx.closePath();   ctx.fill();   ctx.stroke();   if(options.guide) {     ctx.lineWidth = 0.5;     ctx.beginPath();     ctx.arc(0, 0, radius, 0, 2 * Math.PI);     ctx.stroke();   }   ctx.restore(); } Listing 5-1Drawing Basic Shapes The function takes four arguments : the context with which to draw, the radius of the asteroid, the number of segments, and an optional set of options. It begins a path and proceeds to rotate the canvas one segment at a time, adding a line to the path for each segment. The path is then closed off, which completes the drawing. If a guide is requested, it’s drawn as a simple circle. Note that the position of the start of the path isn’t established after the context.beginPath method call. Under these circumstances, the first line to be added to the path isn’t drawn but is treated as a move. So, by the time the last segment is drawn, there’s one line missing and the path needs to be closed. Create a new file exercise5.html and set it up as before but with a new title and heading. Draw a grid as in the previous exercises and add the code from Listing [5-2](#Par9). let context = document.getElementById("asteroids").getContext("2d"); draw_grid(context); let segments = 1 for(let x=0.25; x<1; x+= 0.5) {   for(let y=0.25; y<1; y+= 0.5) {     segments += 2;     context.save();     context.translate(context.canvas.width * x, context.canvas.height * y);     draw_asteroid(context, 60, segments, {guide: true});    context.restore();  } } Listing 5-2Some Regular Shapes This draws four asteroids to the canvas, as in Figure [5-1](#Fig1). Notice that the corners of the asteroids are located on the guide circles.![A455241_1_En_5_Fig1_HTML.jpg](Images/A455241_1_En_5_Fig1_HTML.jpg) Figure 5-1Regular asteroids with no randomization To add randomization is fairly simple. We simply change the x-coordinate of the context.lineTo command, adding a bit of random noise to the radius in each segment. How we do this determines how close we can keep to the guide circles. A simple approach would be to multiply the radius by a random number—that would add huge variation in the segment positions between 0 (the center of the asteroid) and the full radius. Listing [5-3](#Par12) shows three approaches to adding randomness that were attempted when writing these examples. //A simplistic approach - we don't want totally random ctx.lineTo(radius * Math.random(), 0); //This is much better, only a bit random ctx.lineTo(radius * 0.8 + radius * 0.4 * Math.random(), 0); //This is neat, configurable and keeps the radius about right ctx.lineTo(radius + radius * options.noise * (Math.random() - 0.5), 0); Listing 5-3Adding Randomness There are requirements that those examples expose. In the first example, a random asteroid could include points at the origin; that’s not what we want. To avoid this, we specify a portion of the radius that will always remain intact (for example, 80%) and only randomize the remainder. In the second example, a random asteroid will always have points within the collision circle and never outside it. We want the randomization to “straddle” the specified radius rather than always eating into it, making the asteroid smaller. To do that, we generate a number between –0.5 and +0.5 and randomize the drawing using this. Also, the second example isn’t configurable, so we introduce the use of a configuration parameter that can be specified in the options argument. The final example shows this approach achieved by specifying a noise parameter between 0 (no randomization) and 1 (lots of randomization). This value is multiplied by a random number between –0.5 and 0.5 to limit the effect of the randomization. For example, a noise value of 0.2 can lead to any radius between 90% and 110% of the original radius. Specifying a noise factor of 0.1 would allow the radius to vary between 95% and 105% of the given value. Update your function to take a noise argument . Then draw 25 asteroids using the code in Listing [5-4](#Par16). var segments = 15, noise = 0.4; for(let x=0.1; x<1; x+= 0.2) {   for(let y=0.1; y<1; y+= 0.2) {     context.save();     context.translate(context.canvas.width * x, context.canvas.height * y);     draw_asteroid(context, context.canvas.width / 12, segments, {noise: noise, guide: true});     context.restore();   } } Listing 5-4Drawing Some Different Asteroids Here we loop over the x- and y-coordinates as before and draw an asteroid at each location. The result is shown in Figure [5-2](#Fig2). Try experimenting with the number of segments and the noise level by changing the initial values of the provided variables. You can also change the values in each loop by incrementing or randomizing them. What do you notice about asteroids with large numbers of segments?![A455241_1_En_5_Fig2_HTML.jpg](Images/A455241_1_En_5_Fig2_HTML.jpg) Figure 5-225 asteroids (segments = 15, noise = 0.2) These asteroids look pretty good! Notice in Figure [5-2](#Fig2) that we’ve also added two new guide circles to show the inner and outer extent of the configured noise. This is left as an exercise. Implement this in your function using a thinner line width than the main guide circle.

## 存储形状数据

In our game we’ll need to have individual asteroids persist until they’re shot or the game ends. As it stands, our function can’t do this. It randomizes the asteroid shape every time it’s called. The shape data (an array of random numbers) needs to be stored and used when drawing the individual asteroids. Each asteroid needs its own shape data. A first step towards doing this would be to generate the random shape data outside the function and pass it in as a function argument. Let’s try it. function draw_asteroid(ctx, radius, shape, options) {   options = options || {};   ctx.strokeStyle = options.stroke || "white";   ctx.fillStyle = options.fill || "black";   ctx.save();   ctx.beginPath();   for(let i = 0; i < shape.length; i++) {     ctx.rotate(2 * Math.PI / shape.length);     ctx.lineTo(radius + radius * options.noise * shape[i], 0);   }   ctx.closePath();   ctx.fill();   ctx.stroke();   if(options.guide) {     ctx.lineWidth = 0.5;     ctx.beginPath();     ctx.arc(0, 0, radius, 0, 2 * Math.PI);     ctx.stroke();     ctx.beginPath();     ctx.lineWidth = 0.2;     ctx.arc(0, 0, radius + radius * options.noise, 0, 2 * Math.PI);     ctx.stroke();     ctx.beginPath();     ctx.arc(0, 0, radius - radius * options.noise, 0, 2 * Math.PI);     ctx.stroke();   }   ctx.restore(); } Listing 5-5Taking Shape Data We’ve actually made very few changes. The main difference is that we now take a shape argument rather than a segments argument. The shape can be any array of numbers, but the numbers are assumed to vary between –0.5 and +0.5\. Where we previously referenced the segments variable, we now use shape.length. Where we generated random numbers, we now use the value of the appropriate element in the shape array (shape[i]). We’ve also added the extra guide circles indicating the value of noise. To use the new function, we must generate our shape data and then we can simply pass it into the function to replace the segments argument . Try the code in Listing [5-6](#Par24). var segments = 15, noise = 0; var shape = []; for(var i = 0; i < segments; i++) {   shape.push(2 * (Math.random() - 0.5)); } for(let y=0.1; y<1; y+= 0.2) {   for(let x=0.1; x<1; x+= 0.2) {     context.save();     context.translate(context.canvas.width * x, context.canvas.height * y);     draw_asteroid(context, context.canvas.width / 16, shape, {noise: noise, guide: true});     context.restore();     noise += 0.025;   } } Listing 5-6Using the Same Shape with Different Noise In this case, we generate the shape data and then draw a set of 25 asteroids with the same shape but with increasing value for the noise argument (see Figure [5-3](#Fig3)). noise starts at 0 and increases in 0.125 steps to 0.6\. Try experimenting with the code.![A455241_1_En_5_Fig3_HTML.jpg](Images/A455241_1_En_5_Fig3_HTML.jpg) Figure 5-3Using the same shape with increasing noise We now have a function that can draw our asteroids according to a configurable noise level. The client code that uses the function is responsible for generating the asteroid shape, setting the size, and selecting an appropriate noise level. Functions are great for handling the nitty-gritty detail and pushing the important decisions up to higher-level code.

## 摘要

In this chapter we’ve repeated the process of designing an item we’ll need in our game. We’ve also introduced something else. If we’re going to draw an asteroid spinning across our scene, we’ll need to store data about its shape. The use of data that’s tied to the individual item is an important concept. It’s also important to understand that writing code is a creative, problem-solving process. The code examples in this book serve as examples to demonstrate the concepts. The code didn’t appear fully formed, but each example was sculpted and perfected over many weeks. Listing [5-3](#Par12) shows how a piece of code has developed over time—in short, by starting as simple as possible and adapting the design if it doesn’t work for what you’re doing. When you write code of your own, it’s wise to expect it to be a difficult but rewarding experience. Mastery comes with practice. For now, a good way to practice is to elaborate on the examples provided. Try drawing an asteroid using a different approach. Add a new parameter that can be passed as an optional argument. Display your asteroids in an interesting way.