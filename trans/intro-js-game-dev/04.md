© Graeme Stuart 2017 Graeme StuartIntroducing JavaScript Game Development [https://doi.org/10.1007/978-1-4842-3252-1_4](04.html)

# 4.画一艘飞船

Graeme Stuart<sup class="calibre7">1 </sup> (1)Market Harborough, Leicestershire, UK   Okay, let’s get a bit more serious and start work on our game elements. The spaceship in both the classic and modern Asteroids games is based on a simple isosceles triangle. In this chapter, we’ll draw the spaceship and develop the design using quadratic curves to customize our ship. We want our ship to approximate to a circle with a given radius because later we will use “circle to circle” collision detection. So, we’re interested in locating points on the edge of a circle. Using angles and distances (polar coordinates) is the obvious way to specify the points we want, but to draw to the canvas, we need to use x and y values (Cartesian coordinates). We’ll need to get over this.

## 基础三角学

Trigonometry is going to come up a few times in this book, so its a good idea to be clear about it now. We’ll be using a very simple subset that allows us to calculate the x- and y-coordinates from angles and distances. Figure [4-1](#Fig1) shows the basic principle. The longest edge of a right-angled triangle is the straight line between the centre of a circle and a point on the circumference. If we change the angle, this affects the x- and y-coordinates in a predictable way.![A455241_1_En_4_Fig1_HTML.jpg](img/A455241_1_En_4_Fig1_HTML.jpg) Figure 4-1Sine and cosine of an angle, θ Basically all you will need to know for now is that the sine and cosine functions allow the (x, y) coordinates to be calculated from a distance (a radius) and a direction (an angle). In JavaScript , there are two corresponding methods of the Math object: Math.sin(θ) and Math.cos(θ). With these, we can calculate the x- and y-coordinates relative to the center of the circle for any given angle, θ. To convert an angle and a distance to x- and y-coordinates, simply multiply these values by the distance you need (the radius of the circle). In our diagram, the blue dotted line shows the value of the y-coordinate, calculated as r × Math.sin(θ). The red dotted line shows the value of the x-coordinate, calculated as r × Math.cos(θ).

## 一艘基本的船

Let’s put this to work. We’ll use a function to draw a ship to the canvas at a specific position, with a specific radius. Remember, we want our ship to fill a circle as completely as possible. To start, create a new folder called exercise4, copy through the stylesheet (styles.css) and drawing.js library , and add a new file exercise4.html with the code from Listing [4-1](#Par9). <!doctype html> <html>   <head>     <title>Drawing a spaceship</title>     <link rel="stylesheet" href="styles.css">     <script src="drawing.js"></script>   </head>   <body>     <h1>Drawing a spaceship</h1>     <canvas id="asteroids" width="400" height="400"></canvas>     <script>       var context = document.getElementById("asteroids").getContext("2d");       draw_grid(context);       draw_ship(context, 200, 200, 150, {guide: true});     </script>   </body> </html> Listing 4-1Template for Drawing a Ship The template loads the stylesheet and library and includes a simple three-line script . The script creates a reference to the context, draws the grid, and then draws our ship by calling the new draw_ship function with some arguments. The first argument is the context, the second and third are the x- and y-coordinates, and the fourth is the radius of the circle that contains the ship. The final argument is a bit different—it contains an object, which we’ll get to later. Our first version of the draw_ship function is shown in Listing [4-2](#Par12). Add this to the drawing.js library. function draw_ship(ctx, x, y, radius, options) {   options = options || {};   ctx.save();   // optionally draw a guide showing the collision radius   if(options.guide) {     ctx.strokeStyle = "white";     ctx.fillStyle = "rgba(0, 0, 0, 0.25)";     ctx.lineWidth = 0.5;     ctx.beginPath();     ctx.arc(x, y, radius, 0, 2 * Math.PI);     ctx.stroke();     ctx.fill();   }   // set some default values   ctx.lineWidth = options.lineWidth || 2;   ctx.strokeStyle = options.stroke || "white";   ctx.fillStyle = options.fill || "black";   let angle = (options.angle || 0.5 * Math.PI) / 2;   // draw the ship in three lines   ctx.beginPath();   ctx.moveTo(x + radius, y);   ctx.lineTo(     x + Math.cos(Math.PI - angle) * radius,     y + Math.sin(Math.PI - angle) * radius   );   ctx.lineTo(     x + Math.cos(Math.PI + angle) * radius,     y + Math.sin(Math.PI + angle) * radius   );   ctx.closePath();   ctx.fill();   ctx.stroke();   ctx.restore(); } Listing 4-2Drawing a Basic Ship The result is a basic ship . Load the template in your browser, and you should see something like Figure [4-2](#Fig2).![A455241_1_En_4_Fig2_HTML.jpg](img/A455241_1_En_4_Fig2_HTML.jpg) Figure 4-2A simple triangle ship The core of the function uses context.moveTo context.lineTo to draw three lines forming a triangle. It sets a few parameters on the context and then fills the shape and strokes the outline. But it does a lot of other stuff too. There are a few new things here that require explanation.

## 使用对象文字

Notice we’ve defined a fifth argument: options. This is an optional argument; we can see this because it’s set to an empty object ({}) if it’s undefined. The options argument allows multiple optional aspects of the ship to be set. These options are referenced using dotted notation, such as options.stroke or options.fill. If they’re not defined, default values are provided. Note Objects are extremely useful and will be used extensively in later sections. Here I introduce the object literal {} used as a simple key: value store. Object literals are specified as curly braces containing several key: value pairs, separated by commas. Keys can be anything that converts to a valid JavaScript string. Values can be anything. Empty objects are specified as a pair of curly braces ({}). Update your exercise4.html file to use the draw_ship function with different options set , as shown in Listing [4-3](#Par19). <script>   var context = document.getElementById("asteroids").getContext("2d");   draw_grid(context);   draw_ship(context, 200, 200, 125, {guide: true});   draw_ship(context, 75, 75, 50, {stroke: 'gold', fill: 'purple'});   draw_ship(context, 325, 325, 50, {angle: 0.8 * Math.PI, guide: true});   draw_ship(context, 75, 325, 50, {angle: 0.3 * Math.PI, guide: true});   draw_ship(context, 325, 75, 50, {lineWidth: 8, fill: 'blue'}); </script> Listing 4-3Setting the Ship Options The result is shown in Figure [4-3](#Fig3). Note how we can create a function that has a simple interface, and by allowing default values, a more detailed interface is also possible.![A455241_1_En_4_Fig3_HTML.jpg](img/A455241_1_En_4_Fig3_HTML.jpg) Figure 4-3Lots of ships The three corners of the ship are positioned on the radius of the circle. The front of the ship is positioned at (x + radius, y), to the right of the circle. The rear corners of the ship are determined by the angle of the ship’s nose. The angle variable is set by this line: let angle = (options.angle || 0.5 * Math.PI) / 2; It defaults to 0.5π /2\. There are 2π radians in a full circle, so 0.25π radians is 45 degrees (an eighth of a circle). The rear corners of the ship are drawn by this code: ctx.lineTo(   x + Math.cos(Math.PI - angle) * radius,   y + Math.sin(Math.PI - angle) * radius ); ctx.lineTo(   x + Math.cos(Math.PI + angle) * radius,   y + Math.sin(Math.PI + angle) * radius ); Multiplying each coordinate by radius ensures we’re always on the circle (a fixed distance from the middle). So, we’re finding the points on the circle that correspond to the angle Math.PI - angle and Math.PI + angle. One corner is positioned on the circle 45 degrees before Math.PI, and one is 45 degrees after Math.PI. Because Math.PI is half a circle, it points to the rear of the ship, and the two corners are positioned on either side of that. Look at Figure [4-3](#Fig3) and think carefully about this until you can see what is going on. Remember, the guide circle shows where collisions will be detected. Asteroids will have similar circles around them, and when the circles touch, a collision will be detected. With our ship, head-on collisions will be accurate, as will those with the rear corners, but there are large areas between the ship and the circle that will detect collisions too soon. This is something we’ll try to improve later.

## 转换画布上下文

Notice we’ve drawn the ship facing right. That’s because the 0 radians angle points to the right. But how do we rotate the ship? We’re going to need to rotate the ship around its own center and draw it at all angles in our game. Calculating all the coordinates would be long-winded and boring. A convenient way to make rotation easier is to transform the context rather than the drawing. Rotating the context always happens around the current context origin. Try drawing some rotated ships—replace your exercise4.html script as shown in Listing [4-4](#Par32). var context = document.getElementById("asteroids").getContext("2d"); context.lineWidth = 0.5; context.strokeStyle = "white"; let x = context.canvas.width * 0.9; let y = 0; let radius = context.canvas.width * 0.1; draw_grid(context); for(let r = 0; r <= 0.5 * Math.PI; r += 0.05 * Math.PI) {   context.save()   context.rotate(r);   draw_ship(context, x, y, radius, {guide: true});   context.beginPath();   context.moveTo(0, 0);   context.lineTo(x, 0);   context.stroke();   context.restore() } Listing 4-4Rotating the Canvas context Rotating the context is just like it sounds. Imaging holding a pen over some paper and literally rotating the paper around, drawing our ship, pointing to the right, and then returning the paper back to its original position. This allows us to draw our ship pointing in any direction we want. Importantly, the rotation happens around the canvas origin, which, as we know from our grid labels, is the top-left corner. Now imagine holding the top-left corner of your paper still and rotating the paper around it. In each iteration we save the context, rotate it, draw the ship and a line, and then restore the context back to its original state. This means the rotation is always applied to the un-rotated context because we’re rotating by a larger angle each time we draw the ship at a different angle. Because we’re rotating about the origin, the ship is always the same distance away from the top-left corner. In each iteration we also draw a line from the origin to the center of the ship. This line is also rotated, but the origin remains in the top-left corner. Figure [4-4](#Fig4) shows the result.![A455241_1_En_4_Fig4_HTML.jpg](img/A455241_1_En_4_Fig4_HTML.jpg) Figure 4-4Rotating about the origin In our game, we need to rotate the ship about its central point, not the top-left corner of the canvas. To do that we need to move the context origin before we rotate it. Crucially, when we rotate the canvas, it rotates around the origin, so if we move the origin then we can control the rotation. In our game, we’ll store the ship position and the ship angle. We will translate and rotate the context before drawing the ship. This means we’ll always be drawing to the new origin, so we’ll need to adjust the ship drawing function to remove the coordinates and just draw at (0, 0) every time. Replace all references to x and y with 0 (zero), as shown in Listing [4-5](#Par37). function draw_ship(ctx, radius, options) {   options = options || {};   ctx.save();   if(options.guide) {     ctx.strokeStyle = "white";     ctx.fillStyle = "rgba(0, 0, 0, 0.25)";     ctx.lineWidth = 0.5;     ctx.beginPath();     ctx.arc(0, 0, radius, 0, 2 * Math.PI);     ctx.stroke();     ctx.fill();   }   ctx.lineWidth = options.lineWidth || 2;   ctx.strokeStyle = options.stroke || "white";   ctx.fillStyle = options.fill || "black";   let angle = (options.angle || 0.5 * Math.PI) / 2;   ctx.beginPath();   ctx.moveTo(radius, 0);   ctx.lineTo(     Math.cos(Math.PI - angle) * radius,     Math.sin(Math.PI - angle) * radius   );   ctx.lineTo(     Math.cos(Math.PI + angle) * radius,     Math.sin(Math.PI + angle) * radius   );   ctx.closePath();   ctx.fill();   ctx.stroke();   ctx.restore(); } Listing 4-5Draw at the Current Origin We can now draw the ship in any position we like by translating the canvas (using calls to context.translate) and rotating the canvas (with context.rotate) before drawing the ship at point (0, 0). When transforming the canvas like this, we must be careful to save and restore the canvas state—otherwise we can lose track. In Listing [4-6](#Par39) we rotate and translate the canvas without restoring it, and the rotations and translations accumulate to produce a nice but unintentional spiral, as shown in Figure [4-5](#Fig5). let t = context.canvas.width / 20; let r = Math.PI / 500; context.translate(0, t); for(let i = 0; i <= 50; i ++) {   context.rotate(i * r);   draw_ship(context, t, {guide: true, lineWidth: 1});   context.translate(t, 0); } Listing 4-6Combining Rotate and Translate ![A455241_1_En_4_Fig5_HTML.jpg](img/A455241_1_En_4_Fig5_HTML.jpg) Figure 4-5Losing track of the canvas state A better approach is to maintain variables (that is, x, y, and angle) that determine the position and angle of the ship. In this way, we can save the untransformed context, apply the transformations, draw the ship, and finally restore the context. This allows us to draw the ship in any location and pointing in any direction we choose. Listing [4-7](#Par42) loops over x and y positions in a nested loop and draws a small ship in each position. Each ship is drawn with a slightly bigger angle. Notice that the code within the save and restore calls is very generic. It’s the code that controls our variables that is doing the work. Figure [4-6](#Fig6) shows the ships all lined up obediently. let x, y, angle = 0; let w = context.canvas.width, h = context.canvas.height for(y = h/20; y < h; y += h/10) {   for(x = w/20; x < w; x += w/10) {     context.save();     context.translate(x, y);     context.rotate(angle);     draw_ship(context, w/30, {guide: true, lineWidth: 1});     context.restore();     angle = (angle + 0.0075 * Math.PI);   } } Listing 4-7Controlling Variables ![A455241_1_En_4_Fig6_HTML.jpg](img/A455241_1_En_4_Fig6_HTML.jpg) Figure 4-6Controlled ship drawing using canvas transformations

## 添加一些曲线

The ship is looking nice, but it’s a bit boxy. The next step is to take control of the curves. Luckily, that’s really simple. The first thing to do is identify a straight line that we want to turn into a curve. The rear of the ship is the obvious first choice. Now, for a quadratic curve we need a single control point that will “pull” the straight line into a curve. In this case, it will be a point towards the back of the ship on the central line of the ship, where the y-coordinate is 0\. With this decided, we can convert one context.lineTo call to a context.quadraticCurveTo call. Update your draw_ship function , as shown in Listing [4-8](#Par44). function draw_ship(ctx, radius, options) {   options = options || {};   let angle = (options.angle || 0.5 * Math.PI) / 2;   // this is new   let curve = options.curve || 0.5;   ctx.save();   if(options.guide) {     ctx.strokeStyle = "white";     ctx.fillStyle = "rgba(0, 0, 0, 0.25)";     ctx.lineWidth = 0.5;     ctx.beginPath();     ctx.arc(0, 0, radius, 0, 2 * Math.PI);     ctx.stroke();     ctx.fill();   }   ctx.lineWidth = options.lineWidth || 2;   ctx.strokeStyle = options.stroke || "white";   ctx.fillStyle = options.fill || "black";   ctx.beginPath();   ctx.moveTo(radius, 0);   ctx.lineTo(     Math.cos(Math.PI - angle) * radius,     Math.sin(Math.PI - angle) * radius   );   // here we have added a control point based on the curve variable   ctx.quadraticCurveTo(radius * curve - radius, 0,     Math.cos(Math.PI + angle) * radius,     Math.sin(Math.PI + angle) * radius   );   ctx.closePath();   ctx.fill();   ctx.stroke();   // a new guide line and circle show the control point   if(options.guide) {     ctx.strokeStyle = "white";     ctx.lineWidth = 0.5;     ctx.beginPath();     ctx.moveTo(-radius, 0);     ctx.lineTo(0, 0);     ctx.stroke();     ctx.beginPath();     ctx.arc(radius * curve - radius, 0, radius/50, 0, 2 * Math.PI);     ctx.stroke();   }   ctx.restore(); } Listing 4-8Using Quadratic Curves We’ve added a new optional variable called curve. The default value is 0.5\. When we draw the line between the rear corners of the ship, we now use a quadratic curve rather than a straight line. The control point for the curve is on the central axis of the ship. If the value of curve is 0, then the control point in on the radius of the circle. If the value of curve is set to 1, then the control point is the center of the circle. Now, to test the function we’ll randomize the new argument and draw a large ship in the center of the canvas. Each time the page is refreshed (for example, by pressing Ctrl+R), a new value will be selected, and the canvas will update: context.translate(200, 200); draw_ship(context, 150, {curve: Math.random(), guide: true}); We also add a new section of guide code to draw the control point on top of the ship. We draw a filled dot at the position of the control point to help show how the curve is constructed. We also draw a line to show the potential extent of the control point (between 0 and 1). Notice that the curve doesn’t necessarily pass through the dot but is drawn towards it. You should see something like Figure [4-7](#Fig7).![A455241_1_En_4_Fig7_HTML.jpg](img/A455241_1_En_4_Fig7_HTML.jpg) Figure 4-7Adding a curve Try setting the value of curve manually. Values below 0 and above 1 are valid up to a point. Make sure you understand what’s happening here. As noted before, the ship should be drawn as close to the circle edge as possible so that collisions are more accurate. Though we’re relaxed about the shape, we want its position and size to match the circle as closely as possible. The final embellishment we’ll add to the spaceship design is to draw the sides as quadratic curves. This can be done in many ways, here we’ll place a control point on either side of the ship at opposite points to the rear corners. We’ll specify the position in the circle as an argument. This is the position (from 0 to 1, center to radius) at which the control point will be placed. Larger numbers will pull the sides out so they fill more of the space inside the circle, smaller numbers will pull the sides inwards. Listing [4-9](#Par53) shows the final code . function draw_ship(ctx, radius, options) {   options = options || {};   let angle = (options.angle || 0.5 * Math.PI) / 2;   // Now we have two curve arguments   let curve1 = options.curve1 || 0.25;   let curve2 = options.curve2 || 0.75;   ctx.save();   if(options.guide) {     ctx.strokeStyle = "white";     ctx.fillStyle = "rgba(0, 0, 0, 0.25)";     ctx.lineWidth = 0.5;     ctx.beginPath();     ctx.arc(0, 0, radius, 0, 2 * Math.PI);     ctx.stroke();     ctx.fill();   }   ctx.lineWidth = options.lineWidth || 2;   ctx.strokeStyle = options.stroke || "white";   ctx.fillStyle = options.fill || "black";   ctx.beginPath();   ctx.moveTo(radius, 0);   // here we have the three curves   ctx.quadraticCurveTo(     Math.cos(angle) * radius * curve2,     Math.sin(angle) * radius * curve2,     Math.cos(Math.PI - angle) * radius,     Math.sin(Math.PI - angle) * radius   );   ctx.quadraticCurveTo(-radius * curve1, 0,     Math.cos(Math.PI + angle) * radius,     Math.sin(Math.PI + angle) * radius   );   ctx.quadraticCurveTo(     Math.cos(-angle) * radius * curve2,     Math.sin(-angle) * radius * curve2,     radius, 0   );   ctx.fill();   ctx.stroke();   // the guide drawing code is getting complicated   if(options.guide) {     ctx.strokeStyle = "white";     ctx.fillStyle = "white";     ctx.lineWidth = 0.5;     ctx.beginPath();     ctx.moveTo(       Math.cos(-angle) * radius,       Math.sin(-angle) * radius     );     ctx.lineTo(0, 0);     ctx.lineTo(       Math.cos(angle) * radius,       Math.sin(angle) * radius     );     ctx.moveTo(-radius, 0);     ctx.lineTo(0, 0);     ctx.stroke();     ctx.beginPath();     ctx.arc(       Math.cos(angle) * radius * curve2,       Math.sin(angle) * radius * curve2,       radius/40, 0, 2 * Math.PI     );     ctx.fill();     ctx.beginPath();     ctx.arc(       Math.cos(-angle) * radius * curve2,       Math.sin(-angle) * radius * curve2,       radius/40, 0, 2 * Math.PI     );     ctx.fill();     ctx.beginPath();     ctx.arc(radius * curve1 - radius, 0, radius/50, 0, 2 * Math.PI);     ctx.fill();   }   ctx.restore(); } Listing 4-9Curvy Ships The changes are actually quite small—we’re only adding some control points calculated using simple trigonometry as described earlier. The majority of the additional code is actually for drawing the control points! Focus on the changes in the main code. We’ve changed the options.curve value into options.curve1 and options.curve2\. The two remaining calls to context.lineTo have been converted to calls to context.quadraticCurveTo and have specified the control points. Again, calling it is straightforward: context.translate(200, 200); draw_ship(context, 150, {   curve1: Math.random(),   curve2: Math.random(),   guide: true }); Try this and you should get something like Figure [4-8](#Fig8). Refresh the page (Ctrl+R) and you should see random variants drawn each time .![A455241_1_En_4_Fig8_HTML.jpg](img/A455241_1_En_4_Fig8_HTML.jpg) Figure 4-8A fully curved spaceship Try the code in Listing [4-10](#Par59) to check out some of the alternative ships we can draw with our new method . You should end up with something like Figure [4-9](#Fig9). var context = document.getElementById("asteroids").getContext("2d"); draw_grid(context); let c1 = 0, c2 = 0; for(c1=0.1; c1<1; c1+=0.2) {   for(c2=0.1; c2<1; c2+=0.2) {     context.save();     context.translate(context.canvas.width * c1, context.canvas.height * c2)     context.rotate(-Math.PI/2);     draw_ship(context, context.canvas.width / 12, {curve1: c1, curve2: c2, guide : true});     context.restore();   } } Listing 4-10Drawing Multiple Variations ![A455241_1_En_4_Fig9_HTML.jpg](img/A455241_1_En_4_Fig9_HTML.jpg) Figure 4-9A series of alternative spaceships Now we have a complete, fully configurable ship drawing function we can use in our game by simply importing our drawing.js library. Adding structure by defining your own functions makes complex code far easier to comprehend.

## 摘要

This chapter has developed the ideas from Chapter [3](03.html) significantly. We’ve drawn a more complicated shape and developed the design from a simple triangle into a curvy delight. We’ve learned about translating and rotating the canvas. These will be important concepts later on, so you need to be sure you understand them pretty well. They allow us to work with our drawing function in an extremely flexible way. A crucial observation is that as our drawing function becomes more and more complicated, the code with which we call our drawing function hardly changes at all. This is how we manage complexity in general, by abstracting ideas such as draw a ship into functions and calling the function whenever we need to “draw a ship.” Try developing your own draw_ship function. Keep the guide circle code and try to draw as close to the edges as you can. Does it matter if you go over the edges a bit?