© Graeme Stuart 2017 Graeme StuartIntroducing JavaScript Game Development [https://doi.org/10.1007/978-1-4842-3252-1_11](11.html)

# 11.控制飞船

Graeme Stuart<sup class="calibre7">1 </sup> (1)Market Harborough, Leicestershire, UK   In this chapter we’ll finally implement user control of the ship. This is where all the hard work in setting up our objects will begin to pay off. At the end of this chapter you’ll be able to fly the ship gracefully around the canvas and even shoot projectiles from the nose of the ship. As with the Pac-Man example, we’ll need to add some properties to our ship class so we can use keyboard events to control the ship. The ship remains a mass floating in space, so we only want to use the Mass.prototype.push and Mass.prototype.twist methods to do the actual moving. Copy exercise9.html and all related files (styles.css and the libraries drawing.js and objects.js) into a new folder and rename the HTML file as exercise11.html. Remove all the ship-controlling stuff from the global update function.

## 推进器控制

Starting simply, the ship needs a thruster. When the thruster is on, the ship will be pushed forwards. When the thruster is off, the ship will behave as normal. Update the Ship constructor with the code in Listing [11-1](#Par4). function Ship(x, y, power) {   this.super(x, y, 10, 20, 1.5 * Math.PI);   this.thruster_power = power;   this.thruster_on = false; } Listing 11-1 Ship Thruster Properties We’ve added two properties to the ship. The thruster_power property determines how much force is applied to the ship when the thruster is on. The thruster_on property determines whether the thruster is on. The thruster is initialized to off (that is, thrusters_on is set to false). We also make the ship mass and size configurable. Update the ship instantiation in exercise11.html to match Listing [11-2](#Par6). var ship = new Ship(context.canvas.width / 2, context.canvas.height / 2, 1000); Listing 11-2Create a Nice Ship Now we need to add a Ship.prototype.update method because the standard Mass.prototype.update method isn't good enough any more. We want to push the ship in the direction it’s pointing using the correct power, but only if this.thruster_on is true. So, we call the this.push method with the angle (this.angle) and this.thruster_power multiplied by the Boolean value this.thruster_on, as shown in Listing [11-3](#Par8). Boolean values are cast automatically to 1 or 0, so the result is exactly what we need to calculate the force and apply it over the elapsed time. Ship.prototype.update = function(elapsed) {   this.push(this.angle, this.thruster_on * this.thruster_power, elapsed);   Mass.prototype.update.apply(this, arguments); } Listing 11-3The Ship.prototype.update Method We then call the Mass.prototype.update method. We can’t call it on the this keyword because we’ve overwritten the method on the Ship.prototype. Consequently, we need to use function.apply to call the Mass.prototype.update method, passing in our this keyword to reference the ship instance and the arguments list passed into the function. This is a generic way to call methods of a parent class when the child class has overridden them. Now that we’ve adapted the behavior of the ship, we should be able to refresh the browser and turn on the thrusters via the console. Type ship.thruster_on = true into the console and check that the ship responds correctly. We can add some visual feedback on the thruster state by updating the draw_ship function. First, we should pass the ship.thruster_on property into the call to draw_ship, as shown in Listing [11-4](#Par12). Ship.prototype.draw = function(c, guide) {   c.save();   c.translate(this.x, this.y);   c.rotate(this.angle);   draw_ship(c, this.radius, {     guide: guide,     thruster: this.thruster_on   });   c.restore(); } Listing 11-4The Ship.prototype.draw Method Now add the code snippet in Listing [11-5](#Par14) into the draw_ship function before the ship is drawn. We draw a simple filled red curve with a yellow outline and we put this before the ship is drawn so that the ship will hide the overlap and it appears neat. if(options.thruster) {   ctx.save();   ctx.strokeStyle = "yellow";   ctx.fillStyle = "red";   ctx.lineWidth = 3;   ctx.beginPath();   ctx.moveTo(     Math.cos(Math.PI + angle * 0.8) * radius / 2,     Math.sin(Math.PI + angle * 0.8) * radius / 2   )   ctx.quadraticCurveTo(-radius * 2, 0,     Math.cos(Math.PI - angle * 0.8) * radius / 2,     Math.sin(Math.PI - angle * 0.8) * radius / 2   );   ctx.fill();   ctx.stroke();   ctx.restore(); } Listing 11-5Addition to the draw_ ship Function Now, setting the ship.thruster_on property to true will make the ship move and will also draw a filled red curve at the rear of the ship. Figure [11-1](#Fig1) shows the result of turning the thruster on via the browser console.![A455241_1_En_11_Fig1_HTML.jpg](img/A455241_1_En_11_Fig1_HTML.jpg) Figure 11-1Thruster indicator We’ll complete this first step with a pair of event handlers, one for keydown and one for keyup. First, add the helper function to do the actual ship control, as shown in Listing [11-6](#Par17). function key_handler(e, value) {   var nothing_handled = false;   switch(e.key || e.keyCode) {     case "ArrowUp":     case 38: // up arrow       ship.thruster_on = value;       break;     default:       nothing_handled = true;   }   if(!nothing_handled) e.preventDefault(); } Listing 11-6Control the Ship Thruster This function takes an event and a value as arguments. If the key that triggered the event is the up arrow ("ArrowUp" or 38), then it sets the ship.thruster_on property to whatever value is passed to it. Finally, we connect the event handler function to event listeners on the canvas, as shown in Listing [11-7](#Par19). context.canvas.addEventListener("keydown", function(e) {   key_handler(e, true); }, true); context.canvas.addEventListener("keyup", function(e) {   key_handler(e, false); }, true); Listing 11-7Event Handlers to Do the Job Finally, we also need to set the tabindex of the canvas and call canvas.focus(), as in the preceding exercise. Once we’ve done this, we should find that pressing and releasing the up arrow controls the thruster!

## 指导

The real fun begins when we hook up the steering . Update the Ship constructor to reflect Listing [11-8](#Par22). function Ship(x, y, power) {   this.super(x, y, 10, 20, 1.5 * Math.PI);   this.thruster_power = power;   this.steering_power = power / 20;   this.right_thruster = false;   this.left_thruster = false;   this.thruster_on = false; } extend(Ship, Mass); Listing 11-8Add Steering Properties Now use the new properties to twist the ship at every frame, as shown in the Ship.prototype.update method in Listing [11-9](#Par24). We take the difference between the this.right_thruster and this.left_thruster to determine the twisting force to apply. If both are on or neither is on, the result is zero. Otherwise, it’s either –1 or +1\. This is multiplied by the steering force. Ship.prototype.update = function(elapsed, c) {   this.push(this.angle, this.thruster_on * this.thruster_power, elapsed);   this.twist((this.right_thruster - this.left_thruster) * this.steering_power, elapsed);   Mass.prototype.update.apply(this, arguments); } Listing 11-9Twist the Ship with Thrusters Finally, update the key_handler function to respond to left and right arrows, as shown in Listing [11-10](#Par26). function key_handler(e, value) {   var nothing_handled = false;   switch(e.key || e.keyCode) {     case "ArrowUp":     case 38: // up arrow       ship.thruster_on = value;       break;     case "ArrowLeft":     case 37: // left arrow       ship.left_thruster = value;       break;     case "ArrowRight":     case 39: // right arrow       ship.right_thruster = value;       break;     case "g":     case 71: //g       if(value) guide = !guide;     default:       nothing_handled = true;   }   if(!nothing_handled) e.preventDefault(); } Listing 11-10Control Thrusters with Arrow Keys Refresh the browser and give it a try. Now it feels a lot like a working game! Fly around the canvas in triumph as you learn how to control the ship. Notice we’ve added a response to the G key that toggles a new guide variable. Have a go at implementing this. You’ll need to define the global guide variable and initialize it to true. You’ll also need to pass it into the draw methods of your asteroids and ship and use it to determine whether the grid is drawn.

## 射击

To shoot, we need to introduce a new Projectile class. The Projectile class inherits from Mass just like Asteroid and Ship. We throw projectiles out from the front of the ship and hope they hit asteroids. Add the basic Projectile class from Listing [11-11](#Par30) into your objects.js library. Start with the constructor—this is very similar to an asteroid except that a new lifetime argument is provided and saved to a property. We also create a life property and initialize it to 1.0. function Projectile(mass, lifetime, x, y, x_speed, y_speed, rotation_speed) {   var density = 0.001; // low density means we can see very light projectiles   var radius = Math.sqrt((mass / density) / Math.PI);   this.super(mass, radius, x, y, 0, x_speed, y_speed, rotation_speed);   this.lifetime = lifetime;   this.life = 1.0; } extend(Projectile, Mass); Listing 11-11The Projectile Constructor Notice we also extend from Mass. The Projectile class has special behavior in that it’s instantiated with a finite lifetime and will be removed from the game when that lifetime has run its course. This avoids accumulating an ever-growing number of projectiles that would drain system resources. Listing [11-12](#Par32) shows that the projectile updates its own remaining life property from the initial 1.0 by decrementing it at each frame proportional to the elapsed time. Otherwise, it’s a simple Mass with a very low density. Projectile.prototype.update = function(elapsed, c) {   this.life -= (elapsed / this.lifetime);   Mass.prototype.update.apply(this, arguments); } Listing 11-12The Projectile.prototype.update Method As shown in Listing [11-13](#Par34), drawing is very familiar. The only thing to note is that we pass this.life to the drawing function. Projectile.prototype.draw = function(c, guide) {   c.save();   c.translate(this.x, this.y);   c.rotate(this.angle);   draw_projectile(c, this.radius, this.life, guide);   c.restore(); } Listing 11-13The Projectile.prototype.draw Method Implement a draw_projectile function in your drawing.js library. Using Listing [11-14](#Par36) as a template, we use the life argument to set the fill color. Remember to call context.beginPath(). function draw_projectile(ctx, radius, lifetime) {   ctx.save();   ctx.fillStyle = "rgb(100%, 100%, " + (100 * lifetime) + "%)";   // *****************************************   // **         your code goes here         **   // **    draw a path to fill the radius   **   // *****************************************   ctx.fill();   ctx.restore(); } Listing 11-14Template for Drawing a Projectile Now that we have projectiles, we need a mechanism for adding them to the game data and for hooking them up to the game loop. Mostly this is as expected. We initialize an empty array of projectiles, as shown in Listing [11-15](#Par38). var asteroid = new Asteroid(   10000,   Math.random() * context.canvas.width,   Math.random() * context.canvas.height ); asteroid.push(Math.random() * 2 * Math.PI, 1000, 60); asteroid.twist(Math.random() * 100, 60); var ship = new Ship(10, 15, context.canvas.width / 2, context.canvas.height / 2, 1000, 200); var projectiles = []; // new array Listing 11-15Add an Empty Array for Projectiles Then we draw projectiles in the usual way, as shown in Listing [11-16](#Par40). function draw() {   if(guide) {     draw_grid(context);   }   asteroid.draw(context, guide);   projectiles.forEach(function(p) {     p.draw(context);   });   ship.draw(context, guide); } Listing 11-16Hook Up Projectiles in the draw Function The update function in Listing [11-17](#Par42) has a few surprises. We update the projectiles as expected in a forEach loop over the array. Then we check the value of projectile.life. If the value is 0 or less, we call the array.prototype.splice method on our projectiles array to remove the dead projectile. This removes all references to the projectile, and it gets removed from memory. function update(elapsed) {   asteroid.update(elapsed, context);   ship.update(elapsed, context);   projectiles.forEach(function(projectile, i, projectiles) {     projectile.update(elapsed, context);     if(projectile.life <= 0) {       projectiles.splice(i, 1);     }   });   if(ship.trigger) {     projectiles.push(ship.projectile(elapsed));   } } Listing 11-17Hook Up Projectiles in the update Function After the loop, we check a new property: ship.trigger. If it’s set, we push a new projectile onto the projectiles array. We get the projectile by calling ship.projectile and passing in the elapsed time. Let’s create the new projectiles in the new Ship.prototype.projectile method. We add this method to the Ship class for a number of reasons—mainly because it makes sense for the ship to generate projectiles. From a practical point of view, we need to access some of the ship’s properties in order to create a projectile with the correct behavior. Alternatively, you could do this by passing the ship instance to another function. Listing [11-18](#Par45) has the code. Ship.prototype.projectile = function(elapsed) {   var p = new Projectile(0.025, 1,     this.x + Math.cos(this.angle) * this.radius,     this.y + Math.sin(this.angle) * this.radius,     this.x_speed,     this.y_speed,     this.rotation_speed   );   p.push(this.angle, this.weapon_power, elapsed);   this.push(this.angle + Math.PI, this.weapon_power, elapsed);   return p; } Listing 11-18Create Projectiles with the Ship.prototype. projectile Method The first expression creates a new Projectile and assigns it to the variable, p. It’s created with a fixed mass of 0.025 (very light compared to the ship, this is important). The lifetime argument is set to 1 second. The (x, y) coordinates are calculated to place the projectile at the front of the ship. The (x_speed, y_speed) velocity of the projectile is initialized to that of the ship, as is the rotation_speed. The next two expressions ensure that we adhere to Newton’s third law. We push the projectile in the direction the ship is pointing in with the force determined by a new property of the ship, weapon_power. Then we push the ship back with the same force. So, it’s important that the mass of the projectile is very small relative to the mass of the ship. When we apply the same force to both, the projectile is accelerated much more than the ship. The new property weapon_power must exist on the ship. Create it in the Ship constructor function, as shown in Listing [11-19](#Par48). Make sure you also give the ship a value for weapon_power when you instantiate it (I’ve given it a default value just in case). function Ship(mass, radius, x, y, power, weapon_power) {   this.super(mass, radius, x, y, 1.5 * Math.PI);   this.thruster_power = power;   this.steering_power = this.thruster_power / 20;   this.right_thruster = false;   this.left_thruster = false;   this.thruster_on = false;   this.weapon_power = weapon_power || 200; } extend(Ship, Mass); Listing 11-19Update the Ship Constructor The final line of the Ship.prototype.projectile method returns our projectile so we can add it to our projectiles array as shown earlier in the global update function. Now if ship.trigger is set to true, we’ll create new projectiles and fire them out from the front of the ship. Once the projectile has been alive for one second, it’s removed from play. The last step is simple. We update our key_handler to connect the spacebar to the ship.trigger property, as shown in Listing [11-20](#Par51). function key_handler(e, value) {   var nothing_handled = false;   switch(e.key || e.keyCode) {     case "ArrowUp":     case 38: // up arrow       ship.thruster_on = value;       break;     case "ArrowLeft":     case 37: // left arrow       ship.left_thruster = value;       break;     case "ArrowRight":     case 39: // right arrow       ship.right_thruster = value;       break;     case " ":     case 32: //spacebar       ship.trigger = value;       break;     case "g":       if(value) guide = !guide;     default:       nothing_handled = true;   }   if(!nothing_handled) e.preventDefault(); } Listing 11-20Hooking Up the key_ handler Take the time to study how this works and make sure you understand it. When the spacebar is pressed, ship.trigger becomes true. From this we’re adding new projectiles into our array on every frame. Projectiles are removed from the array when their lifetime is up. Figure [11-2](#Fig2) shows the result.![A455241_1_En_11_Fig2_HTML.jpg](img/A455241_1_En_11_Fig2_HTML.jpg) Figure 11-2Shooting a stream of projectiles Refresh your browser and try it out. Notice that the ship is being pushed back by the projectiles as intended. We’re creating projectiles at an extremely fast rate, one per frame. We should throttle this in order to make the game more challenging and keep down the number of projectiles in play. Add a new restriction to the global update function; replace the existing conditional statement with the code from Listing [11-21](#Par55). if(ship.trigger && ship.loaded) {   projectiles.push(ship.projectile(elapsed)); } Listing 11-21Throttle the Projectile Creation Here we’re specifying that the ship’s weapon must be loaded before it can be fired. Update your Ship constructor with the new code in Listing [11-22](#Par57). this.loaded = false; this.weapon_reload_time = 0.25; // seconds this.time_until_reloaded = this.weapon_reload_time; Listing 11-22Update the Ship Constructor Again We’re initializing the ship weapon to be not loaded. We’re defining the time it will take for the weapon to reload. And we’re setting a property to record how much time there is left until the weapon is reloaded. Now add the few lines of Listing [11-23](#Par59) to the Ship.prototype.update method. // reload as necessary this.loaded = this.time_until_reloaded === 0; if(!this.loaded) {   this.time_until_reloaded -= Math.min(elapsed, this.time_until_reloaded); } Listing 11-23Control the Reload Time This simple piece of code controls the ship.loaded property. It will be true whenever the this.time_until_reloaded property is equal to 0\. This, in turn, is decremented every frame by the elapsed time. If the elapsed time is greater than the this.time_until_reloaded property, then it will be set to 0\. This alone will ensure that we must wait the 0.25 seconds specified in this.weapon_reload_time before we can fire the weapon the first time. Once the weapon is fired, we need to reset the this.time_until_reloaded property to the value of this.weapon_reload_time. Add this line to the Ship.prototype.projectile method before the line that returns the projectile: this.time_until_reloaded = this.weapon_reload_time; Now refresh the page and behold! You should have something like Figure [11-3](#Fig3).![A455241_1_En_11_Fig3_HTML.jpg](img/A455241_1_En_11_Fig3_HTML.jpg) Figure 11-3Shooting is now restricted by the weapon reload time The ship is now shooting at the rate you prescribed with this.weapon_reload_time. If you change the property, the rate of fire will adjust accordingly. This is a good target for a powerup to decrease the weapon reload time. Also perhaps the projectile lifetime property might be a good one to increase to give a concrete advantage to the player. For practice, implement a retro-thruster that can be triggered with the down arrow key. Think about how to integrate it with the existing mechanism. Look at how we combine ship.left_thruster and ship.right_thruster in the Ship.prototype.update method. Try to replicate this using a ship.retro_on property. Don’t worry about drawing the retro-thrusters unless you really want to (in which case, you may want to draw the left and right thrusters too).

## 摘要

In this chapter we added a lot of controllable properties to our ship object. We connected event listeners to allow us to control the ship’s movement. We’ve introduced a projectile object and triggered projectile generation via a function on the ship. We call this function when the spacebar is pressed but only once every quarter-second. We also managed the projectiles population so they’re destroyed after one second in play. This chapter has been a very quick addition of new functionality. If you encounter any problems, go through the chapter again carefully until you’re crystal clear on what has happened.