© Graeme Stuart 2017 Graeme StuartIntroducing JavaScript Game Development [https://doi.org/10.1007/978-1-4842-3252-1_2](02.html)

# 2.理解路径

Graeme Stuart<sup class="calibre7">1 </sup> (1)Market Harborough, Leicestershire, UK   Chapter [1](01.html) introduced some of the basic methods for drawing to the canvas. This chapter presents a follow-up exercise that looks more closely at the canvas coordinate system and explores how to construct paths. These concepts are critical to understanding the canvas and designing your own drawing code. We’ll also start to add a bit more structure to our code. Complex code can be difficult to comprehend—adding structure is the main way to keep the complexity under control. Structuring code into functions allows the development of simpler code that uses those functions. This chapter introduces functions and goes through the process of refactoring, a crucial skill that’s necessary to manage code of any complexity.

## 整理您的文件

To get started, we are going to organize our HTML document in a more traditional way. In Chapter [1](01.html), we simply included the styling information in a <style> element. To remove clutter and make the styles reusable, we’re going to move the styles into a separate file. Create a file called exercise2.html and start with the basic template shown in Listing [2-1](#Par4). <!doctype html> <html>   <head>     <title>More drawing to canvas</title>     <link rel="stylesheet" href="styles.css">   </head>   <body>     <h1>More drawing to canvas</h1>     <canvas id="asteroids" width="400" height="400"></canvas>     <script>       var canvas = document.getElementById("asteroids");       var context = canvas.getContext("2d");       // Grid drawing code goes here     </script>   </body> </html> Listing 2-1A Basic Template We’ve added a <link> element that refers to an external stylesheet called styles.css. Create the styles.css file and add the rules from Listing [2-2](#Par6). Both files should be saved in the same folder. It’s usually a good idea to have a folder exclusively for these two files. body {   text-align: center;   font-family: sans-serif; }   canvas {   background-color: black; } Listing 2-2A Standard Stylesheet Load exercise2.html into your browser. We have a blank canvas, so let’s put something on it.

## 画布网格系统

We saw in Chapter [1](01.html) that the canvas has a coordinates system. The origin (0, 0) is in the top-left corner. The canvas is canvas.width pixels wide and canvas.height pixels high. Let’s make these coordinates visible by drawing a grid. Start by setting the stroke color and line width. Add the following lines into your <script> tag after the comment "Grid drawing code goes here": context.strokeStyle = "#00FF00"; context.lineWidth = 0.25; Now we use a for loop to increment the x-coordinate from 0 to the canvas width in 10-pixel steps, drawing the vertical grid lines in each iteration. Within the loop we move the current path position to the top of the canvas at our x-coordinate and draw a line all the way to the bottom of the canvas. Keeping the x-coordinate unchanged between the context.moveTo and context.lineTo calls ensures we get a vertical line each time: for(var x = 0; x < canvas.width; x += 10) {   context.moveTo(x, 0);   context.lineTo(x, canvas.height); } If you refresh the page, nothing is drawn. That’s because we’re still only building a path and haven’t yet asked for it to be drawn. Repeat the same pattern with the horizontal grid lines: for(var y = 0; y < canvas.height; y += 10) {   context.moveTo(0, y);   context.lineTo(canvas.width, y); } Again, we’re drawing each horizontal line in turn from the left of the canvas (x = 0) to the right (x = canvas.width). The y-coordinate starts at 0 and increases by 10 pixels each iteration until it reaches canvas.height. Nothing is actually drawn to the canvas until we call context.stroke() : context.stroke(); This then draws the path onto the canvas, as shown in Figure [2-1](#Fig1).![A455241_1_En_2_Fig1_HTML.jpg](img/A455241_1_En_2_Fig1_HTML.jpg) Figure 2-1A basic grid pattern We’d like to have a major/minor grid system so we can easily pick out coordinates. To do this we need every fifth line to be thicker. But as we currently do it, we have no control over the line width. The context.stroke method we call at the end of the code applies the current stroke style and line width to the entire current path. This means all the lines will have the same width. If we want to give them different widths, we need to split the drawing into multiple paths, one for each line. To do that, we need to call both context.beginPath and context.stroke within our loops. Being careful not to remove any of the initial template code, replace the grid drawing code (everything after the comment "Grid drawing code goes here") with the code in Listing [2-3](#Par20). context.strokeStyle = "#00FF00"; for(var x = 0; x < canvas.width; x += 10) {   context.beginPath();   context.moveTo(x, 0);   context.lineTo(x, canvas.height);   context.lineWidth = (x % 50 == 0) ? 0.5 : 0.25;   context.stroke(); } for(var y = 0; y < canvas.height; y += 10) {   context.beginPath();   context.moveTo(0, y);   context.lineTo(canvas.width, y);   context.lineWidth = (y % 50 == 0) ? 0.5 : 0.25;   context.stroke(); } Listing 2-3Altering Line Thickness Now, within each loop we’re calling context.beginPath to start a new path and discard any previous path data. We draw the line as before and then set the line width using a ternary operator . The ternary operator is a compact one-line if statement of the form result = boolean ? value_if_true : value_if_false. Here we’re setting the line width, so if the current x or y coordinate is divisible by 50 (determined using the modulo operator, x % 50 == 0), we make the line width a bit thicker. Finally, we call context.stroke within the loop to draw each line in turn. The resulting grid is shown in Figure [2-2](#Fig2).![A455241_1_En_2_Fig2_HTML.gif](img/A455241_1_En_2_Fig2_HTML.gif) Figure 2-2 Major/minor grid lines To complete our canvas graph paper, we need some axes. Because we can’t draw outside of the canvas, we’ll squeeze some labels in at the edges. First, we need to set a fill color so we can use canvas.fillText. Add the following line to your script, above the loops: context.fillStyle = "#009900"; Now, within each loop we’ll draw a label next to the major (thicker) grid lines. Add this line at the end of the x-coordinate loop: if(x % 50 == 0 ) {context.fillText(x, x, 10);} Similarly, add the equivalent line at the end of the y-coordinate loop : if(y % 50 == 0 ) {context.fillText(y, 0, y + 10);} The result is shown in Figure [2-3](#Fig3).![A455241_1_En_2_Fig3_HTML.jpg](img/A455241_1_En_2_Fig3_HTML.jpg) Figure 2-3Major grid labels Now it should be very clear how the coordinates system works. Each of the thicker lines has a coordinate value drawn next to it. The origin is clearly in the top-left corner, and we’re ready to draw on top of our grid.

## 尽早重构，经常重构

Now that we have a potentially useful piece of functionality (a grid showing coordinates) we should immediately think about making it reusable. Rather than copying the raw code into every script, we can refactor the code into a function and include it in a code library (a separate JavaScript file). Once we have the function in a library, we can simply include the library in our HTML document and call the function. Any code that can be reduced to simple reusable functions is a candidate for placing in a library. A good rule of thumb is that loading a library should have no side effects other than defining functions. Typically libraries contain related functionality. In this case, let’s create an empty file called drawing.js and place a link to the file in our html <head> element. Your <head> element should now look something like this: <head>   <title>More drawing to canvas</title>   <link rel="stylesheet" href="styles.css">   <script src="drawing.js"></script> </head> Now let’s convert the grid code into a handy function and place it in our drawing.js library, as shown in Listing [2-4](#Par35). function draw_grid(ctx, minor, major, stroke, fill) {   minor = minor || 10;   major = major || minor * 5;   stroke = stroke || "#00FF00";   fill = fill || "#009900";   ctx.save();   ctx.strokeStyle = stroke;   ctx.fillStyle = fill;   let width = ctx.canvas.width, height = ctx.canvas.height   for(var x = 0; x < width; x += minor) {     ctx.beginPath();     ctx.moveTo(x, 0);     ctx.lineTo(x, height);     ctx.lineWidth = (x % major == 0) ? 0.5 : 0.25;     ctx.stroke();     if(x % major == 0 ) {ctx.fillText(x, x, 10);}   }   for(var y = 0; y < height; y += minor) {     ctx.beginPath();     ctx.moveTo(0, y);     ctx.lineTo(width, y);     ctx.lineWidth = (y % major == 0) ? 0.5 : 0.25;     ctx.stroke();     if(y % major == 0 ) {ctx.fillText(y, 0, y + 10);}   }   ctx.restore(); } Listing 2-4draw_grid function We haven’t made many changes here, but the result is a robust library function. Our function, called draw_ grid , takes five arguments. The first argument ctx is a canvas context, which allows us to use the function to draw onto any canvas using a suitable context. In order to find the canvas height and width, we access the canvas object as a property of the ctx argument. We’ve stored the width and height as variables for efficiency. The second and third arguments are the minor and major distances. The fourth and fifth arguments are the stroke and fill colors. We’ve also added a call to context.save() at the beginning of the drawing code and a call to context.restore() at the end. These save and restore canvas state such as context.lineWidth, context.strokeStyle, and context.fillStyle. Using them in this way ensures that the canvas is restored to its original state after the function is done. This is good practice when writing drawing code. It avoids side effects and allows the calling code to keep control of the canvas context. Notice that we’ve tried to make the function as general purpose as possible. It makes no assumptions about what the client code wants other than it wants to draw a grid with the provided context. We can use this function to draw many different grids on many different canvases. Which aspects of a function should be configurable depends on the circumstances. Providing flexibility (multiple arguments) must be balanced with the benefits of a simpler interface (fewer arguments). Default parameters are a good way to compromise. In this case, we’ve provided defaults by setting minor to 10 by default, and major to 5 times the minor value. We’ve also set the colors to default values. These defaults are only used if no values are provided, which is achieved through an or operator (||). The value of minor is set to itself or the default value, which only applies if the value of minor evaluates to false (which undefined values do). It’s worth noting that this syntax has drawbacks. If, for example, the calling code tries to set a default parameter to 0 or some other value that resolves to false, then it will be ignored and the default will be used. Moving this new draw_grid function into our drawing.js library makes our main script much shorter. We can remove all the grid drawing code from our HTML document and replace it with a one-liner: draw_grid(context); We can now easily make custom grids . Try experimenting with the arguments: // try this for comparison draw_grid(context, 15, 45, 'red', 'yellow'); // or this draw_grid(context, 5, 30, 'white', 'red');

## 使用路径

Drawing on canvases requires an understanding of paths. As we saw earlier, a path can be constructed by calling several drawing methods in turn. Once a path has been specified, we can either call context.fill to fill the enclosed areas using the current context.fillStyle or we can call context.stroke to draw the path as a line using the current context.strokeStyle and context.lineWidth. We’ve also seen that paths don’t need to be contiguous; they can be interrupted by calls to context.moveTo. When transferring from one path to another, it’s necessary to call context.beginPath in order to discard the old path data and start a fresh path. Let’s draw some lines on our new grid to confirm that we understand the coordinates system. Add the content of Listing [2-5](#Par47) after your call to draw_grid. context.beginPath(); context.strokeStyle = "#FFFFFF"; context.fillStyle = "#00FF00"; context.lineWidth = 2; context.moveTo(50, 50); context.lineTo(150, 250); context.lineTo(250, 170); context.stroke(); context.fillText("(50, 50)", 30, 40); context.fillText("(150, 250)", 130, 260); context.fillText("(250, 170)", 255, 175); Listing 2-5Some Lines The code draws two white lines. When we draw the first line, we specify that we want to start at (50, 50) and draw a line to (150, 250). We draw the second line without specifying a start position. The line is drawn as a continuation of the path. We then draw the point coordinates so we can see what’s going on clearly. Figure [2-4](#Fig4) shows the result. Note that the coordinates can be read from the grid labels .![A455241_1_En_2_Fig4_HTML.jpg](img/A455241_1_En_2_Fig4_HTML.jpg) Figure 2-4Lines are joined by default Now, we know that the path we’ve just defined, which consists of two straight lines, is still in memory. If we add a call to context.fill we should be able to fill the shape. But what happens when the shape isn’t completely enclosed? Add the line to the end of your script to find out: context.fill(); Figure [2-5](#Fig5) shows what happens.![A455241_1_En_2_Fig5_HTML.jpg](img/A455241_1_En_2_Fig5_HTML.jpg) Figure 2-5Filling a path adds a straight line if necessary The path is filled with the shortest possible route from the beginning of the path to the end. If we add a new context.lineTo to the script, we’ll fill a different shape. We can even fill shapes where the lines cross over. Add the following line in the appropriate place (before we stroke the line): context.lineTo(320, 280); Figure [2-6](#Fig6) shows the result.![A455241_1_En_2_Fig6_HTML.jpg](img/A455241_1_En_2_Fig6_HTML.jpg) Figure 2-6Adding a line to the path Without filling, the path is extended with a new point. Figure [2-7](#Fig7) shows that if we add the context.fill command, the shape is filled with a straight line once again.![A455241_1_En_2_Fig7_HTML.jpg](img/A455241_1_En_2_Fig7_HTML.jpg) Figure 2-7Filling when the lines cross We can also close a path programmatically using context.closePath. This will add a line from the current path position to the most recent open end. Remove the call to context.fill and add a call to context.closePath before the last call to context.stroke. Figure [2-8](#Fig8) shows what happens.![A455241_1_En_2_Fig8_HTML.jpg](img/A455241_1_En_2_Fig8_HTML.jpg) Figure 2-8 Closing the path We saw that paths can be interrupted when we first drew the grid lines. We can effectively “pick up” the “pen” and move it to another position by calling context.moveTo. By combining this with context.closePath, we can quickly and easily draw several closed shapes together. Add the code in Listing [2-6](#Par59) to the end of your script . context.beginPath() context.moveTo(50, 250); context.lineTo(50, 350); context.lineTo(150, 350); context.closePath(); context.moveTo(230, 360); context.lineTo(270, 360); context.lineTo(270, 310); context.closePath(); context.moveTo(250, 50); context.lineTo(370, 50); context.lineTo(370, 100); context.closePath(); context.strokeStyle = "#FFFF00"; context.fillStyle = "#000000"; context.fill(); context.stroke(); Listing 2-6Closed Shapes Study that code and see what happens. Figure [2-9](#Fig9) shows the result. Each time we call context.moveTo, we’re setting the current origin of the path. This is the position that context.closePath will return to. This allows us to call context.fill and context.stroke once for drawing multiple filled, closed shapes. Also note that we set the drawing styles after we’ve defined the path. They can be set at any time before the calls to context.fill and context.stroke.![A455241_1_En_2_Fig9_HTML.jpg](img/A455241_1_En_2_Fig9_HTML.jpg) Figure 2-9Filled, closed, interrupted paths

## 向路径添加曲线

There are many other ways to add to a path besides context.lineTo. A simple way to make your drawings curvy rather than straight is to use the alternative context.quadraticCurveTo method. It’s very similar to context.lineTo but requires the coordinates of a control point as well as of the end point. The line will curve towards the control point. Replace the construction of the last path with the code from Listing [2-7](#Par63). context.beginPath() context.moveTo(50, 250); context.quadraticCurveTo(25, 300, 50, 350); context.quadraticCurveTo(100, 375, 150, 350); context.closePath(); context.moveTo(230, 360); context.quadraticCurveTo(255, 340, 270, 360); context.quadraticCurveTo(255, 340, 270, 310); context.closePath(); context.moveTo(250, 50); context.quadraticCurveTo(310, 60, 370, 50); context.quadraticCurveTo(400, 75, 370, 100); context.closePath(); context.strokeStyle = "#FFFF00"; context.fillStyle = "#000000"; context.fill(); context.stroke(); Listing 2-7Adding Curves The filled shapes are now made with curves, as shown in Figure [2-10](#Fig10).![A455241_1_En_2_Fig10_HTML.jpg](img/A455241_1_En_2_Fig10_HTML.jpg) Figure 2-10 Quadratic curves For more control , we can draw with Bezier curves. Redraw the white path with Bezier curves by replacing the first three calls to context.lineTo after the grid drawing code with context.bezierCurveTo, as in Listing [2-8](#Par66). <script>   var canvas = document.getElementById("asteroids");   var context = canvas.getContext("2d");   draw_grid(context)   context.beginPath();   context.strokeStyle = "#FFFFFF";   context.fillStyle = "#00FF00";   context.lineWidth = 2;   context.moveTo(50, 50);   context.bezierCurveTo(0, 0, 80, 250, 150, 250);   context.bezierCurveTo(250, 250, 250, 250, 250, 170);   context.bezierCurveTo(250, 50, 400, 350, 320, 280);   context.closePath();   // context.fill();   context.stroke();   context.fillText("(50, 50)", 30, 40);   context.fillText("(150, 250)", 130, 260);   context.fillText("(250, 170)", 255, 175);   context.beginPath()   context.moveTo(50, 250);   context.quadraticCurveTo(25, 300, 50, 350);   context.quadraticCurveTo(100, 375, 150, 350);   context.closePath();   context.moveTo(230, 360);   context.quadraticCurveTo(255, 340, 270, 360);   context.quadraticCurveTo(255, 340, 270, 310);   context.closePath();   context.moveTo(250, 50);   context.quadraticCurveTo(310, 160, 370, 50);   context.quadraticCurveTo(400, 75, 370, 100);   context.closePath();   context.strokeStyle = "#FFFF00";   context.fillStyle = "#000000";   context.fill();   context.stroke(); </script> Listing 2-8Bezier Curves Bezier curves take the coordinates of two control points plus the end point. The resultant path is a curve which passes through each of the specified end points. Figure [2-11](#Fig11) shows the final result. Bezier curves allow for smooth twisting and turning with relatively simple paths.![A455241_1_En_2_Fig11_HTML.jpg](img/A455241_1_En_2_Fig11_HTML.jpg) Figure 2-11Bezier curves

## 摘要

In this chapter, we’ve looked more closely at the way the canvas interface operates. We saw how the coordinates system works and explored in detail how paths are created and modified. We looked at various ways to draw lines between points. These are the basic tools at our disposal when we want to draw things on the canvas. I also introduced JavaScript functions and suggested a refactor early, refactor often approach to structuring code. This chapter has continued teaching you some basics and demonstrating how it all works. Chapter [3](03.html) puts what you’ve learned to work to create a more intentional drawing, and looks at functions again.