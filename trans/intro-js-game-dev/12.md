© Graeme Stuart 2017 Graeme StuartIntroducing JavaScript Game Development [https://doi.org/10.1007/978-1-4842-3252-1_12](12.html)

# 12.冲突检出

Graeme Stuart<sup class="calibre7">1 </sup> (1)Market Harborough, Leicestershire, UK   In this chapter we’ll look at detecting collisions between objects. Now that we’re in control of the ship and shooting projectiles, we should think about taking damage and scoring points. These require that we detect collisions between ship and asteroids for damage and between projectiles and asteroids for scoring points. We’ll use a simple circle-to-circle collision detection, so all our objects must approximate to circles. It’s very simple to calculate: first, you need to calculate the distance between the centers of the two circles. If that distance is less than the sum of the circle radii, then the circles are overlapping.

## 快速重构

We’re going to add complexity, so we’ll start by wrapping existing functionality into an AsteroidsGame class. This has many advantages, the main one being to tidy up our global scope. We want to keep the global scope as clear as possible so our game can work well with other code that may be on the page. Keeping our code tidy in this way forces us to be organized and allows us to increase the complexity in a manageable way. Create a new folder and copy our stylesheet and the drawing.js and objects.js libraries across. Add a new file called exercise12.html. Let’s start by writing the code we’d like to be able to work with. Listing [12-1](#Par5) shows how we might want to work. <!doctype html> <html>   <head>     <title>Asteroids</title>     <link rel="stylesheet" href="styles.css">     <script src="drawing.js"></script>     <script src="objects.js"></script>     <script src="game.js"></script>   </head>   <body>     <h1>Asteroids</h1>     <canvas id="asteroids" width="600" height="600" tabindex="1"></canvas>     <script>       'use strict';       var game = new AsteroidsGame("asteroids");     </script>   </body> </html> Listing 12-1Our Game as a One-Liner Thinking about our AsteroidsGame class before we create it is a useful way to ensure that we build a good interface. What information does the game actually need? All it really needs is to know where to draw itself. We want our game to run on a given canvas, so we pass in the canvas element’s id attribute into the game constructor. There may be multiple games and/or multiple canvases on a page. Notice there’s a new script element in the page head called game.js. This is where we’ll code up our new object. Now, of course, this doesn't work. Our job is to take the code from the previous exercise and put it all into an AsteroidsGame class in the new library. We’ve already defined an element of the API. Let’s code to this interface by creating the AsteroidsGame constructor. Place the code from Listing [12-2](#Par8) into the new game.js file. var AsteroidsGame = function(id) {   this.canvas = document.getElementById(id);   this.c = this.canvas.getContext("2d");   this.canvas.focus();   this.guide = false;   this.ship_mass = 10;   this.ship_radius = 15;   this.asteroid_mass = 5000;   // Mass of asteroids   this.asteroid_push = 500000; // max force to apply in one frame   this.ship = new Ship(     this.canvas.width / 2,     this.canvas.height / 2,     1000, 200   );   this.projectiles = [];   this.asteroids = [];   this.asteroids.push(this.moving_asteroid());   this.canvas.addEventListener("keydown", this.keyDown.bind(this), true);   this.canvas.addEventListener("keyup", this.keyUp.bind(this), true);   window.requestAnimationFrame(this.frame.bind(this)); } Listing 12-2The AsteroidsGame Constructor The constructor takes one argument: the id attribute of the canvas element we want to draw our game onto. We use this to create a reference to a canvas. We also extract a reference to the 2D canvas context and store it as this.c for easy access. We then set the focus on the canvas so key presses will register properly (this might be better left to the calling code if many canvases and many games are running). We then set some properties that were previously either global variables or were “magic numbers” that appeared in the code. These will be useful when we create ships and asteroids . Then we create a new ship and set the projectiles and asteroids properties to blank arrays. We add a single moving asteroid into the asteroids array by calling the new AsteroidsGame.prototype.moving_asteroid helper method. Finally, we connect some event handler code and start the game loop. Notice we “bind” these callback functions to the game instance. This still doesn't work. Let’s build out the necessary code piece by piece. In AsteroidsGame.prototype.moving_asteroid, we create an asteroid, push it, twist it, and return it. We do this using two more helper methods: AsteroidsGame.prototype.new_asteroid and AsteroidsGame.prototype.push_asteroid. The implementation is shown in Listing [12-3](#Par13). AsteroidsGame.prototype.moving_asteroid = function(elapsed) {   var asteroid = this.new_asteroid();   this.push_asteroid(asteroid, elapsed);   return asteroid; } AsteroidsGame.prototype.new_asteroid = function() {   return new Asteroid(     this.canvas.width * Math.random(),     this.canvas.height * Math.random(),     this.asteroid_mass   ); } AsteroidsGame.prototype.push_asteroid = function(asteroid, elapsed) {   elapsed = elapsed || 0.015;   asteroid.push(2 * Math.PI * Math.random(), this.asteroid_push, elapsed);   asteroid.twist(     (Math.random() - 0.5) * Math.PI * this.asteroid_push * 0.02,     elapsed   ); } Listing 12-3 Helper Methods for Creating Asteroids The AsteroidsGame.prototype.new_asteroid method simply creates an asteroid in a random position with the asteroid_mass property. The AsteroidsGame.prototype.push_asteroid helper method pushes and twists an asteroid using the asteroid_push property as the force. It pushes over the provided elapsed time. If no elapsed time is provided, it assumes a standard frame at 60 fps (frames per second). It still doesn’t work. The event handler functions shown in Listing [12-4](#Par16) are simple wrappers for the AsteroidsGame.prototype.key_handler function, which replaces the old key_handler function. Inside it, we refer to this.ship rather than just ship. Notice also the addition of a down arrow handler and the use of the G key to toggle the this.guide property. AsteroidsGame.prototype.keyDown = function(e) {   this.key_handler(e, true); } AsteroidsGame.prototype.keyUp = function(e) {   this.key_handler(e, false); } AsteroidsGame.prototype.key_handler = function(e, value) {   var nothing_handled = false;   switch(e.key || e.keyCode) {     case "ArrowLeft":     case 37: // left arrow       this.ship.left_thruster = value;       break;     case "ArrowUp":     case 38: // up arrow       this.ship.thruster_on = value;       break;     case "ArrowRight":     case 39: // right arrow       this.ship.right_thruster = value;       break;     case "ArrowDown":     case 40:       this.ship.retro_on = value;       break;     case " ":     case 32: //spacebar       this.ship.trigger = value;       break;     case "g":     case 71: // g for guide       if(value) this.guide = !this.guide;       break;     default:       nothing_handled = true;   }   if(!nothing_handled) e.preventDefault(); } Listing 12-4The Key Event Handling Methods The final line in the constructor calls window.requestAnimationFrame with the AsteroidsGame.prototype.frame method as the callback. Listing [12-5](#Par18) replaces the old global frame function and does much the same, the main difference being that we call this.update and this.draw and store the previous timestamp as this.previous. AsteroidsGame.prototype.frame = function(timestamp) {   if (!this.previous) this.previous = timestamp;   var elapsed = timestamp - this.previous;   this.update(elapsed / 1000);   this.draw();   this.previous = timestamp;   window.requestAnimationFrame(this.frame.bind(this)); } Listing 12-5The AsteroidsGame.prototype. frame Method Notice that the this.frame function is bound to the game instance when passed into window.requestAnimationFrame. This forces the this keyword to be set to the game instance when the frame function is called. The AsteroidsGame.prototype.update method in Listing [12-6](#Par21) controls all the game elements. It updates all the asteroids, the ship, and all the projectiles. It controls the removal of dead projectiles and the creation of new projectiles when the ship is loaded and the trigger is pulled. It contains nothing new, but we’re now always referencing attributes of our game object. AsteroidsGame.prototype.update = function(elapsed) {   this.ship.compromised = false;   this.asteroids.forEach(function(asteroid) {     asteroid.update(elapsed, this.c);   }, this);   this.ship.update(elapsed, this.c);   this.projectiles.forEach(function(p, i, projectiles) {     p.update(elapsed, this.c);     if(p.life <= 0) {       projectiles.splice(i, 1);     }   }, this);   if(this.ship.trigger && this.ship.loaded) {     this.projectiles.push(this.ship.projectile(elapsed));   } } Listing 12-6The AsteroidsGame.prototype.update Method The AsteroidsGame.prototype. update method makes many calls to the Array.prototype.forEach method. The method takes two arguments: a callback function called for each element in the array and a value to set the value of the this keyword available within the callback function. Notice that we’re passing this as the second argument so that within the callback function we can correctly refer to the game instance as this from within the callback. You can see this happening in all the calls to Array.prototype.forEach. The AsteroidsGame.prototype.draw method shown in Listing [12-7](#Par24) is in charge of drawing the whole game. It draws all the asteroids, the ship, and all the projectiles. It also makes use of Array.prototype.forEach and passes this as the second argument, as in AsteroidsGame.prototype.update. AsteroidsGame.prototype.draw = function() {   this.c.clearRect(0, 0, this.canvas.width, this.canvas.height);   if(this.guide) {     draw_grid(this.c);     this.asteroids.forEach(function(asteroid) {       draw_line(this.c, asteroid, this.ship);     }, this);   }   this.asteroids.forEach(function(asteroid) {     asteroid.draw(this.c, this.guide);   }, this);   this.ship.draw(this.c, this.guide);   this.projectiles.forEach(function(p) {     p.draw(this.c);   }, this); } Listing 12-7The AsteroidsGame.prototype. draw Method The method is fairly similar to the draw function in the last example. It optionally draws the grid and draws lines between asteroids and the ship using the new draw_line function. It only does this if the this.guide property is set. The draw_line function is in drawing.js and is shown in Listing [12-8](#Par27). Add the function to your drawing.js library. function draw_line(ctx, obj1, obj2) {   ctx.save();   ctx.strokeStyle = "white";   ctx.lineWidth = 0.5;   ctx.beginPath();   ctx.moveTo(obj1.x, obj1.y);   ctx.lineTo(obj2.x, obj2.y);   ctx.stroke();   ctx.restore(); } Listing 12-8The draw_line Function Now we have a comprehensive AsteroidsGame class that can be used to run a game on any canvas. We’ve hooked it up to keyboard events and run it frame by frame with its own event loop. There’s no code triggered outside of the AsteroidsGame class. We make use of some very simple helper functions. It’s all pretty straightforward. Refresh the page to see if the game is working as expected. Try toggling the guide property by pressing the G key.

## 飞船大战小行星

Now we need to do some actual collision detection. We’ll detect collisions between the circles that approximate the ship and the asteroids. When the circle around the ship contacts the circle around an asteroid, we’ll set a new compromised property on the ship. When the ship is in the compromised state, it loses health. The first thing to do is to initialize the required properties in the Ship constructor. Update your constructor, as shown in Listing [12-9](#Par31). function Ship(x, y, power, weapon_power) {   this.super(x, y, 10, 20, 1.5 * Math.PI);   this.thruster_power = power;   this.steering_power = this.thruster_power / 20;   this.right_thruster = false;   this.left_thruster = false;   this.thruster_on = false;   this.retro_on = false;   this.weapon_power = weapon_power;   this.loaded = false;   this.weapon_reload_time = 0.25; // seconds   this.time_until_reloaded = this.weapon_reload_time;   this.compromised = false;   this.max_health = 2.0;   this.health = this.max_health; } Listing 12-9Initialize the compromised and health Properties in the Ship Constructor We can also update the Ship.prototype.draw method to indicate (when the guide is turned on) whether the ship is in the compromised state. This is shown in Listing [12-10](#Par33). Ship.prototype.draw = function(c, guide) {   c.save();   c.translate(this.x, this.y);   c.rotate(this.angle);   if(guide && this.compromised) {     c.save();     c.fillStyle = "red";     c.beginPath();     c.arc(0, 0, this.radius, 0, 2 * Math.PI);     c.fill();     c.restore();   }   draw_ship(c, this.radius, {     guide: guide,     thruster: this.thruster_on   });   c.restore(); } Listing 12-10Draw a Red Circle When compromised We could have placed this in the draw_ship function and added an argument. That would probably be neater, but would take longer to describe, so I’ll leave it as an optional exercise. Now we need a general purpose collision function to test for collisions between any two objects. The objects must have (x, y) coordinates and radius properties. Add the functions in Listing [12-11](#Par36) at the top of game.js. function collision(obj1, obj2) {   return distance_between(obj1, obj2) < (obj1.radius + obj2.radius); } function distance_between(obj1, obj2) {   return Math.sqrt(Math.pow(obj1.x - obj2.x, 2) + Math.pow(obj1.y - obj2.y, 2)); } Listing 12-11Collision Detection Collision between circles is simple: the circles intersect if the distance between their centers is smaller than the sum of their radii. We also split out the distance calculation into its own function. To implement collision detection, we need the game to check each asteroid against the ship for collisions and to set the ship.compromised property accordingly. Listing [12-12](#Par39) shows the implementation. AsteroidsGame.prototype.update = function(elapsed) {   this.ship.compromised = false;   this.asteroids.forEach(function(asteroid) {     asteroid.update(elapsed, this.c);     if(collision(asteroid, this.ship)) {       this.ship.compromised = true;     }   }, this);   this.ship.update(elapsed, this.c);   this.projectiles.forEach(function(p, i, projectiles) {     p.update(elapsed, this.c);     if(p.life <= 0) {       projectiles.splice(i, 1);     }   }, this);   if(this.ship.trigger && this.ship.loaded) {     this.projectiles.push(this.ship.projectile(elapsed));   } } Listing 12-12Update compromised Property We set the ship.compromised property to false and then, as we loop over each asteroid, if a collision is detected we set it to true. Notice that we also move things around to ensure we test for collisions before we update the asteroids and the ship. Refresh the page and admire the results. Press G to turn on the guide and you should see that if we hit the asteroid with our ship, a red circle appears under the ship!![A455241_1_En_12_Fig1_HTML.jpg](img/A455241_1_En_12_Fig1_HTML.jpg) Figure 12-1Collision detection

## 受到伤害

Now let’s update things so the ship takes damage when it’s compromised. Effectively, we’re giving the ship a collision time limit (max_health—let’s say 2 seconds). This value will be a property of the ship, so the health property can be topped up at any time. Ship.prototype.update = function(elapsed, c) {   this.push(this.angle,     (this.thruster_on - this.retro_on) * this.thruster_power,      elapsed   );   this.twist(     (this.right_thruster - this.left_thruster) * this.steering_power, elapsed   );   this.loaded = this.time_until_reloaded === 0;   if(!this.loaded) {     this.time_until_reloaded -= Math.min(elapsed, this.time_until_reloaded);   }   if(this.compromised) {     this.health -= Math.min(elapsed, this.health);   }   Mass.prototype.update.apply(this, arguments); } Listing 12-13Drain Health Notice how similar this is to the reload time. Also notice how the retro-thruster is implemented. Now we can’t see the ship’s health, so let’s draw it onto the canvas. Add the following to the end of AsteroidsGame.prototype. draw :   this.c.save();   this.c.font = "18px arial";   this.c.fillStyle = "white";   this.c.fillText("health: " + this.ship.health.toFixed(1), 10, this.canvas.height - 10);   this.c.restore(); Now refresh the page and admire your new health indicator. Try hitting an asteroid and watch your health deplete. But we can do better than this! We’re JavaScript ninjas by now. Add the code from Listing [12-14](#Par48) to the end of objects.js. function Indicator(label, x, y, width, height) {   this.label = label + ": ";   this.x = x;   this.y = y;   this.width = width;   this.height = height; } Indicator.prototype.draw = function(c, max, level) {   c.save();   c.strokeStyle = "white";   c.fillStyle = "white";   c.font = this.height + "pt Arial";   var offset = c.measureText(this.label).width;   c.fillText(this.label, this.x, this.y + this.height - 1);   c.beginPath();   c.rect(offset + this.x, this.y, this.width, this.height);   c.stroke();   c.beginPath();   c.rect(offset + this.x, this.y, this.width * (max / level), this.height);   c.fill();   c.restore() } Listing 12-14 Indicator Class The new Indicator constructor takes a label, a position (x, y), and a size (width, height) as its arguments. Think of it as a rectangle with a label. It has a draw method that takes a context and two values: the max and the level. It works out how wide the label will be and writes the label in (just below) the specified position. It measures how wide the label is so it can draw an empty rectangle of the specified size to the right of the label. It also draws a filled rectangle inside the empty rectangle that’s sized according to the given level as a proportion of max. At the end of the AsteroidGame constructor, add the following property: this.health_indicator = new Indicator("health", 5, 5, 100, 10); To draw the indicator, add the following to the AsteroidGame.prototype.draw method. This should replace our first attempt: this.health_indicator.draw(this.c, this.ship.health, this.ship.max_health); Now we’re seriously impressed. Collide with the asteroid to see your health drop, as shown in Figure [12-2](#Fig2).![A455241_1_En_12_Fig2_HTML.jpg](img/A455241_1_En_12_Fig2_HTML.jpg) Figure 12-2Health indicator

## 小行星对抛射体

The next step is to detect collisions between asteroids and projectiles. If an asteroid is hit, we’ll take away some mass, split the asteroid, and add some score. We’ll treat every unit of mass destroyed as one point for now. We’ll remove 500 units of mass for each hit and award 500 points. We’ll add these new values as properties of AsteroidsGame in the constructor: this.mass_destroyed = 500; this.score = 0; To implement the collision detection and trigger asteroids to split when they’re hit, we need to add some logic to our AsteroidsGame.prototype.update method. Listing [12-15](#Par58) shows the new method: AsteroidsGame.prototype.update = function(elapsed) {   this.ship.compromised = false;   this.asteroids.forEach(function(asteroid) {     asteroid.update(elapsed, this.c);     if(collision(asteroid, this.ship)) {       this.ship.compromised = true;     }   }, this);   this.ship.update(elapsed, this.c);   this.projectiles.forEach(function(p, i, projectiles) {     p.update(elapsed, this.c);     if(p.life <= 0) {       projectiles.splice(i, 1);     } else {       this.asteroids.forEach(function(asteroid, j) {         if(collision(asteroid, p)) {           projectiles.splice(i, 1);           this.asteroids.splice(j, 1);           this.split_asteroid(asteroid, elapsed);         }       }, this);     }   }, this);   if(this.ship.trigger && this.ship.loaded) {     this.projectiles.push(this.ship.projectile(elapsed));   } } Listing 12-15Trigger an Asteroid to Split When Hit The addition of an else clause to the if(p.life <= 0) block ensures that we only test projectiles that are currently live in the game. For every live projectile, we loop over all the asteroids (which have already been updated) and test for collisions. If a collision is detected, we remove the asteroid and the projectile from play. Then we call a new helper method, split_asteroid, passing in the damaged asteroid. The new helper method needs to create new child asteroids and update the score accordingly. It needs to remove the appropriate mass from the parent asteroid, generate two child asteroids with the correct total mass, and give each of them a push so they separate out. Listing [12-16](#Par61) shows a basic implementation. AsteroidsGame.prototype.split_asteroid = function(asteroid, elapsed) {   asteroid.mass -= this.mass_destroyed;   this.score += this.mass_destroyed;   var split = 0.25 + 0.5 * Math.random(); // split unevenly   var ch1 = asteroid.child(asteroid.mass * split);   var ch2 = asteroid.child(asteroid.mass * (1 - split));   [ch1, ch2].forEach(function(child) {     if(child.mass < this.mass_destroyed) {       this.score += child.mass;     } else {       this.push_asteroid(child, elapsed);       this.asteroids.push(child);     }   }, this); } Listing 12-16Split an Asteroid The function does quite a lot. First, it removes some mass from the given asteroid and adds some score to the game. It then determines a (more or less even) split ratio used to distribute mass between the two new asteroids. Two asteroids are created, and the total mass of each is determined by the remaining mass of the original asteroid and the split ratio. We use the Asteroid.child helper method to create asteroids with the same properties (position, speed, and so on) as the parent. For each new child asteroid, we give it a push and add it to the game. We’ve implemented a minimum size for asteroids because tiny asteroids are very difficult to hit and they tend to fly around at high speeds when pushed. If a child asteroid is too small, it’s not added to the game—its mass is simply added to the score. The new child asteroids are created using another helper method: Asteroid.child. This simply initializes new asteroids with the same velocity, rotation, and position as their parent. Listing [12-17](#Par65) shows the function. Asteroid.prototype.child = function(mass) {   return new Asteroid(     this.x, this.y, mass,     this.x_speed, this.y_speed,     this.rotation_speed   ) } Listing 12-17Spawn child Asteroids Now refresh your browser and shoot some asteroids! In order to see the collision detection comparisons at every frame, we now draw lines between projectiles and asteroids. Update the if(this.guide) block in the AsteroidsGame.prototype.draw method. Add a loop over the projectiles nested within the existing loop over asteroids and call the existing draw_line function. Toggle the guides with the G key and shoot to see the new guide lines. You should end up seeing something like Figure [12-3](#Fig3).![A455241_1_En_12_Fig3_HTML.jpg](img/A455241_1_En_12_Fig3_HTML.jpg) Figure 12-3Projectiles break asteroids The final thing we’ll do in this exercise is add a score indicator and a frame rate indicator. The score and frame rate should be presented as numbers, so we’ll add the new NumberIndicator class from Listing [12-18](#Par69) to our objects.js file. function NumberIndicator(label, x, y, options) {   options = options || {}   this.label = label + ": ";   this.x = x;   this.y = y;   this.digits = options.digits || 0;   this.pt = options.pt || 10;   this.align = options.align || 'end'; } NumberIndicator.prototype.draw = function(c, value) {   c.save();   c.fillStyle = "white";   c.font = this.pt + "pt Arial";   c.textAlign = this.align;   c.fillText(     this.label + value.toFixed(this. digits),     this.x, this.y + this.pt - 1   );   c.restore(); } Listing 12-18 NumberIndicator The class allows us to specify a label and position for our indicator. It also takes an optional options argument that overrides default values. The options.digits attribute sets the number of decimal places to present (default is 0), the options.pt attribute sets the font size (default is 10 points), and the options.align attribute determines the text alignment. It has a draw method that takes two arguments, a canvas context on which to draw, and the value to show. It simply prints the label and the value separated by a colon. Like the Indicator class, the NumberIndicator class avoids the need for low-level drawing code in our main AsteroidsGame class. This avoids clutter and helps us to organize our code and keep track of what everything does. We’re also going to use it twice, which avoids repeating similar code (which is bad). We need to add a couple of lines in our AsteroidsGame constructor, as shown in Listing [12-19](#Par72). this.score_indicator = new NumberIndicator("score",   this.canvas.width - 10, 5 ); this.fps_indicator = new NumberIndicator("fps",   this.canvas.width - 10,   this.canvas.height - 15,   {digits: 2} ); Listing 12-19Some Indicators Then we update our AsteroidsGame.prototype.draw method, as shown in Listing [12-20](#Par74). We only show the frame rate when the guide is on. AsteroidsGame.prototype.draw = function() {   this.c.clearRect(0, 0, this.canvas.width, this.canvas.height);   if(this.guide) {     draw_grid(this.c);     this.asteroids.forEach(function(asteroid) {       draw_line(this.c, asteroid, this.ship);       this.projectiles.forEach(function(p) {         draw_line(this.c, asteroid, p);       }, this);     }, this);     this.fps_indicator.draw(this.c, this.fps);   }   this.asteroids.forEach(function(asteroid) {     asteroid.draw(this.c, this.guide);   }, this);   this.ship.draw(this.c, this.guide);   this.projectiles.forEach(function(p) {     p.draw(this.c);   }, this);   this.health_indicator.draw(this.c, this.ship.health, this.ship.max_health);   this.score_indicator.draw(this.c, this.score); } Listing 12-20Some More Indicators The last thing we need is to calculate the frame rate. Add a line to the AsteroidsGame.prototype.frame method, as shown in Listing [12-21](#Par76). AsteroidsGame.prototype.frame = function(timestamp) {   if (!this.previous) this.previous = timestamp;   var elapsed = timestamp - this.previous;   this.fps = 1000 / elapsed;   this.update(elapsed / 1000);   this.draw();   this.previous = timestamp;   window.requestAnimationFrame(this.frame.bind(this)); } Listing 12-21Calculating the Frame Rate That’s it! Refresh the page and enjoy your new score indicator. Figure [12-4](#Fig4) shows what you should see. Notice that destroying all the asteroids leaves you with a score equal to the mass of one asteroid. All the mass has been converted to score. You can also toggle the guide and admire the new fps indicator.![A455241_1_En_12_Fig4_HTML.jpg](img/A455241_1_En_12_Fig4_HTML.jpg) Figure 12-4Score and frame rate indicated

## 摘要

We’ve added functionality to our game. We can now fly around destroying asteroids. And we’ve added significant complexity to our code—in the update and draw functions, we’re now managing the game itself. We detect collisions and encode the consequences of collisions. The main lesson here is that new code should always have a place of its own in the structure. We refactored our code at the beginning of the chapter to create a home for our newly composed complexity. We didn’t have to do that, but it brings many small benefits and simplifications. The functions themselves provide structure within the game object. When we read through our functions, it’s possible to understand what’s going on. Having complex code declared directly in the global scope is always a sign that a refactoring to add structure should be considered.