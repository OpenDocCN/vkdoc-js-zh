© Graeme Stuart 2017 Graeme StuartIntroducing JavaScript Game Development [https://doi.org/10.1007/978-1-4842-3252-1_9](09.html)

# 9.遗产

Graeme Stuart<sup class="calibre7">1 </sup> (1)Market Harborough, Leicestershire, UK   In this chapter we’ll begin to build our final version of the Asteroids game. We’ll need objects to describe asteroids and our ship and we will eventually need objects for our projectiles too, which the ship will use to destroy asteroids. In this case, the objects will all share some common features, and this makes them good candidates for inheritance. Inheritance is an important concept in object-oriented software engineering because it allows for potentially complex logic to be expressed once and used across multiple object types. We’ll learn this in the usual way—by doing.

## 设置模板

To start, create a new folder called exercise9, copy the library files and stylesheet into the new folder, and save the template in Listing [9-1](#Par3) as exercise9.html. As usual, we’ll reuse our drawing.js and objects.js libraries, where we place our drawing code and object definitions respectively. <!doctype html> <html>   <head>     <title>Inheritance</title>     <link rel="stylesheet" href="styles.css">     <script src="drawing.js"></script>     <script src="objects.js"></script>   </head>   <body>     <h1>Inheritance</h1>     <canvas id="asteroids" width="600" height="600"></canvas>     <script>       'use strict';       var context = document.getElementById("asteroids").getContext("2d");       function draw(ctx) {         draw_grid(context);       }       function update(elapsed) {       }       var previous;       function frame(timestamp) {         if (!previous) previous = timestamp;         var elapsed = timestamp - previous;         context.clearRect(0, 0, context.canvas.width, context.canvas.height);         update(elapsed/1000);         draw(context);         previous = timestamp;         window.requestAnimationFrame(frame);       }       window.requestAnimationFrame(frame);     </script>   </body> </html> Listing 9-1exercise9.html The result should be a blank grid . We’ve increased the size of the grid to accommodate our game. Note that the animation is drawing a frame 60 times per second, it’s just that the frame is the same each time.

## 牛顿运动定律

Any attempt to produce a model of objects floating in space should comply with all three basic laws of classical mechanics:

1.  1.如果没有力的作用，空间中的质量将保持同样的速度。
2.  2.施加在物体上的力等于物体的质量乘以合成加速度。
3.  3.当一个质量推另一个质量时，它会以大小相等方向相反的力被推回去。

When we created our Asteroid object, we coded its behavior in line with Newton’s first law. The Asteroid instances store their velocity and simply keep moving at that velocity. With no forces acting upon them, this is what asteroids do. In our game, we’re piloting a ship floating in space. The ship will also need to be coded to obey Newton’s first law. In fact, everything in the game (unless we’ve implemented some kind of laser, which you’re welcome to try) should comply with all three basic laws of classical mechanics.

## 一个通用的大众类

In this exercise we’ll encode the laws of classical mechanics into a general-purpose Mass class and extend this Mass class to produce our Asteroid and Ship classes. The basic Mass class stores a position (x and y coordinates) and a velocity (x_speed and y_speed). It also has an angle and a rotation_speed. Add the constructor shown in Listing [9-2](#Par11) to your objects.js file. function Mass(x, y, mass, radius, angle, x_speed, y_speed, rotation_speed) {   this.x = x;   this.y = y;   this.mass = mass || 1;   this.radius = radius || 50;   this.angle = angle || 0;   this.x_speed = x_speed || 0;   this.y_speed = y_speed || 0;   this.rotation_speed = rotation_speed || 0; } Listing 9-2The Mass Constructor The list of arguments is long because we don’t want any complex default behavior. All the parameters are required for a mass to properly operate. Default values are provided for most parameters, but in typical usage they’re not likely to be relied upon. They have sensible default values of 0 in most cases, so the mass is stationary by default. A mass value of 1 and a radius of 50 is also provided by default. The (x, y) coordinates are required arguments because otherwise the Mass object will be located at the canvas origin, which is confusing. The update method in Listing [9-3](#Par14) is responsible for enforcing Newton’s first law. We also use it to wrap the Mass around the canvas if it moves off the canvas edge. Copy it under your constructor. Mass.prototype.update = function(elapsed, ctx) {   this.x += this.x_speed * elapsed;   this.y += this.y_speed * elapsed;   this.angle += this.rotation_speed * elapsed;   this.angle %= (2 * Math.PI);   if(this.x - this.radius > ctx.canvas.width) {     this.x = -this.radius;   }   if(this.x + this.radius < 0) {     this.x = ctx.canvas.width + this.radius;   }   if(this.y - this.radius > ctx.canvas.height) {     this.y = -this.radius;   }   if(this.y + this.radius < 0) {     this.y = ctx.canvas.height + this.radius;   } } Listing 9-3The Mass.prototype.update Method This should be a familiar pattern because it’s much like the update function of the original asteroid. One difference is that this time we take the context as an argument because this code now sits in the objects.js library and has (or should have) no knowledge of the canvas or context in our main scope. We implement Newton’s second law with the simple Mass.prototype. push method shown in Listing [9-4](#Par17). Calling this method with an angle, a force, and an elapsed time will apply the force to the mass, causing acceleration that is inversely proportional to the mass. Add it to your library. Mass.prototype.push = function(angle, force, elapsed) {   this.x_speed += elapsed * (Math.cos(angle) * force) / this.mass;   this.y_speed += elapsed * (Math.sin(angle) * force) / this.mass; } Listing 9-4The Mass.prototype.push Method The very similar Mass.prototype.twist method shown in Listing [9-5](#Par19) does the same thing for angles. Positive forces rotate the mass clockwise, and negative forces rotate the mass counterclockwise. Again, add it to your growing code base. Mass.prototype.twist = function(force, elapsed) {   this.rotation_speed += elapsed * force / this.mass; } Listing 9-5The Mass.prototype. twist Method We’ll also add the pair of methods shown in Listing [9-6](#Par21). These calculate the speed and angle of movement of a Mass and will be useful later. Mass.prototype.speed = function() {   return Math.sqrt(Math.pow(this.x_speed, 2) + Math.pow(this.y_speed, 2)); } Mass.prototype.movement_angle = function() {   return Math.atan2(this.y_speed, this.x_speed); } Listing 9-6Other Useful Methods To test out our parent Mass class, we need a draw method. This will be overridden in any child classes. Add the method in Listing [9-7](#Par23). Mass.prototype.draw = function(c) {   c.save();   c.translate(this.x, this.y);   c.rotate(this.angle);   c.beginPath();   c.arc(0, 0, this.radius, 0, 2 * Math.PI);   c.lineTo(0, 0);   c.strokeStyle = "#FFFFFF";   c.stroke();   c.restore(); } Listing 9-7A Placeholder Mass.prototype. draw Method We simply draw a circle and a line to the center to indicate the position, radius, and angle of the Mass. To test this out, instantiate a Mass object and define the global update and draw functions to drive your mass. Follow the code in Listing [9-8](#Par25). var mass = new Mass(context.canvas.width/2, context.canvas.height/2, 10, 20); function draw() {   context.clearRect(0, 0, context.canvas.width, context.canvas.height);   draw_grid(context);   mass.draw(context); } function update(elapsed) {   mass.update(elapsed, context); } Listing 9-8A Simple Test Refreshing your browser displays our Mass object sitting static in the middle of the canvas, as shown in Figure [9-1](#Fig1). It has 0 (zero) x_speed, y_speed, and rotation_speed, so it’s not moving. When we call our object functions from the global update and draw methods, we’re linking the objects into the game loop. We will sometimes refer to this job of linking objects into the game as plumbing code or hooking up the objects.![A455241_1_En_9_Fig1_HTML.jpg](Images/A455241_1_En_9_Fig1_HTML.jpg) Figure 9-1An abstract mass rendered as a circle with a line Open your browser’s developer tools (press F12 in Google Chrome) and navigate to the JavaScript console, which enables you to interact with the web page. In this case, because we’re defining our variables in the global scope, we can access them and call methods directly. Type mass into the console, and you should see the mass variable printed out. Try typing mass.twist(Math.PI, 10). This applies a twisting force, and we see the mass rotate. Calling the method again accelerates the rotation. The same applies to calling mass.push(0.75 * Math.PI, 10, 10). The mass is accelerated by the push. Experiment with this on the command line for a bit. Contemplate the fact that you can define any method you like and have ultimate power over your own canvas game.

## 继承的简单方法

In order for our Asteroid class to inherit the behavior of a Mass, we’ll need to manipulate the object prototypes. Place the function shown in Listing [9-9](#Par30) at the top of objects.js, above your Mass constructor. function extend(ChildClass, ParentClass) {   var parent = new ParentClass();   ChildClass.prototype = parent;   ChildClass.prototype.super = parent.constructor;   ChildClass.prototype.constructor = ChildClass; } Listing 9-9The extend Method This function emulates classes and implements a simple inheritance mechanism. To extend a child class with the properties and methods of a parent class, simply call this function with the two class objects. The first line of the function creates an instance of the parent class. The child class prototype is replaced with this instance. The third line sorts out a way to call the parent constructor from within the child constructor. Finally, the constructor of the child class prototype (which is the parent class instance) is set back to the child class. This prototype manipulation allows for a child class constructor to pass parameters to the parent constructor via the super method. It doesn’t handle any extra methods added to the prototype. If these need to call the parent implementation, they need to do it manually, as we’ll see later.

## 小行星

Listing [9-10](#Par33) shows how we create the Asteroid class as an extension of the Mass class. Replace the existing Asteroid definition in your object.js library with Listing [9-10](#Par33). function Asteroid(mass, x, y, x_speed, y_speed, rotation_speed) {   var density = 1; // kg per square pixel   var radius = Math.sqrt((mass / density) / Math.PI);   this.super(mass, radius, x, y, 0, x_speed, y_speed, rotation_speed);   this.circumference = 2 * Math.PI * this.radius;   this.segments = Math.ceil(this.circumference / 15);   this.segments = Math.min(25, Math.max(5, this.segments));   this.noise = 0.2;   this.shape = [];   for(var i = 0; i < this.segments; i++) {     this.shape.push(2 * (Math.random() - 0.5));   } } extend(Asteroid, Mass); Asteroid.prototype.draw = function(ctx, guide) {   ctx.save();   ctx.translate(this.x, this.y);   ctx.rotate(this.angle);   draw_asteroid(ctx, this.radius, this.shape, {     noise: this.noise,     guide: guide   });   ctx.restore(); } Listing 9-10The Asteroid Class The Asteroid constructor is much the same as our previous example, with a few minor enhancements. It takes six arguments, the most important being the mass and the (x, y) coordinates. We also allow for the velocity and rotation speed to be set, which we’ll use later when we split asteroids. Internally, the asteroid calculates a radius value from the given mass based on a fixed density value. If you want larger or smaller asteroids, tweaking the density value is the way to do it. We then call this.super, which we can see from the extend function is a reference to the parent class constructor, Mass. By calling this, we set the mass, radius, x, y, angle, x_speed, y_speed, and rotation_speed properties of our object. The final steps are to set the asteroid shape. To do this, we first calculate the circumference and use this to set the number of segments so that larger asteroids have more detail. We make sure the number of segments is at least 5 and no more than 25\. We set the noise to 0.2 and set the random shape as before. After we define the constructor, we call the extend function and pass in the child class, Asteroid, and the parent class, Mass. This is what sets Asteroid.super to the Mass constructor—and, critically, it sets the Asteroid.prototype to an instance of Mass. The Asteroid.prototype.draw method holds no surprises. It’s unchanged from our previous asteroid example. Notice we don’t need to define an Asteroid.prototype.update method because the one we inherit from Mass does everything we need. Create an instance of Asteroid in the center of the canvas with randomized mass, as shown in Listing [9-11](#Par39). var asteroid = new Asteroid(   10000,   Math.random() * context.canvas.width,   Math.random() * context.canvas.height ); Listing 9-11Instantiate an Asteroid Hook up the update and draw functions and refresh your browser. Now experiment again in the browser console with our asteroid.push and asteroid.twist API. Notice that larger, heavy asteroids need more force to give the same acceleration. Figure [9-2](#Fig2) shows an asteroid.![A455241_1_En_9_Fig2_HTML.jpg](Images/A455241_1_En_9_Fig2_HTML.jpg) Figure 9-2A similar asteroid but this time inheriting from mass Try creating a list of asteroids (remember to hook up the update and draw functions to the asteroid objects). Use the browser console to push and twist each of the asteroids in turn.

## 这艘船

Now we can do the same thing with the ship. The ship is a mass floating in space just like an asteroid. Add the code in Listing [9-12](#Par43) to your library. function Ship(x, y) {   this.super(x, y, 10, 20, 1.5 * Math.PI); } extend(Ship, Mass); Ship.prototype.draw = function(c, guide) {   c.save();   c.translate(this.x, this.y);   c.rotate(this.angle);   c.strokeStyle = "white";   c.lineWidth = 2;   c.fillStyle = "black";   draw_ship(c, this.radius, {     guide: guide   });   c.restore(); } Listing 9-12The Ship Class In your exercise9.html file, add some code to set up your asteroids and ship properly. Try to automatically push and twist the asteroids to send them floating off into space. Instantiate a ship right in the middle of the canvas. Listing [9-13](#Par45) shows one approach. var asteroids = []; for (let i=0; i<4; i++) {   let asteroid = new Asteroid(     Math.random() * context.canvas.width,     Math.random() * context.canvas.height,     2000 + Math.random() * 8000   );   asteroid.push(Math.random() * 2 * Math.PI, 2000, 60);   asteroid.twist((Math.random()-0.5) * 500, 60);   asteroids.push(asteroid); } var ship = new Ship(context.canvas.width / 2, context.canvas.height / 2); Listing 9-13Set Up a Simple Scene We now have a set of asteroids, each of which has been given a push and a twist to get them started. We also have a ship in the middle of the canvas. Plumb all the game elements to the update and draw functions to activate them. Try pushing and twisting the ship in the browser console. Figure [9-3](#Fig3) shows the kind of scene you should be able to produce.![A455241_1_En_9_Fig3_HTML.jpg](Images/A455241_1_En_9_Fig3_HTML.jpg) Figure 9-3The ship and the asteroid both inherit from mass Now let’s play with the ship. Change your global update function as shown in Listing [9-14](#Par48) and refresh your browser. function update(elapsed) {   // if its nearly stopped, turn   if(Math.abs(ship.speed()) < 15) {     ship.angle += Math.PI * 2 * 0.01;   }   // If Its going fast, turn around to slow down   if(Math.abs(ship.speed()) > 100) {     ship.angle = ship.movement_angle() + Math.PI;   }   // push in the direction its pointing (thrusters?)   ship.push(ship.angle, 1000, elapsed)   asteroids.forEach(function(asteroid) {     asteroid.update(elapsed, context);   })   ship.update(elapsed, context); } Listing 9-14Playing with the Ship Here we’re implementing a simple set of instructions to control the ship. We accelerate the ship forward all the time (as if the ship’s thrusters were on). If the ship speed gets above 100 pixels per second, we turn around to face the opposite direction. When we’re travelling slowly, we increase the ship’s angle. This is beginning to look like a game.

## 摘要

In this chapter, you’ve learned how to define common functionality and share it between multiple game elements. We implemented methods on the parent Mass class that can be inherited by any massive objects we need to float around according to the basic laws of motion. We also played with developing a scene. The structured way we’ve developed our objects makes it easy. It allows us to write very simple code to initialize game elements, decide on their initial behavior, and “hook them up” to our game loop to place them on the canvas. This is a powerful approach. Pushing the implementation details of our objects into their definitions means we can easily switch contexts when writing code and can focus on developing more complexity without getting bogged down in detail. Playing with the ship in Listing [9-14](#Par48) shows how we can experiment with controlling our game elements in the global update loop. But for behavior that’s more intrinsic to our object, we should place code in the object definition. Before we look closer at the ship behavior, we need to look into how we can take user inputs via the keyboard to control our game.