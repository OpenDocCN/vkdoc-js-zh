© Graeme Stuart 2017 Graeme StuartIntroducing JavaScript Game Development [https://doi.org/10.1007/978-1-4842-3252-1_1](01.html)

# 1.HTML5 和画布元素

Graeme Stuart<sup class="calibre7">1 </sup> (1)Market Harborough, Leicestershire, UK   This chapter introduces some of the basics of HTML, CSS, and JavaScript. These are the core web technologies, and we’ll use them for developing our game throughout this book. In order to follow along, you’ll need a text editor to generate text files and a web browser to view the results with. You won’t be learning everything there is to know about these technologies. We’ll focus on just enough to draw some stuff on an HTML canvas element. We’ll work with the HTML canvas element throughout this book, so pay attention.

## html first(html 第一个)

HTML (HyperText Markup Language) documents describe content on the web. When you access a web page, you’re typically downloading and viewing an HTML document. HTML is a way to organize and add semantic meaning to multimedia content (text, images, videos, and more) and to link between documents in a “web” of information. HTML5 is the current version of the HTML standard. The standard was originally developed in the early 1990s and has evolved a little since then. The modern standard allows for the extremely rich experience of the modern World Wide Web. We’ll be working with the HTML canvas element, so let’s create our first HTML document and add a canvas element to it. Create a file called exercise1.html and type in the basic HTML template shown in Listing [1-1](#Par6). <!doctype html> <html>   <head>     <title>This is an HTML canvas</title>   </head>   <body>     <h1>This is an HTML canvas</h1>     <canvas id="asteroids" width="400" height="400"></canvas>   </body> </html> Listing 1-1A Basic HTML Template Listing [1-1](#Par6) begins with a <!doctype html> declaration. The doctype declaration is always the first thing in an HTML document. It’s an instruction to the web browser about what version of HTML the page is written in. In the past, using doctype was complex because there were many versions of HTML to choose from. With HTML5, the declaration is reduced to simply specifying that we’re using HTML. After the doctype, the main <html> element is opened. Note that it’s closed at the end of the file with an </html> closing tag. Everything in between the opening and closing html tags is said to be within the html element. There should be nothing more in an HTML file than a doctype and an html element with content. Within the html element there are two nested elements: <head> and <body>. The <head> element is used to describe details about the document, such as the <title> to be displayed in a browser tab. It often also contains links to stylesheets or JavaScript files that specifies how the contents are to be rendered and how they behave. The <body> element contains the content of the document and in this case includes a level one header <h1> and a <canvas> element. The <canvas> element provides a JavaScript API (application programmable interface) for drawing simple shapes and lines. It’s this API that we will use to render our game.

## 画到画布上

<script> elements contain JavaScript code that’s executed by the browser. Add the <script> shown in Listing [1-2](#Par12) into your document <body> after the <canvas> element . <script>   var canvas = document.getElementById("asteroids");   var context = canvas.getContext("2d");   context.strokeStyle = 'dimgrey';   context.lineWidth = 5;   context.rect(75, 75, 250, 250);   context.stroke();   // this is a comment, it has no effect!!! </script> Listing 1-2A Simple Script You’ll need to reload the page in order for the script to run. The script runs line by line once the page is loaded. The first line calls the getElementById method on the global document object. The document object is defined automatically and provides a programmable interface into the entire HTML document. The document is loaded into memory as a tree-like structure often referred to as the DOM (Document Object Model). In this case we’re using getElementById to get a reference to the <canvas> element within the DOM using the id value we specified in the HTML. The second line in the script generates a reference to a canvas context. Canvas contexts provide an API for drawing. In this case, we’re accessing the "2d" canvas context. It has a variety of methods for drawing lines and shapes on the canvas and for transforming the canvas. Other canvas contexts are available but are outside of the scope of this book. The third and fourth lines of the script set some properties of the context. Setting context.strokeStyle affects the color of the line, here we set it to the built in 'dimgrey' color. Setting context.lineWidth affects the thickness of the line, and here we set it to five pixels wide. When we set properties of the canvas context, they remain in force until we change them. All future lines we draw will be five pixels wide and 'dimgrey' until we tell the canvas context otherwise. The fifth line specifies a rectangle using the context.rect method. The (x, y) pixel coordinates of the origin of the rectangle is specified in the first two arguments (75 and 75). The pixel width and height of the rectangle are specified in the last two arguments (250 and 250). Most canvas operations involving lengths are specified in pixels (and angles are in radians). Note that this line specifies the rectangle but doesn’t draw it. The rectangle specification is stored in memory as a structure known as a path. We’ll talk more about paths later. The final active line tells the context to draw the stored path using the current values of the context properties (lineWidth and strokeStyle). Open the file in your browser and you’ll see the rectangle has been drawn on the canvas, as shown in Figure [1-1](#Fig1).![A455241_1_En_1_Fig1_HTML.jpg](Images/A455241_1_En_1_Fig1_HTML.jpg) Figure 1-1A rectangle (actually, a square) The final line of the script is actually a comment. Comments begin with double forward slashes (//) and are ignored by the browser when running the code. Comments are useful for annotating your code but also for quickly removing lines of code while keeping the ability to uncomment them again later by removing the slashes.

## 设置页面样式以突出显示画布

Great so far, but we can’t see the edges of the canvas on the page because the page and canvas are both white. Insert the <style> element from Listing [1-3](#Par20) into the <header> element after the <title> element and reload the page. <style media="screen">   body {     text-align: center;     font-family: sans-serif;   }   canvas {     background-color: black;   } </style> Listing 1-3Styling the Canvas Styles allow us to control how the content of the document looks when it’s rendered by the browser. In this case, we’re specifying that we want the <body> element to be centrally aligned with a sans-serif font (this applies to all child elements of the body element, as font-family is inherited by default). We’re also specifying that <canvas> elements should be drawn with a black background color. After reloading the page, you should see something similar to Figure [1-2](#Fig2).![A455241_1_En_1_Fig2_HTML.jpg](Images/A455241_1_En_1_Fig2_HTML.jpg) Figure 1-2A 250 × 250 “rectangle” in a 400 × 400 canvas. The top-left corner is at point (75, 75). This allows us to see exactly where the canvas edges are and understand that the rectangle is positioned as specified within the canvas. I won’t cover styles much more in this book, but they’re a very powerful technology providing exquisite control over how to render HTML content.

## 试用 fillStyle

Setting the context.fillStyle determines the color to use when filling drawn shapes (including fonts). Try setting the fill style to a light grey (for example, context.fillStyle = 'lightgrey'). Reloading the page does nothing. That’s because we haven’t asked the context to fill the path. To fill the path it’s necessary to call the context.fill method. Go ahead and add the call at the end of the script, just like the call to context.stroke. Also, swap the values of fillStyle and strokeStyle to create a dark square with a light border for more contrast. Your page should look like Figure [1-3](#Fig3).![A455241_1_En_1_Fig3_HTML.jpg](Images/A455241_1_En_1_Fig3_HTML.jpg) Figure 1-3A dark square with a light border Now let’s change the shape of the rectangle so we can create a motivational poster. Replace the rectangle coordinates with those shown in Listing [1-4](#Par26). Notice that we can access the canvas.width and canvas.height attributes and use them to calculate the size of our rectangle. <script>   var canvas = document.getElementById("asteroids");   var context = canvas.getContext("2d");   context.strokeStyle = 'lightgrey';   context.fillStyle = 'dimgrey';   context.lineWidth = 5;   context.rect(75, 50, canvas.width - 150, canvas.height - 100);   context.stroke();   context.fill(); </script> Listing 1-4Changing the Rectangle Color, Shape, and Position

## 呈现文本

The canvas treats text a lot like a collection of shapes. The outline can be drawn with the context.strokeText method, or text can be filled with the context.fillText method. Both methods must be passed a text string and the (x, y) coordinates (in pixels) at which to render the text. Before rendering text it’s useful to change the font from the default using context.font. Add the two lines in Listing [1-5](#Par29) to your script. context.font = "34px Arial"; context.fillText("2D Drawing", 110, 100); Listing 1-5Write Some Text It seems like nothing has happened, but actually, the text has been drawn. The problem is that the fillStyle is still set to the same color as the filled rectangle. The text color and the background color are the same, so nothing visibly changes. Edit your script to add a second call to context.fillStyle. Set it to a contrasting (light) color (for example, 'lightgrey'). Make sure your new line is positioned after the previous call to context.fill and before your call to context.fillText. Refresh the page and admire the fruits of your hard work—you should have something similar to Figure [1-4](#Fig4).![A455241_1_En_1_Fig4_HTML.jpg](Images/A455241_1_En_1_Fig4_HTML.jpg) Figure 1-4Use fillText to render text Try using context.strokeText instead—it has exactly the same API (it takes the same arguments in the same order) as context.fillText. Notice that the text is rendered as an outline but that the line width is still set to 5 pixels. Add another call to context.lineWidth and choose a suitable thickness. Note that you can use non-integer values such as 0.5\. Update your code to match Listing [1-6](#Par33). <script>   var canvas = document.getElementById("asteroids");   var context = canvas.getContext("2d");   context.strokeStyle = 'lightgrey';   context.fillStyle = 'dimgrey';   context.lineWidth = 5;   context.rect(75, 50, canvas.width - 150, canvas.height - 100);   context.stroke();   context.fill();   context.font = "34px Arial";   context.strokeStyle = '#FF2222';   context.fillStyle = '#FFAAAA';   context.lineWidth = 0.75;   context.textAlign="center";   let msg = "2D Drawing"   context.fillText(msg, canvas.width / 2, 100);   context.strokeText(msg, canvas.width / 2, 100); </script> Listing 1-6Some Fancy Text The changes are all in the second half of the script. We set the familiar context properties to some sensible values (note the use of hexadecimal color codes). We then set a new property context.textAlign to the value "center". This tells the context to use the central point in the text as the “anchor.” So, when we actually render the text, the central point in the text is positioned at the x-coordinate we provide rather than the default leftmost point. The final few lines set a message variable and draw the text. First we fill it and then we draw an outline (experiment with swapping the order of these method calls). This is just the same as before except this time we’re calculating the x-coordinate rather than specifying a literal value (such as 110, as before). In this case, we’re aligning the text centrally on the horizontal axis so we divide the width by 2\. See Figure [1-5](#Fig5).![A455241_1_En_1_Fig5_HTML.jpg](Images/A455241_1_En_1_Fig5_HTML.jpg) Figure 1-5Fancy, centred text

## 更多形状和线条

Drawing to the canvas is pretty simple. The tricky part is deciding what to draw and designing it. Listing [1-7](#Par36) includes some code for a simple stick figure waving. Paste it in at the end of your script. context.strokeStyle = '#FFFFFF'; context.lineWidth = 2; context.beginPath(); context.arc(200, 140, 20, 0, Math.PI * 2); context.moveTo(200, 160); context.lineTo(200, 220); context.moveTo(180, 300); context.lineTo(185, 260); context.lineTo(200, 220); context.lineTo(215, 260); context.lineTo(220, 300); context.moveTo(240, 130); context.lineTo(225, 170); context.lineTo(200, 170); context.lineTo(175, 180); context.lineTo(170, 220); context.stroke(); Listing 1-7A Stick Figure The script starts by setting the stroke color to white and the line width to 2 pixels. Then we see two new methods of the context object. The context.beginPath method begins a new path or resets the current path. We need to call this because we already had an active path left over from when we drew the original rectangle. If we don’t call it (try commenting it out), then we continue the original path, and a line will be drawn from the rectangle to our first circle. You’ll learn more about paths in Chapter [2](02.html). The circle is drawn using the context.arc method. This method can be used to draw any circle or portion of a circle. The method takes five arguments, as follows: the first pair of arguments includes the (x, y) coordinates (in pixels) of the center of the circle. The third argument is the radius of the circle, and the fourth and fifth arguments are the starting angle and finishing angle of the arc (measured in radians). To draw a full circle, these angles should be 0 and 2π. We access the value of π via the Math.PI method. We’ll use the built-in JavaScript Math object extensively in later chapters. The remaining method calls are all either context.moveTo or context.lineTo until we finally call context.stroke to draw the path. The context.moveTo and context.lineTo methods both take two arguments, and in both cases these are the (x, y) coordinates specifying a location on the canvas in pixels. They each do exactly what you would expect. To move the “pen” to a location without drawing a line, call context.moveTo. To draw a line from the current location to the given location, call context.lineTo. Follow the code line by line and see how each line of code is necessary to draw the stick figure shown in Figure [1-6](#Fig6). Try removing or editing some of the lines to see what happens. Play around until you can predict the effect of a change.![A455241_1_En_1_Fig6_HTML.jpg](Images/A455241_1_En_1_Fig6_HTML.jpg) Figure 1-6Circles and lines Finally, complete the motivational poster by adding the code in Listing [1-8](#Par42) to your script before the recent changes to context.lineWidth and context.strokeStyle. let msg2 = "its quite easy"; context.font = "24px Arial"; context.fillText(msg2, canvas.width / 2, 330); context.strokeText(msg2, canvas.width / 2, 330); Listing 1-8A Motivational Message The final image should appear like Figure [1-7](#Fig7). Note how the position in the code where you insert the new lines makes a difference. If you place the new code after the context changes, the text outline will be drawn with a thicker, white line.![A455241_1_En_1_Fig7_HTML.jpg](Images/A455241_1_En_1_Fig7_HTML.jpg) Figure 1-7The finished poster

## 摘要

In this chapter we’ve had a very quick run-through of the basic technologies we’ll be using to create our game. We’ve created our first HTML document and viewed it in the browser, we’ve styled our document, and we’ve written code to manipulate our canvas element. We’ve seen that the HTML <canvas> element has a programmable interface, and we’ve used HTML <script> elements with JavaScript code to draw to the canvas. We’ve been introduced to some of the methods available in the canvas context and used them to render a motivational poster to the canvas. And we’ve seen that the interface gives us tools for drawing lines and filling shapes and that we can control the thickness of lines and the color of lines and shapes. We learned a little about the coordinate system and how paths are constructed. In Chapter [2](02.html), we’ll expand on this and try to get a deeper understanding of how to master the art of drawing what we want on the HTML canvas.