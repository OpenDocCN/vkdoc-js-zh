# 三、DOM

在这一章中，我们将介绍文档对象模型 ，或 DOM。我们将从说明什么是 DOM 以及它是如何随着时间的推移而发展的开始。然后我们将探索它的内部结构和公开的属性和方法，接着详细讨论使用 JavaScript 处理 DOM。

在本章结束时，你应该对 DOM 及其内部工作原理有一个坚实的理解。您还应该对管理它的标准、在哪里可以找到它们以及它们是如何发展的有所了解。您不仅应该了解如何在脚本中处理用户事件，包括如何手动触发它们，还应该了解如何创建自己的自定义事件。

我是如何学会停止担忧并热爱大教堂的

文档对象模型就是这样:一个对当前加载到浏览器中的文档进行建模的对象。文档中的每个元素在 DOM 中都有相应的存在:每个段落、每个列表项(和每个列表)、每个跨度等等。这包括在呈现的文档中可能不可见的元素，比如`<script>`标签、样式表等等。甚至文档的标题也会在 DOM 中。如果它在文档的标记中，它就会出现在 DOM 中。此外，DOM 提供了许多用于访问和操作这些元素的有用属性。

DOM 还提供了一个事件模型,用于捕获用户与文档的交互:按键、鼠标移动等等。使用 DOM 事件，您可以编写响应用户交互的脚本，从简单的事情，比如当用户单击某个段落时高亮显示它，到在屏幕上拖放元素。

唐！唐！= JavaScript〔??〕

JavaScript 经常因为难以处理而受到抨击，而实际上具体的问题实际上与 DOM 有关，而不是 JavaScript 本身。理解 DOM 不是 JavaScript 很重要。DOM 是浏览器制造商提供的文档接口。这两者紧密交织在一起，许多人错误地认为它们是一样的，但事实并非如此。

很容易将 JavaScript 和 DOM 混为一谈，因为您在浏览器中用 JavaScript 做的大部分事情都涉及到操作浏览器加载的文档。但是如果您要在不同的上下文中访问 JavaScript 解释器，例如，在服务器或工作站上使用 Node.js，您不一定需要访问 DOM。

DOM 实际上不是 JavaScript 的一部分，也不是由 ECMA-262 标准定义的。相反，DOM 由自己的标准管理，由万维网联盟(W3C)维护。尽管 DOM 不是 JavaScript 本身的一部分，但是没有提到它，任何 JavaScript 参考都是不完整的。您在基于浏览器的 JavaScript 中所做的大部分工作都将涉及到 DOM。事实上，DOM 和 JavaScript 如此紧密地交织在一起，以至于不太有经验的 JavaScript 开发人员将 DOM 特性称为 JavaScript 特性并不罕见。

DOM 标准的产生直接源于 Web 历史初期所谓的“浏览器战争”。当时，浏览器制造商决定他们想要如何解析 HTML 文档，以及他们想要向他们的 JavaScript 引擎公开什么(如果有的话)。结果，web 开发成了依赖于浏览器的代码和“在 Netscape 中最佳浏览”以及“在 Internet Explorer 中最佳浏览”横幅的噩梦。

作为回应，业界决定不仅要标准化用于构建 Web 的语言(HTML、CSS 和 JavaScript ),还要标准化浏览器应该如何实现这些语言。这保证了所有浏览器之间的公平竞争，使得抛弃依赖于浏览器的编码成为可能。

然而，实现这一承诺需要一些时间。网络标准化是一项艰巨的任务，从许多方面来说，是一个永远不会真正“完成”的过程。技术在不断发展，导致标准也随之变化，这对浏览器制造商来说很难，因为他们必须瞄准多个移动目标。即便如此，正如我们所知，DOM 和其他 web 标准为现代 Web 铺平了道路。

DOM 标准的历史

如前所述，DOM 由它自己的独立标准管理，该标准归 W3C 所有。DOM 标准最初是在三个主要迭代中开发的，第 1 级、第 2 级和第 3 级。

第一级 DOM 标准是第一个被提出来的，它为所有其他标准提供了基础。它有两个主要特性:一组通用的底层接口，用于表示任何结构化的标记文档，特别是对 HTML 文档通用规范的扩展。

HTML :描述性、结构性、语义性

一般来说，标记语言是指定注释文档的语法的一族语言。概括地说，标记语言分为三类:

*   *表示*:注释通常是低级的(通常不是人类可读的)格式，用于指定应用应该如何显示内容。例如，文字处理器经常使用表示性标记。
*   *程序性*:类似于表示性，但是注释是更高级的格式。注释通常是人类可读的，旨在指定内容应该如何显示。示例包括 PostScript、troff 和 TeX。
*   *描述性*:注释用于根据属性描述文档的各个部分。如何显示内容由解释应用决定。示例包括 Scribe、SGML 和 HTML。

HTML 的标签根据它们各自的结构属性来注释内容，所以 HTML 通常被称为“结构”标记语言。它也经常被称为“语义”标记语言，因为许多结构注释引用了它们目标内容的语义，例如段落的`<p>`，或者标题的`<header>`。然而，一些 HTML 标签在语义上是空的，仅指结构，例如`<div>`或`<span>`标签。

二级 DOM 标准紧随其后，提供了比一级更大的深度。它实际上由六个独立的规格组成:

*   *核心*:扩展了 1 级 DOM 核心规范，并包含了新的 XML 接口。规格在`www.w3.org/TR/DOM-Level-2-Core/`。
*   *事件*:提供在大多数现代浏览器中实现的事件模型。具体请参见下面的 DOM 事件。链接:`www.w3.org/TR/DOM-Level-2-Events/`
*   HTML :用 HTML 和 XHTML 特有的特性扩展了 2 级核心规范。链接:`www.w3.org/TR/DOM-Level-2-HTML/`
*   *遍历和范围*:提供识别文档内容范围的接口，以及在 DOM 中移动的接口:例如，从一个给定的元素开始，找到它的所有兄弟元素，或者它的所有子元素。链接:`www.w3.org/TR/DOM-Level-2-Traversal-Range/`
*   *Style* :为文档的层叠样式表(CSS)提供接口，以及应用于元素的样式。链接:`www.w3.org/TR/DOM-Level-2-Style/`
*   *视图*:指定浏览器呈现给脚本引擎的视图，包括 JavaScript。链接:`www.w3.org/TR/DOM-Level-2-Views/`

第三级 DOM 规范是对第一级和第二级的扩展。它由五个独立的规格组成:

*   *核心*:作为 1 级和 2 级核心的进一步扩展，提供新的接口和方法。链接:`www.w3.org/TR/DOM-Level-3-Core/`
*   *Events* :扩展了 2 级事件规范，为键盘和鼠标滚轮事件以及突变事件(当 DOM 节点被修改时触发的事件)提供了事件规范。链接:`www.w3.org/TR/DOM-Level-3-Events/`
*   *加载并保存*:指定如何解析 XML 并从中生成 DOM 树，以及如何将 DOM 树序列化为 XML。链接:`www.w3.org/TR/DOM-Level-3-LS/`
*   *验证*:指定当文档被各种方法更改时，如何保持文档内部的一致性。链接:`www.w3.org/TR/DOM-Level-3-Val/`
*   *XPath* :提供了使用 XPath 访问 DOM 树的规范。链接:`www.w3.org/TR/DOM-Level-3-XPath/`

最后，HTML5 系列规范是 W3C 在 2012 年 12 月推荐的候选规范，它包含了 DOM 规范，这些规范包含了以前规范中的大部分内容。

目前，有十几个文档指定了 DOM 标准，其中一些完全或部分地包含了其他标准。为了避免混淆，也为了避免无意中将 DOM 标准与 HTML5 语言规范捆绑在一起(您应该能够将 DOM 标准用于任何结构化标记语言，而不仅仅是 HTML)，已经开始将所有不同的部分整合到一个规范中。您可以在以下两个位置查看结果:

*   W3C 的 DOM4(`http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html`)2012 年 12 月工作草案。该版本提供了更多关于各种版本如何合并在一起的背景信息，包括未来的整合计划。
*   Web 超文本应用技术工作组(WHATWG)的动态 DOM 规范(`http://dom.spec.whatwg.org/`)。

WHATWG 是一个独立于 W3C 的组织，它的成立是为了回应对 W3C 方法的关注。这两个组织之间存在一定程度的紧张，但最终他们有着相同的目标，尽管他们维护着不同版本的 DOM 规范，但他们的版本永远不会不一致。我们鼓励您查看这两个版本；它们提供了相同信息的略微不同的视图。

浏览器依赖关系

仅仅因为 DOM 存在管理标准，并不意味着所有浏览器都平等地实现它们。DOM 标准是随着时间的推移而产生的，其驱动力是控制浏览器制造商的不同和分散的文档模型实现的需要，即使在今天，标准化仍在进行中。我们在前两章学习的 JavaScript 在跨浏览器时相当稳定。对于 DOM，我们将会遇到不同浏览器之间的实现差异，甚至同一浏览器的不同版本之间的差异。不幸的是，这些变化通常非常明显，如果不加以解决，可能会导致代码在一种浏览器中运行，但在其他浏览器中却顽固地拒绝运行。

好消息是，现代浏览器(Internet Explorer 9 和更高版本、Firefox 4 和更高版本、Chrome、Safari 和 Opera)很好地实现了这些标准。Internet Explorer 的旧版本是不良实现的罪魁祸首，不幸的是，您经常不得不在您的项目中提供对这些旧版本的支持。大多数情况下，这些实现问题可以用 JavaScript 来缓解。更好的是，已经有几十个优秀的、经过良好测试的 JavaScript 库可以做到这一点。

这些库中最流行的可能是 jQuery，它最初是由 John Resig 创建的，现在作为一个开源项目维护着。根据一些浏览器统计，jQuery 是 Web 上部署最广泛的库，因此它肯定经过了很好的测试。我们将在第四章中介绍 jQuery 的使用。

jQuery 不是唯一可用的库；还有很多其他的。最早创建的库之一叫做 Prototype，它仍然被广泛使用，也是一个积极维护的开源项目。其他值得注意的库有 Dojo Toolkit、script-aculo-us、MooTools 和 Yahoo 的 YUI 库。如果你想要提供更多支持的东西——更像一个框架的东西——有 Sencha Ext JS、Closure Library 和 AngularJS(都是谷歌的)、Backbone.js 和 Montage(JavaScript 框架领域的新来者，但却是我们的最爱)等选择。

在这一章中，我们将从标准的角度来讨论 DOM。当我们在实现中遇到严重分歧时，我们会提到它们，但可以肯定的是，浏览器版本越老，它不能正确实现标准的某些方面的可能性就越大。我们还将讨论缓解技术，因此您应该能够解决最严重的问题。总的来说，如果您发现自己不得不支持许多旧版本的浏览器，您可能会发现一个精心选择的 JavaScript 库可以避免许多令人头疼的问题。

如果您将支持旧版本的浏览器，您将需要评估它们对项目所需功能的支持程度。Peter-Paul Koch 在他的 QuirksMode 网站上维护了两个优秀的页面，一个是 DOM 特性页面(`www.quirksmode.org/dom/w3c_core.html`)，另一个是 DOM 事件页面 ( `www.quirksmode.org/dom/events/`)。这些页面是评估您的浏览器支持情况的一个很好的起点。

DOM 结构

现在您已经知道了 DOM 是什么以及它是如何产生的，您已经准备好深入了解它实际上是如何为您工作的了。从概念上讲，DOM 结构可以被认为是一棵树，它表示加载到浏览器中的文档和子文档，以及每个文档和子文档的单个元素。

该结构的顶部是`window`对象，它代表包含加载文档的实际浏览器窗口。因为 HTML 文档可以通过使用 iframes 包含子文档，所以`window`对象实际上是一个类似数组的对象。它有一个`length`属性，代表文档包含的 iframe 的数量，这些 iframe 可以通过索引(例如`window[0]`)访问，或者，如果`<iframe>`标签有`name`属性，可以通过`window['iframename']`访问。`window`对象还有一个`frames`属性，它是一个数组，表示文档中 iframes 的数量。它只是对`window`对象本身的引用(换句话说，如果存在子文档，就是`window === window.frames`和`window[0] === window.frames[0]`)，但是它的优点是更加明确。两种语法都可以。

每个子文档都有自己的`window`对象，因为任何给定的子文档本身都可以包含子文档，所以子文档的`window`对象也是一个类似数组的对象。

`window`对象有几个其他有用的方法和属性。`window`对象也作为 JavaScript 的全局上下文，如清单 3-1 所示。

***清单 3-1。*** 窗口对象是 JavaScript 的全局上下文

```js
myVar = 5;           // defined without var keyword, so it is global
alert(window.myVar); // will alert 5
```

因为`window`为 JavaScript 提供了全局上下文，所以您不需要将`document`对象显式地作为`window`对象的属性来访问；相反，你可以直接访问它(换句话说，引用`window.document.title`和引用`document.title anywhere in your script`是一回事)。

`window`对象有一个`document`属性，它是对已经加载到浏览器窗口中的文档的引用。`document`对象包含了代表文档本身元素的树。每个段落标记、每个 span 标记、每个 div 标记，甚至脚本标记、HTML 和 body 标记以及文档标题都将出现在`document`对象中。如果它在 HTML 标记中，它将被表示在`document`对象中。此外，`document`对象有几个访问元素的方法，并为事件提供基础。

在结构上，DOM 由*节点*组成，每个节点代表 HTML 文档中的内容(通常是一个标签，但也可以代表注释和元数据)。因为 HTML 是结构化的，所以节点是结构化组织的:DOM 中元素的节点可以有子节点，这些子节点表示元素本身包含的标签。类似地，DOM 中的一个节点可以有一个表示该元素的父标记的父节点。

考虑清单 3-2 中的简单示例文档。

***清单 3-2。*** 简单的 HTML 文档

```js
<!DOCTYPE html>
<html>
    <head>
        <title>JavaScript Programmer's Reference</title>
    </head>
    <body>
          <p id="myParagraph">This is my paragraph! <span class="hideme">Lorem ipsum</span> dolor sit amet.<span></span></p>
        <p class="hideme">Another paragraph!</p>
        <script>
alert(document.title); // will alert "JavaScript Programmer's Reference"
        </script>
    </body>
</html>
```

HTML5 示例

清单 3-2 是我们展示整个 HTML 文档而不仅仅是 JavaScript 片段的第一个例子。因为 DOM 操作涉及到处理 HTML 文档，所以我们将在本章的例子中使用这种格式。特别是，我们将使用 HTML5，如 DOCTYPE 标签所指定的。

请注意，如果您使用的是特别旧的浏览器版本(例如，Internet Explorer 6 或 Firefox 2)，这些示例可能会有问题。(如果您使用的是这种旧版本的浏览器，我们鼓励您尽可能升级。)

如果加载这个文档，浏览器会提示“JavaScript 程序员参考”，因为标题被`document.title`属性引用。

正文中的节点由`document`对象上的`childNodes`属性引用:

```js
alert(document.childNodes); // Depending on browser, will alert something like "[object NodeList]"
```

DOM 中的节点由类似数组的节点列表表示。它们有一个`length`属性，表示存在多少个节点，单个节点本身可以通过它们的索引来访问。

每个单独的节点都有不同的属性，这取决于它所代表的元素，但本质上，元素上的任何属性都有一个作为节点上的属性的表示。例如，段落标签上的 class 属性将在其节点上的`className`属性中表示。

使用这种节点树，您可以访问 DOM 中的任何元素。例如，`document.childNodes[1].childNodes[2].childNodes[3]`表示我们标记中的第二段:

```js
alert(document.childNodes[1].childNodes[2].childNodes[3].className); // will alert "hideme"
```

单个节点通过`parentNode`属性引用它们的父节点。因为一个标签只能有一个父标签，所以`parentNode`属性不是一个类似数组的集合，而是一个简单的属性:

```js
alert(document.childNodes[1].childNodes[2] == document.childNodes[1].childNodes[2].childNodes[3].parentNode); // will alert "true" because the body tag is the parent node of the paragraph
```

这是 DOM 的基本结构，但是在访问元素时，它非常笨拙。你可以访问任何东西，但是即使我们的超级简单的文档，我们已经产生了相当长的引用链。想象一下，如果我们有一个复杂的文档，这些链会有多长！幸运的是，DOM 提供了比通过这些长引用链访问元素更好的方法。

访问 DOM 中的元素

通常，您希望直接访问 DOM 中的元素，并对它做一些事情:隐藏、显示、移动、删除、监听事件等等。DOM 提供了几种不同的方法来直接访问元素，或者从一个已知的位置开始遍历树。

可能最著名和最简单的访问元素的方法是使用`document.getElementById()`方法，如清单 3-3 所示。

***清单 3-3。*** 使用 getElementById()

```js
<!DOCTYPE html>
<html>
    <head>
        <title>JavaScript Programmer's Reference</title>
    </head>
        <body>
        <p id="myParagraph">This is my paragraph! <span class="hideme">Lorem ipsum</span> dolor sit amet.<span></span></p>
        <p class="hideme">Another paragraph!</p>
        <script>
var myPar = document.getElementById("myParagraph"); // myPar is now a pointer to the paragraph.
myPar.innerText = "I have changed the content!"; // Change the text of the paragraph to "I have changed the content!"
        </script>
    </body>
</html>
```

在这个例子中，我们得到一个指向特定节点的指针，然后用新内容更新它的`innerText`属性。当这个文档加载时，您将看到两段:第一段将显示“我已经更改了内容！”而第二个会读作“又一段！”

在清单 3-3 中，`document.getElementById()`方法和`innerText`属性是由 DOM 标准而不是 JavaScript 标准指定的。由于它们与浏览器中的 JavaScript 无缝集成，您可以看到很容易将它们误认为 JavaScript，如前所述。

DOM 还公开了其他几种直接访问节点的方法。`getElementsByTagName()`方法将一个标签名作为参数，并返回它在文档中找到的属于该标签的所有节点的集合，如清单 3-4 所示。集合是一个类似数组的对象，所以你可以迭代单个元素，它们在文档中按照解析的顺序出现，如清单 3-4 所示。

***清单 3-4。*** 使用 getElementsByTagName()

```js
<!DOCTYPE html>
<html>    <head>
        <title>JavaScript Programmer's Reference</title>
    </head>
    <body>
        <p id="myParagraph">This is my paragraph! <span class="hideme">Lorem ipsum</span> dolor sit amet.<span></span></p>
        <p class="hideme">Another paragraph!</p>    <script>
var myPars = document.getElementsByTagName("p"),
  mySpans = document.getElementsByTagName("span"),
  myParsLength = myPars.length,
  mySpansLength = mySpans.length,
  i;

// Give paragraphs a red background color
for (i = 0; i < myParsLength; i++) {
  myPars[i].style.backgroundColor = "red";
}

// Add some content to our empty span, and alert its index
for(i = 0; i < mySpansLength; i++) {
  if (mySpans[i].innerText === "") {
    mySpans[i].innerText = "No longer empty!";
    alert(i);
  }
}        </script>
    </body>
</html>
```

清单 3-4 将两个段落都改为红色，添加文本“不再是空的！”到空跨度，并警告数字 1，它是由`getElementsByTagName()`方法返回的跨度集合中的空跨度的索引。

在 HTML5 之前，`getElementById()`和`getElementsByTagName()`是 DOM 标准指定的直接访问元素的两种方法。HTML5 规范增加了三个新方法:`getElementsByClassName()`、`querySelector()`和`querySelectorAll()`。

`getElementsByClassName()`方法的工作方式类似于`getElementById()`，除了它将一个类作为参数，并返回一个类似数组的包含该类元素的集合，如清单 3-5 所示。

***清单 3-5。*** 使用 getElementsByClass()

```js
<!DOCTYPE html>
<html>
    <head>
    	<title>JavaScript Programmer's Reference</title>
    </head>
    <body>
      <p id="myParagraph">This is my paragraph! <span class="hideme">Lorem ipsum</span> dolor sit amet.<span></span></p>
      <p class="hideme">Another paragraph!</p>
      <script>
var hideme = document.getElementsByClassName("hideme"),
  hidemeLength = hideme.length,
  i;

// Hide all the elements that have a class of "hideme"
for (i = 0; i < hidemeLength; i++) {
  hideme[i].style.display = "none";
}
      </script>
    </body>
</html>
```

在清单 3-5 的中，我们获取了所有具有“hideme”类的元素，然后通过将其 CSS `display`属性改为“none”来隐藏每个元素

`querySelector()`和`querySelectorAll()`方法比其他方法提供了更多的灵活性。这两种方法都将任何有效的 CSS 选择器作为参数。`querySelector()`参数将返回文档中匹配的第一个元素(按标记顺序)，而`querySelectorAll()`将返回与选择器匹配的所有元素的类数组集合(如果只有一个匹配，方法将返回一个有一个成员的类数组对象；如果没有匹配，该方法将返回一个没有成员的类似数组的对象，即长度为 0)。这给了我们一个强大的工具来访问 DOM 中的元素，如清单 3-6 所示。

***清单 3-6。*** 使用 querySelector()

```js
<!DOCTYPE html>
<html>
    <head>
        <title>JavaScript Programmer's Reference</title>
    </head>
    <body>
      <p id="myParagraph">This is my paragraph! <span class="hideme">Lorem ipsum</span> dolor sit amet.<span></span></p>
      <p class="hideme">Another paragraph!</p>
      <script>
var emptySpan = document.querySelector("#myParagraph span:last-child"); // Get the last span
emptySpan.innerText = "Not empty anymore!" // And give it some text.
      </script>
    </body>
</html>
```

在这个例子中，我们使用 CSS 伪选择器`last-child`访问段落的最后一段。当它运行时，这个例子将会显示“不再是空的！”在最后一段时间里。

关于使用`querySelector()`和`querySelectorAll()`的一个有趣的事情是，你想用 JavaScript 访问的元素通常就是你想用样式表访问的元素。因此，您经常会发现在 CSS 中使用的一些相同的选择器会作为查询出现在 JavaScript 中。

![image](img/sq.jpg) **注意**如果您打算编写依赖于`querySelector()`或`querySelectorAll()`的代码，并计划支持旧版本的浏览器，这些版本可能不会为您提供这些方法，因为这些方法是最近添加到 DOM 标准中的。在这种情况下，您总是可以使用选择器库来添加特性。最常用的选择引擎叫做 Sizzle，在`www.sizzlejs.com/`可以买到。它不依赖于其他库，非常小，非常高效，并且经过了很好的测试(它是 jQuery 库中包含的引擎)。

最后，DOM 中的每个节点都拥有这些元素选择方法，就像顶级的`document`对象一样。当你在一个 DOM 节点上使用其中一个方法时，这个方法的范围被限制在那个节点的子节点上，正如你在清单 3-7 中看到的。

***清单 3-7。*** 使用元素上的方法

```js
<!DOCTYPE html>
<html>
    <head>
        <title>JavaScript Programmer's Reference</title>
    </head>
    <body>
      <p id="myParagraph">This is my paragraph! <span class="hideme">Lorem ipsum</span> dolor sit amet.<span></span></p>
      <p class="hideme">Another paragraph!</p>
      <script>
var myPar = document.getElementById("myParagraph"), // Get a reference to the first paragraph
  mySpan = myPar.querySelector("span:last-child"); // Get a reference to the last span in that paragraph

mySpan.innerText = "Not empty anymore!"
      </script>
    </body>
</html>
```

这个例子，如清单 3-6 ，将添加文本“不再为空！”到那一段的最后一段。在这种情况下，我们首先使用`getElementById()`获得对段落的引用，然后使用`querySelector()`只搜索该段落的子元素。这也适用于 DOM 片段(关于 DOM 片段的详细信息，请参见下一节)。

遍历 DOM

访问 DOM 中元素的另一种方式是从 DOM 树中的一个已知位置开始，然后使用父/子/兄弟关系遍历到一个不同的位置。在前一节中，我们已经看到了一个基本的例子。幸运的是，DOM 为遍历提供了一些方便的属性:

*   `Node.firstChild`:引用节点的第一个子节点
*   `Node.lastChild`:引用节点的最后一个子节点
*   `Node.nextSibling`:引用节点的下一个兄弟节点
*   `Node.previousSibling`:引用该节点的上一个兄弟节点

清单 3-8 显示了这些遍历属性的一个例子。

***清单 3-8。*** 使用遍历属性

```js
<!DOCTYPE html>
<html>
    <head>
        <title>JavaScript Programmer's Reference</title>
    </head>
    <body>
      <p id="myParagraph">This is my paragraph! <span class="hideme">Lorem ipsum</span> dolor sit amet.<span></span></p>
      <p class="hideme">Another paragraph!</p>
      <script>
var mySpan = document.getElementById("myParagraph").lastChild;
mySpan.innerText = "Not empty anymore!"
      </script>
    </body>
</html>
```

此示例将在第一段的最后一个跨度中填入文本“不再为空！”

现在您已经知道了如何访问 DOM 中的元素，下一节将介绍如何使用它们。

修改 DOM

除了使您能够访问文档中的元素之外，DOM 还为操作这些元素提供了一个灵活的框架。您可以通过更改现有元素的属性、内容，甚至将它们从 DOM 中的一个地方完全移到另一个地方来修改它们。您也可以删除元素并创建新的元素。

修改现有元素

您可能想要对现有元素进行的最基本的修改是访问并更改其属性。大多数简单元素属性在元素的关联节点上显示为简单属性，您可以直接获取和设置值。

例如，清单 3-9 展示了如何直接改变一个简单锚标签的`href`属性。

***清单 3-9。*** 修改元素的属性

```js
<!DOCTYPE html>
<html>
    <head>
        <title>JavaScript Programmer's Reference</title>
    </head>
    <body>
      <p id="myParagraph"><a href="http://www.yahoo.com/">This is my link!</a></p>
      <script>
var myLink = document.querySelector("#myParagraph a");
myLink.href = "http://www.google.com";
      </script>
    </body>
</html>
```

在这个例子中，我们正在修改`href`属性，将其从`www.yahoo.com`更改为`www.google.com`。如果你把这个例子载入你的浏览器，点击链接，它会把你带到谷歌而不是雅虎。使用这种技术，您可以修改元素的大多数简单属性:`name`、`href`，甚至元素的`id`。

修改样式

对于某些属性，DOM 提供了更健壮的接口。例如，在清单 3-10 的中，一个元素的`style`属性提供了一个元素上所有内联样式的映射。

***清单 3-10。*** 修改元素的样式属性

```js
<!DOCTYPE html>
<html>
    <head>
        <title>JavaScript Programmer's Reference</title>
    </head>
    <body>
      <p id="myParagraph"><a href="http://www.yahoo.com/">This is my link!</a></p>
      <script>
var myLink = document.querySelector("#myParagraph a");
myLink.style.backgroundColor = "#ff0000";
myLink.style.color = "#fff";
      </script>
    </body>
</html>
```

在本例中，我们修改了链接，使背景色为红色，前景色为白色。

当访问一个元素的`style`属性时，如清单 3-11 所示，你所做的就是处理内联样式。`style`属性不是通过样式表应用于元素的样式的表示，如清单 3-11 所示。

***清单 3-11。***style 属性仅用于内联样式

```js
<!DOCTYPE html>
<html>
    <head>
        <title>JavaScript Programmer's Reference</title>
        <style>
#myParagraph a {
  background-color: #ff0000;
  color: #ffffff;
}
        </style>
    </head>
    <body>
      <p id="myParagraph"><a href="http://www.yahoo.com/">This is my link!</a></p>
      <script>
var myLink = document.querySelector("#myParagraph a");
alert(myLink.style.backgroundColor); // will alert "" (empty)
alert(myLink.style.color); // will alert "" (empty)
      </script>
    </body>
</html>
```

即使我们已经设置了背景颜色和文本颜色，这两个警告都是空的。这是因为它们是使用样式表而不是内联样式设置的。

类似地，如果您修改了元素的`style`属性，DOM 会将您的更改作为内联样式插入。检查清单 3-11 中的元素，你会看到它看起来像这样:

```js
<a href="http://www.yahoo.com/" style="background-color: rgb(255, 0, 0); color: rgb(255, 255, 255);">This is my link!</a>
```

您可以通过使用`window`对象的 DOM 的`getComputedStyle()`方法来确定哪些样式当前正在元素上工作，如清单 3-12 所示。此方法采用一个元素引用并返回一个对象，该对象表示元素上当前活动的样式，无论这些样式来自样式表还是内联样式。该对象将与元素上的`style`属性具有相同的格式。

***清单 3-12。*** 使用 window.getComputedStyle()方法

```js
<!DOCTYPE html>
<html>
    <head>
        <title>JavaScript Programmer's Reference</title>
        <style>
#myParagraph a {
  background-color: #ff0000;
  color: #ffffff;
}
        </style>
    </head>
    <body>
      <p id="myParagraph"><a href="http://www.yahoo.com/" style="color: #00ff00">This is my link!</a></p>
      <script>
var myLink = document.querySelector("#myParagraph a"),
  styleObject = window.getComputedStyle(myLink);

alert(styleObject.backgroundColor); // will alert something like "rgb(255, 0, 0)"
alert(styleObject.color); // will alert something like "rgb(0, 255, 0)"
      </script>
    </body>
</html>
```

本例将首先警告应用于目标元素背景的颜色——在本例中为红色或 rgb(255，0，0)。第二个警告将显示文本的颜色。在这种情况下，我们有两个冲突的样式，一个在样式表中，另一个是内联样式。内联样式具有更高的特异性，因此它会胜出，脚本将发出绿色或 rgb(0，255，0)警告。

另一个要更改的常见属性是元素的类。HTML5 DOM 规范包括一个用于管理类的健壮接口:`classList`属性。当直接访问时，`classList`属性将返回一个类似数组的对象，其中包含应用于该元素的类。(如果没有类应用于元素，对象的长度将为 0。)每个单独的类都可以通过索引来访问。此外，`classList`属性公开了一组有用的助手方法(参见清单 3-13 中的使用):

*   `classList.add(classname)`:在`classList`中增加`classname`类。
*   `classList.contains(classname)`:如果`classname`出现在`classList`中，则返回 true。
*   `classList.remove(classname)`:从`classList`中移除类`classname`。
*   `classList.toggle(classname)`: If `classname` is present in `classList`, it is removed; otherwise it is added.

    ***清单 3-13。*** 使用 classList 接口

    ```js
    <!DOCTYPE html>
    <html>
        <head>
            <title>JavaScript Programmer's Reference</title>
            <style>
    .redclass {
      background-color: #ff0000;
    }
    .greenclass {
      background-color: #00ff00;
    }
            </style>
        </head>
        <body>
          <p id="myParagraph" class="redclass">Here is a paragraph.</p>
          <script>
    var myPar = document.getElementById("myParagraph");
    myPar.classList.toggle("redclass"); // removes redclass from classList
    myPar.classList.add("greenclass"); // adds greenclass to classList
          </script>
        </body>
    </html>
    ```

在本例中，段落的背景色是绿色。

旧版本的浏览器没有`classList`接口，你必须通过`className`属性手动修改类字符串。此外，许多 JavaScript 库提供了管理类的方法。

修改内容

另一个常见的任务是访问和修改元素的内容。DOM 提供了一个属性来访问元素中的实际标记，还提供了一个属性来访问标记中包含的文本:

*   `Node.innerHTML`:提供一个节点内部 HTML 的接口。当简单访问时，它返回包含在节点中的 HTML。如果用作 setter，它将删除元素中包含的 HTML(及其在 DOM 中的关联节点)，并用指定的 HTML 替换它(并将关联节点添加到 DOM 中)。这个接口最初是由 Internet Explorer 团队在许多年前创建的，它非常有用，以至于在它成为 HTML5 标准的一部分之前，所有其他浏览器团队都实现了它。
*   `Node.innerText`(非标准，在除 Firefox 之外的所有浏览器中可用)或`Node.textContent`(标准，在除 Internet Explorer 之外的现代浏览器中可用):类似于`Node.innerHTML`，除了它只返回节点中包含的所有元素的文本。它不返回任何 HTML 标记。当用作 setter 时，它删除节点中的所有内容，并插入提供的文本。

清单 3-14 展示了这两种方法的使用示例。

***清单 3-14。*** 使用 innerHTML 和 innerText

```js
<!DOCTYPE html>
<html>
    <head>
        <title>JavaScript Programmer's Reference</title>
    </head>
    <body>
      <p id="firstParagraph">Here is a paragraph.</p>
      <p id="secondParagraph">Here is another paragraph. It contains <span>some other tags,</span> <a href="http://www.google.com/">as well.</a></p>
      <script>
var firstPar = document.getElementById("firstParagraph"),
  secondPar = document.getElementById("secondParagraph");

alert(firstPar.innerText); // will alert "Here is a paragraph."
alert(secondPar.innerText); // will alert "Here is another paragraph. It contains some other tags, as well."
alert(firstPar.innerHTML); // will alert "Here is a paragraph."
alert(secondPar.innerHTML); // will alert "Here is another paragraph. It contains <span>some other tags,</span> <a href="http://www.google.com/">as well.</a>"

firstPar.innerText = "I have changed the text."; // will change the text of the first paragraph
secondPar.innerHTML = "<ul><li>How do I love thee?</li><li>Let me count the ways!</li></ul>"; // will change the HTML inside the second paragraph
      </script>
    </body>
</html>
```

在这个例子中，我们首先使用属性来查看段落的内容，然后使用它们来更改内容。

![image](img/sq.jpg) **警告**这些方法非常有用，但是有一个重要的警告:使用`innerHTML`时要非常小心，因为你放入的任何东西都会被解析成 DOM 节点并插入到 DOM 中。如果不仔细清理插入到 DOM 中的 HTML，就会出现严重的安全问题。具体来说，对于来自用户或者您无法完全控制的任何内容，使用`innerHTML`时要非常小心。这些方法将插入任何 HTML，包括脚本标记，因此如果您盲目地将用户提供的 HTML 插入到您的文档中，那么对于用户来说，包含可能访问您的应用数据并完全危及您的安全性的恶意脚本是微不足道的。

创建新元素

除了`innerHTML`，DOM 还提供了创建新元素的通用方法:`createElement()`方法。它将 HTML 标记名作为参数，并返回指定类型的普通 DOM 节点。然后，您可以使用该节点，就好像它是您通过某种访问方法访问过的节点一样:您可以修改它的属性、更改它的内容等等。

生成的节点没有附加到文档，因此 DOM 还提供了以下一组方法，用于将这些片段插入到主 DOM 中，从而使它们的关联标记呈现在浏览器窗口中:

*   `parentNode.appendChild(fragment)`:将 DOM 片段作为`parentNode`的子节点附加在其现有子节点(如果有)的末尾
*   `parentNode.insertBefore(fragment, targetNode)`:将 DOM 片段作为`parentNode`的子元素和`targetNode`的兄弟元素插入到文档中
*   `parentNode.replaceChild(fragment, targetNode)`:用`fragment`代替`targetNode`

注意，片段可以引用使用`createElement()`(或其他方法)创建的分离片段，也可以引用文档中的现有节点。如果是后者，这些方法会在将片段插入到新位置之前，将它从先前的位置移除。这使得在 DOM 中将节点从一个地方移动到另一个地方变得很容易。

最后，DOM 提供了一种使用`cloneNode()`方法复制现有节点的方法，参见清单 3-15 。`cloneNode()`方法可以接受一个可选的布尔参数，如果设置为 true，则指示克隆是“深层的”,并包括目标节点的所有子节点。

***清单 3-15。*** 使用 DOM 方法创建新节点并将它们添加到文档中

```js
<!DOCTYPE html>
<html>
    <head>
        <title>JavaScript Programmer's Reference</title>
    </head>
    <body>
      <p id="firstParagraph">Here is a paragraph.</p>
      <p id="secondParagraph">Here is another paragraph. It contains <span>some other tags,</span> <a href="http://www.google.com/">as well.</a></p>
      <script>
var firstPar = document.getElementById("firstParagraph"),
  secondPar = document.getElementById("secondParagraph"),
  targetLink = document.querySelector("#secondParagraph a"),
  myNewList = document.createElement("ul"),
  myNewListItemTemplate = document.createElement("li"),
  myNewListItem = myNewListItemTemplate.cloneNode();

myNewListItem.classList.add("menuitem");
myNewListItem.innerText = "One";
myNewList.appendChild(myNewListItem);
myNewListItem = myNewListItemTemplate.cloneNode();
myNewListItem.appendChild(targetLink);
myNewList.appendChild(myNewListItem);
firstPar.appendChild(myNewList);
      </script>
    </body>
</html>
```

在这个例子中，我们首先使用`createElement()`方法创建一个无序列表和一个列表项模板。然后我们克隆模板，使用`innerText`属性给克隆一个新的 CSS 类和一些文本，并将其添加到无序列表中。然后，我们再次克隆模板，并将第二段中的链接添加到模板中。这将从该位置移除该链接，并将其插入列表项中。最后，我们将列表项添加到列表中，并将列表添加到第一段。

删除元素

DOM 为我们提供了几种删除目标节点的方法:

*   `parentNode.removeChild(targetNode)`:从`parentNode`中删除`targetNode`。
*   `parentNode.innerHTML`:通过将一个节点的`innerHTML`设置为空字符串，我们可以一次移除它的所有子节点。

但是，在从 DOM 中删除元素时，有一些注意事项。如果元素附加了事件处理程序，特别是自由使用闭包来维护其状态的事件处理程序，简单地删除那些处理程序所绑定的元素并不一定会将它们从内存中清除。这是动态应用中内存泄漏的主要原因。在从 DOM 中移除元素(当然还有它们的子元素)之前，一定要明确地移除事件处理程序。

Internet Explorer 的旧版本(主要是 6 和 7)在从 DOM 中移除元素时不释放内存是非常糟糕的。事实上，即使元素已经从 DOM 中删除，这些旧版本的 Internet Explorer 仍会保留每个元素的一些内存，从而导致内存泄漏。高度动态的页面，其中大量的元素被添加到 DOM 中或者从 DOM 中删除，在 IE 中只会变得越来越大。有一个简单的技巧可以解决这个问题:IE 专有财产`outerHTML`。

`outerHTML`属性引用元素的父元素的 HTML 当用作 setter 并给定一个空字符串时，它从 DOM 中有效地移除元素。它不会完全从内存中清除该元素，但确实有所帮助。

因此，对于一个普通的元素删除，你应该遵循类似的步骤(如清单 3-16 所示):

1.  从目标元素及其子元素中删除任何事件处理程序。
2.  使用`removeChild()`删除元素。
3.  Check if `outerHTML` is available and, if so, use it to clear the memory in IE.

    ***清单 3-16。*** 有效地从 DOM 和内存中删除一个元素

    ```js
    var myTarget = document.getElementById("deleteme");
    deleteme.removeEventListener("click", clickHandler, false);

    myTarget.parentNode.removeChild(myTarget);

    if (typeof document.outerHTML !== "undefined") {
      myTarget.outerHTML = "";
    }
    ```

在清单 3-16 所示的人为例子中，我们首先获取对目标元素的引用，然后移除它的事件处理程序，然后从 DOM 中移除它。然后，我们检查我们是否在 Internet Explorer 中操作，如果是，则清除与该元素相关的内存。

如果您使用的是 JavaScript 库，它可能会为您管理这个过程，特别是当它公开自己的 API 来从 DOM 中删除元素时。

DOM 事件

除了提供对元素的访问，DOM 还指定了处理用户与元素交互的框架。当用户与页面上的元素交互时——鼠标悬停、单击、选择、拖动、输入等等——浏览器会将这些交互转换为元素中的事件。然后，您可以将事件处理程序附加到特定事件的元素；一个*事件处理程序*本质上是一个当事件发生时浏览器将执行的代码块。

DOM 为处理事件提供了一个简单但健壮的框架。。。而 IE9 之前的 Internet Explorer 几乎完全忽略了它。在 IE9 之前的版本中，Internet Explorer 使用不同的方法绑定事件处理程序，为事件提供不同的执行上下文，甚至没有事件模型的完整阶段。

从积极的方面来看，处理 Internet Explorer 的不同事件模型是一项常见的任务，因此解决方案非常丰富和健壮。我们将在本节的最后讨论其中的一些解决方案，但是现在我们只关注事件模型是如何工作的。

事件阶段

当用户与某个元素交互时，浏览器会检查该元素上是否注册了该事件类型的事件处理程序。如果是，浏览器将执行该处理程序。

因为 HTML 是结构化的，并且标签可以嵌套，所以 DOM 规定，从一个元素开始的事件将“冒泡”到它的父元素——毕竟，子元素中的事件可能也需要计入父元素中。在目标元素上发生事件后，浏览器会将事件“冒泡”到目标元素的父元素。然后，它将执行相同的检查，以确定是否为事件类型注册了处理程序，如果有，则执行该处理程序。然后它会向上冒泡到下一个父节点，依此类推。最终，事件将到达 DOM 树的主干 body 元素，它是文档中任何元素的最终祖先。此时，事件将沿着它刚刚到达原始目标的路径返回，再次在每个元素上检查并执行注册的事件处理程序，一直返回到原始目标元素。一旦往返完成，事件终止。

事件沿着 DOM 树向上移动的阶段称为*冒泡阶段*，事件沿着 DOM 树向下返回的阶段称为*捕获阶段*。您可以指定希望事件处理程序在哪个阶段执行，这为您处理嵌套元素上的事件提供了极大的灵活性。例如，如果希望在父元素上执行 click 事件，然后再在原始子目标上执行，可以在冒泡阶段注册父事件处理程序，在捕获阶段注册子事件处理程序。

事件有第三个阶段，称为目标处的*，此时事件当前位于目标元素处。当绑定事件处理程序时，没有办法直接指向这个阶段，但是您可以通过`Event`对象中的一个属性来访问它(参见下面的“事件对象”)。*

事件执行上下文

当浏览器执行一个事件处理程序时，它必须为该函数提供一个执行上下文。DOM 标准规定这个上下文应该是事件处理程序绑定到的元素。因此，在事件处理函数中，`this`关键字将是一个指针，指向事件正在其上执行的 DOM 元素。

此外，当执行事件处理程序时，浏览器将向其传递一个`Event`对象(作为参数),该对象包含几个有用的属性，提供关于事件的详细信息:事件起源的原始目标元素、鼠标在目标中的位置、鼠标在页面中的位置等等。此外，`Event`对象有一些用于修改事件传播行为的有用方法(我们将在下面的“事件对象”一节中介绍这些方法)。

不同的事件

DOM 标准提供了大量的事件。它们可以分为六个基本组:

*   *鼠标事件*:`click``mousedown``mouseup``mousemove`等。这些都包含在 DOM MouseEvents 模块中。
*   *键盘事件*:`keypress``keydown``keyup`。由 DOM KeyboardEvents 模块覆盖。
*   *对象事件* : `load`、`error`、`resize`、`scroll`等。由 DOM HTMLEvents 模块覆盖。
*   *表单事件* : `select`、`change`、`submit`、`reset`、`focus`等。也包含在 DOM HTMLEvents 模块中。
*   *用户界面事件* : `focusin`和`focusout`。由 DOM UIEvents 模块覆盖。
*   *突变事件*:DOM 内部发生变化时触发的事件，如`DOMNodeInserted`、`DOMAttrModified`等。由 DOM 变异事件模块覆盖。

此外，移动设备上的浏览器还可能暴露与触摸交互相关的其他事件(`tap`、`doubletap`、`taphold`、`swipe`等)。)或移动设备特有的其他事件(方向改变、摇动、移动、位置等)。).

绑定事件处理程序

为了让浏览器对元素上的事件做出反应，您必须首先将该事件的处理程序绑定到元素。绑定一个事件处理程序本质上等同于说“当用户以这种方式与这个元素交互时，当事件经过这个阶段时执行这个代码。”DOM 为此提供的方法是`addEventListener()`方法，它有三个参数:一个`event type`参数(`click`、`keypress`等)。)、一个`listener`参数(事件发生时要执行的代码)、一个可选的布尔型`phase`参数，该参数指示事件处理程序在捕获阶段(如果设置为`true`)或冒泡阶段(如果设置为`false`，这是默认值)执行。(在一些较旧的浏览器版本中，用于采集的布尔值并不总是可选的，所以总是包含它被认为是一种良好的做法。)事件处理程序可以将事件对象作为参数，然后您可以在处理程序中访问该事件对象。你可以在清单 3-17 中看到一个绑定点击事件处理程序的例子。

***清单 3-17。*** 将点击事件处理程序绑定到一个元素

```js
<!DOCTYPE html>
<html>
    <head>
        <title>JavaScript Programmer's Reference</title>
    </head>
    <body>
      <p id="firstParagraph">Click Me!</p>
      <script>
var firstPar = document.getElementById("firstParagraph");

function myEventHandler(event) {
  alert("You clicked me!");
}

firstPar.addEventListener("click", myEventHandler, false);
      </script>
    </body>
</html>
```

当您单击该段落时，警告框将会打开。

您可以向单个对象上的一个事件添加多个事件处理程序:

```js
firstPar.addEventListener("click", myFirstEventHandler, false);
firstPar.addEventListener("click", mySecondEventHandler, false);
etc.
```

当事件被触发时，事件处理程序将按照绑定的顺序执行。

这是将事件处理程序绑定到元素的基本模式。如果你愿意，你可以使用一个内嵌匿名函数来代替一个命名函数，如清单 3-18 所示，这也是一个相当常见的模式。

***清单 3-18。*** 使用匿名内联函数作为事件处理程序

```js
<!DOCTYPE html>
<html>
  <head>
    <title>JavaScript Programmer's Reference</title>
  </head>
  <body>
    <p id="firstParagraph">Click Me!</p>
    <script>
var firstPar = document.getElementById("firstParagraph");

firstPar.addEventListener("click", function(event) {
  alert("You clicked me!");
}, false);

    </script>
  </body>
</html>
```

这个例子的行为与清单 3-17 中的例子完全相同。区别仅在于命名的函数。请注意，如果您将有一个复杂的事件处理程序，那么为它创建一个命名函数并将其作为参数传递可能是值得的。如果您的内联事件处理程序变得太长(尤其是当它长到足以跨越多个屏幕时)，您的代码可能会令人费解。

解除事件处理程序的绑定

要解除事件处理程序的绑定，使用`removeEventListener()`方法，如清单 3-19 所示。就像`addEventListener()`，`removeEventListener()`有三个参数:一个事件类型，要移除的处理函数(在命名函数的情况下)，以及布尔参数`phase`。

***清单 3-19。*** 删除事件处理程序

```js
<!DOCTYPE html>
<html>
  <head>
    <title>JavaScript Programmer's Reference</title>
  </head>
  <body>
    <p id="firstParagraph">Click Me!</p>
    <script>
var firstPar = document.getElementById("firstParagraph");

function eventHandler(event) {
  alert("I'm unbinding the event handler!");
  firstPar.removeEventListener("click", eventHandler, false);
}
firstPar.addEventListener("click", eventHandler, false);

    </script>
  </body>
</html>
```

在本例中，当您单击段落时，它将执行处理程序，然后处理程序将解除自身绑定。还要注意，这个例子使用了一个闭包:`firstPar`变量和`eventHandler`函数仍然可用，即使在事件处理程序已经被绑定并且脚本已经完成执行之后。这样，当目标对象上的事件调用事件处理程序时，它将能够成功执行。维护事件处理程序的状态是闭包在 JavaScript 开发中最常见的用法之一。(参见第一章了解更多关于闭包的细节。)

如果调用`removeEventListener()`时使用的参数组合与添加到对象中的任何事件处理程序都不匹配，那么这个方法就会终止。它不会抛出错误，也不会给出任何无效的指示。

无法解除使用匿名内联函数的事件处理程序的绑定。您需要能够引用`removeEventListener()`的函数名。

事件对象

`Event`对象被传递到事件处理程序中，所以如果你愿意，你可以在你的脚本中访问它。`Event`对象有几个有用的属性和方法，最值得注意的是:

*   `event.clientX`、`event.clientY`:事件相对于浏览器窗口的鼠标坐标(如果是鼠标事件)。
*   `event.offsetX`、`event.offsetY`:事件相对于目标元素的鼠标坐标(如果是鼠标事件)。
*   `event.keyCode`:被按下的键的 ASCII 码(如果是键盘事件)。
*   `event.target`:一个指向事件起源的 DOM 元素的指针。
*   `event.currentTarget`:一个指针，指向事件当前冒泡(或捕获)到的 DOM 元素。例如，如果您有一个无序列表，该列表由一个包含 LI 标签的 UL 标签组成，当您单击一个 LI 标签时，click 事件将冒泡到父 UL 标签，然后到父 UL 标签，依此类推。当事件冒泡时，`currentTarget`属性将改变值以反映事件在冒泡过程中的位置。
*   `event.eventPhase`:表示事件当前所处阶段的整数代码:1 表示捕获，2 表示到达目标，3 表示冒泡。
*   `event.type`:事件的类型(“点击”、“按键”等)。).
*   `event.relatedTarget`:用在一些特定的事件中(比如 mouseout)，指向事件发起的元素(或者在 mouseout 的情况下，指向接收事件的元素)。
*   当这个方法被调用时，它阻止事件在 DOM 中进一步传播。但是，如果为此事件向此元素注册了多个事件处理程序，则任何剩余的事件处理程序仍将执行。
*   `event.stopImmediatePropagation()`:类似于`stopPropagation()`，但是当这个方法被调用时，它也将停止当前元素上任何剩余的事件处理程序的执行，并阻止任何进一步的传播。
*   `event.preventDefault()`:如果有一个默认的动作与事件相关联，调用这个方法将阻止它执行。例如，如果你注册了一个点击事件处理程序到一个锚标记，在其中调用`preventDefault()`将会阻止浏览器跟随链接。在 Internet Explorer 中，此方法不存在。取而代之的是一个布尔属性`returnValue`，当设置为 false 时，将取消默认操作。

这些属性告诉我们很多关于事件的信息，并在编写事件处理程序时给予我们很大的灵活性。举例来说，清单 3-20 提供了一个简单的营救小猫的游戏。

***清单 3-20。*** 营救小猫！

```js
<!DOCTYPE html>
<html>
  <head>
    <title>JavaScript Programmer's Reference</title>
    <style>
.basket {
  width: 300px;
  height: 300px;
  position: absolute;
  top: 100px;
  right: 100px;
  border: 3px double #000000;
  border-radius: 10px;
}
    </style>
  </head>
  <body>
    <h3>Rescue the kittens!</h3>
    <p>Click on them to put them in their basket!</p>
    <ul id="kittens">
      <li>Rowly</li>
      <li>Fred</li>
      <li>Mittens</li>
      <li>Lenore</li>
    </ul>
    <ul class="basket"></ul>
    <script>
var basket = document.querySelector(".basket"),
  kittens = document.querySelectorAll("li"),
  kittensLength = kittens.length,
  i;

for(i = 0; i < kittensLength; i++) {
  kittens[i].addEventListener("click", function(event) {
    basket.appendChild(event.target);
  }, false);
}
    </script>
  </body>
</html>
```

在本例中，我们为每只小猫注册了一个 click 事件处理程序，这样当您单击一只小猫时，它就会被神奇地转移到安全的篮子中(或者，在我们的例子中，我们只需将它附加到目标 DOM 节点，该节点会自动将它从 DOM 中的原始位置移除)。

在这个游戏中，效率有点低:我们分别为每个项目分配一个事件处理程序。我们实际上不必这样做；如果我们愿意，我们可以使用一种叫做*事件委托* 的方法来利用事件在 DOM 中冒泡的事实。

事件委托

事件处理中常见的模式是事件委托。基本上，委托事件意味着允许事件由 DOM 树中比原始目标更高的元素来处理。这可以减少您必须使用的事件处理程序的数量，从而对效率产生显著的影响。

作为一个例子，让我们使用事件委托重做我们的游戏。让我们将事件处理程序委托给包含它的元素，而不是给每只小猫应用一个单独的事件处理程序，如清单 3-21 所示。

***清单 3-21。*** 小猫营救，事件代表团版

```js
<!DOCTYPE html>
<html>
  <head>
    <title>JavaScript Programmer's Reference</title>
    <style>
.basket {
  width: 300px;
  height: 300px;
  position: absolute;
  top: 100px;
  right: 100px;
  border: 3px double #000000;
  border-radius: 10px;
}
    </style>
  </head>
  <body>
    <h3>Rescue the kittens!</h3>
    <p>Click on them to put them in their basket!</p>
    <ul id="kittens">
      <li>Rowly</li>
      <li>Fred</li>
      <li>Mittens</li>
      <li>Lenore</li>
    </ul>
    <ul class="basket"></ul>
    <script>
var basket = document.querySelector(".basket"),
  kittens = document.getElementById("kittens");

kittens.addEventListener("click", function(event) {
  basket.appendChild(event.target);
}, false);

    </script>
  </body>
</html>
```

在这个例子中，我们让包含无序列表的元素处理点击事件。现在我们只有一个事件处理程序，代码也简单多了。

手动点火事件

DOM 还允许您手动触发事件。当您在代码中手动触发事件时，它的行为与用户调度的事件完全一样。

手动触发事件包括三个步骤:

1.  创建适当类型的事件对象。
2.  适当地配置对象。DOM 提供了几种正确初始化事件对象的方法，以便它们拥有所有必需的参数。DOM 还提供了一种更简单的方法来初始化事件对象，这种方法适用于只需要最少的事件信息的情况。
3.  调度元素上的事件。

让我们详细看一下这些步骤。

即将推出新的手动赛事

HTML5 规范的最新版本提出了一种使用全局`Event`对象建模事件的新方法。在这个提议中，这个`Event`对象可以像`Object`或`Array`一样作为一个构造器，你可以用这种方式创建和配置你的事件对象。虽然这还没有被批准，但是已经在一些浏览器中实现了。关于这个即将到来的功能的详细信息，请参见 W3C DOM4 标准中的“接口客户事件”部分，网址为`https://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#interface-customevent.`

创建事件对象

要创建一个事件对象，可以使用`document.createEvent()`方法。这个方法接受一个参数，这个参数是一个字符串，表示您将要使用的 DOM 事件模块。以下是最常用的模块:

*   MouseEvents:处理鼠标交互的事件，如`click`、`mousedown`、`mousemove`等。
*   UIEvents:用于焦点事件，当元素被聚焦并接收键盘输入时发生，如在表单域或内容编辑的情况下。
*   HTMLEvents:用于面向浏览器的事件，如文档加载和卸载，以及内容选择、调整大小和滚动。
*   MutationEvents:处理 DOM 变化的事件，如`DOMNodeInserted`、`DOMAttrModified`等。
*   KeyboardEvents:处理按键的事件:`keyup`、`keydown`和`keypress`。
*   Event:这是一个通用的事件模块，可用于发送任何事件。

一旦有了适当类型的事件对象，就可以根据需要对其进行配置。

配置事件对象

DOM 提供了方便的方法来帮助您适当地配置新的事件对象。应该使用哪种方法取决于事件是哪个模块的成员。

MouseEvents 模块中的事件使用`Event.initMouseEvent(type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget)`，其中属性如下:

*   `type`:实际事件类型，如`click`、`mousedown`等。
*   `canBubble`:一个布尔值，表示事件是否应该在 DOM 中冒泡。
*   `cancelable`:一个布尔值，表示事件的默认动作是否可以使用`event.preventDefault`取消。
*   `view`:事件的元上下文，在 JavaScript 中总是全局上下文，所以总是在这里传递对`window`对象的引用。
*   `detail`:事件的具体细节。对于 MouseEvents，它是在同一位置单击鼠标的次数(因此，如果`detail` = 2，则是双击事件)。
*   `screenX`和`screenY`:相对于事件主体的 x 和 y 坐标。
*   `clientX`和`clientY`:相对于事件目标元素的 x 和 y 坐标。
*   `ctrlKey`、`altKey`、`shiftKey`、`metaKey (Mac OS X)`:布尔值，表示事件发生时这些键是否被按下。
*   `button`:表示点击了哪个按钮的数字:0 表示左键，1 表示中键(通常是现代鼠标上的鼠标滚轮)，2 表示右键。
*   `relatedTarget`:事件的相关目标(如果适用)。

UIEvents 模块的事件使用`Event.initUIEvent(type, canBubble, cancelable, view, detail)`，其中:

*   `type`:实际事件类型。
*   `canBubble`:一个布尔值，表示事件是否应该在 DOM 中冒泡。
*   `cancelable`:一个布尔值，表示事件的默认动作是否可以使用`event.preventDefault`取消。
*   `view`:事件的元上下文，在 JavaScript 中总是全局上下文，所以总是在这里传递对`window`对象的引用。
*   `detail`:事件的具体细节。对于 UIEvents，通常是鼠标被点击的次数作为事件的一部分，所以通常设置为 1。

HTMLEvents 模块的事件使用`Event.initEvent(type, canBubble, cancelable)`，其中:

*   `type`:实际事件类型。
*   `canBubble`:一个布尔值，表示事件是否应该在 DOM 中冒泡。
*   `cancelable`:一个布尔值，表示事件的默认动作是否可以使用`event.preventDefault`取消。

MutationEvents 模块的事件使用`Event.initMutationEvent(type, canBubble, cancelable, relatedTarget, previousValue, newValue, attributeName, attributeChange)`，其中:

*   `type`:实际事件类型。
*   `canBubble`:一个布尔值，表示事件是否应该在 DOM 中冒泡。
*   `cancelable`:一个布尔值，表示事件的默认动作是否可以使用`event.preventDefault`取消。
*   `relatedTarget`:事件的相关目标(如果适用)。
*   `previousValue`:修改节点的前一个值。
*   `newValue`:修改节点的新值。
*   `attributeName`:被修改属性的名称。
*   `attributeChange`:表示属性如何改变的整数:1 =修改，2 =添加，3 =删除。

当初始化 KeyboardEvents 事件时，使用`Event.initKeyboardEvent(type, canBubble, cancelable, view, ctrlKey, altKey, shiftKey, metaKey, keyCode, charCode)`，其中:

*   `type`:实际事件类型。
*   `canBubble`:一个布尔值，表示事件是否应该在 DOM 中冒泡。
*   `cancelable`:一个布尔值，表示事件的默认动作是否可以使用`event.preventDefault`取消。
*   `view`:事件的元上下文，在 JavaScript 中总是全局上下文，所以总是在这里传递对`window`对象的引用。
*   `ctrlKey`、`altKey`、`shiftKey`、`metaKey (Mac OS X)`:布尔值，表示按下这些键时是否发生了虚拟按键。
*   `keyCode`:密钥的 ASCII 码。
*   `charCode`:密钥的 Unicode 字符。

注意，这里的非标准浏览器是 Firefox，它调用方法`initKeyEvent()`。最初，`KeybordEvent`模块是在 DOM Level 2 规范的早期版本中定义的，但是它从该规范中被删除了。

扩展事件对象

如果您愿意，可以随意扩展这些事件对象。它们是对象，就像 JavaScript 中的任何其他对象一样，所以您可以向它们添加自己的属性和方法。我们最喜欢的技术之一是为事件提供一个`appDetail`属性，它包含了关于事件的有用信息以及事件被触发的原因。这也便于确定哪些事件是手动触发的，哪些事件是由用户直接触发的。它也可以很好地处理自定义事件(在本章的后面会有描述)。

现在您已经有了一个配置好的事件，您只需要分派它。

调度事件

分派您的事件非常简单。如清单 3-22 所示，你在目标元素上调用`dispatchEvent()`方法。

***清单 3-22。*** 击发自定义事件

```js
<!DOCTYPE html>
<html>
  <head>
    <title>JavaScript Programmer's Reference</title>
  </head>
  <body>
    <p id="clickme">Click me to see an alert!</p>
    <script>
var myPar = document.getElementById("clickme");
myPar.addEventListener("click", function(event) {
  alert('This is your alert!');
}, false);

// Create and dispatch a new click event
var myClickEvent = document.createEvent("MouseEvents");
myClickEvent.initMouseEvent("click", true, true, window, 0, 0, 0, 0, false, false, false, false, 1, null);
myPar.dispatchEvent(myClickEvent);
    </script>
  </body>
</html>
```

在这个例子中，我们手动触发一个点击事件，这样当你加载这个页面时，你会立即看到一个警告，就像你点击了这个段落一样。您可以单击该段落再次查看该警告。

在清单 3-22 中，我们实际上并不需要所有这些参数——我们将坐标设置为 0(尽管这一点都不准确)，我们并不关心 Cntrl、Shift 或 meta 键等等。如果不需要所有这些属性，可以使用由通用事件模块生成的更简单的事件对象。例如，清单 3-23 ，它自动化了我们的小猫营救游戏——因为没有什么比制作一个自我终结的游戏更有趣了。

***清单 3-23。*** 自动化小猫救助

```js
<!DOCTYPE html>
<html>
  <head>
    <title>JavaScript Programmer's Reference</title>
    <style>
.basket {
  width: 300px;
  height: 300px;
  position: absolute;
  top: 100px;
  right: 100px;
  border: 3px double #000000;
  border-radius: 10px;
}
    </style>
  </head>
  <body>
    <h3>Rescue the kittens!</h3>
    <p>Click on them to put them in their basket!</p>
    <ul id="kittens">
      <li>Rowly</li>
      <li>Fred</li>
      <li>Mittens</li>
      <li>Lenore</li>
    </ul>
    <ul class="basket"></ul>
    <script>
var basket = document.querySelector(".basket"),
  kittens = document.getElementById("kittens");

kittens.addEventListener("click", function(event) {
  basket.appendChild(event.target);
}, false);

// Make JavaScript rescue the kittens!
var allKittens = document.querySelectorAll("#kittens li"),
  allKittensLength = allKittens.length,
  i,
  clickKittenEvent = document.createEvent("Event");

clickKittenEvent.initEvent("click", true, true);

for (i = 0; i < allKittensLength; i++) {
  allKittens[i].dispatchEvent(clickKittenEvent);
}
    </script>
  </body>
</html>
```

在清单 3-23 中，我们遍历每只小猫，并对它们触发一个最小配置的点击事件，这是我们使用通用事件模块创建的。这提供了一种快速触发事件的方法，如果你需要的话。

但是，请注意，有些事件需要更复杂的事件对象。键盘事件似乎对此特别敏感。您可能需要进行实验，找出您可以使用的内容。

自定义事件

您可以使用 DOM 事件模型来调度您想要的任何类型的事件！是的，你没看错:你不局限于点击和按键。如果你想定义你自己的事件，你可以这样做。当您使用`addEventListener()`方法附加事件处理程序时，只需指定您的事件类型，然后使用通用事件模块创建并触发您自己的事件。

想想我们的小猫拯救游戏。想象一下，我们不是监听点击事件，而是监听“营救”事件，如清单 3-24 中的所示。然后，我们可以手动生成救援事件，并救援所有的小猫。

***清单 3-24。*** 定制事件救援

```js
<!DOCTYPE html>
<html>
  <head>
    <title>JavaScript Programmer's Reference</title>
    <style>
.basket {
  width: 300px;
  height: 300px;
  position: absolute;
  top: 100px;
  right: 100px;
  border: 3px double #000000;
  border-radius: 10px;
}
    </style>
  </head>
  <body>
    <h3>Rescue the kittens!</h3>
    <p>Click on them to put them in their basket!</p>
    <ul id="kittens">
      <li>Rowly</li>
      <li>Fred</li>
      <li>Mittens</li>
      <li>Lenore</li>
    </ul>
    <ul class="basket"></ul>
    <script>
var basket = document.querySelector(".basket"),
  kittens = document.getElementById("kittens");

kittens.addEventListener("rescue", function(event) {
  basket.appendChild(event.target);
}, false);

// Make JavaScript rescue the kittens!
var allKittens = document.querySelectorAll("#kittens li"),
  allKittensLength = allKittens.length,
  i,
  clickKittenEvent = document.createEvent("Event");

clickKittenEvent.initEvent("rescue", true, true);

for (i = 0; i < allKittensLength; i++) {
  allKittens[i].dispatchEvent(clickKittenEvent);
}
    </script>
  </body>
</html>
```

在本例中，我们只需将 click 事件处理程序更改为 rescue 事件处理程序，然后我们只需创建一个 rescue 事件并从每只小猫中调度它，就像我们对 click 事件所做的那样。

创建自定义事件是一项强大的技术，它允许您在代码中创建解耦的组件。每个组件只需要在事情发生时发布事件，然后其他组件可以监听这些事件，也可以不监听。这样，所有的组件都是完全解耦的:组件 A、B 和 C 不需要知道彼此的任何事情，甚至不需要知道它们是否存在，但是它们仍然可以使用事件相互通信。

跨浏览器策略

正如我们在本节开始时提到的，直到版本 9，Internet Explorer 几乎忽略了 DOM 事件的标准。最值得注意的是，Internet Explorer 使用了方法`attachEvent()`和`removeEvent()`，而不是`addEventListener()`和`removeEventListener()`。此外，Internet Explorer 没有为正在执行的事件处理程序设置适当的上下文；IE 没有将其设置为注册处理程序的元素，而是将其设置为`window`对象。IE 也不支持事件的捕获阶段。最后，IE 不会将一个`Event`对象传递给它的事件处理程序；相反，它把它附加到`window`对象上。

幸运的是，使用一点 JavaScript 就可以很容易地解决这些问题。缺少捕获阶段是很难克服的，但是捕获阶段没有被广泛使用，所以如果我们关注注册方法和上下文问题，我们可以提出一个相当简单的解决方案。

我们要做的是创建两个新的函数来注册我们的事件:`addEventHandler()`和`removeEventHandler()`，如清单 3-25 所示。如果我们在一个支持 DOM 标准的浏览器中工作，我们只需将我们的函数别名化为 DOM 函数，然后就这样了。但是，如果我们在 IE 中，我们需要做更多的工作来解决我们的上下文问题。

***清单 3-25。*** 创建跨浏览器事件绑定方法

```js
if (document.addEventListener) {
  // DOM events available, so just use them.
  window.addEventHandler = function(targetEl, eventType, handler) {
    targetEl.addEventListener(eventType, handler, false);
    return handler;
  };
  window.removeEventHandler = function(targetEl, eventType, handler) {
    targetEl.removeEventListener(eventType, handler, false);
  }
} else {
  // Internet Explorer. Fix context problems as well as create alias.
  window.addEventHandler = function(targetEl, eventType, handler) {
    var fixContext = function() {
      return handler.apply(targetEl, arguments);
    };
    targetEl.attachEvent("on" + eventType, fixContext);
    return fixContext;
  }

  window.removeEventHandler = function(targetEl, eventType, handler) {
    targetEl.detachEvent("on" + eventType, handler);
  }
}
```

在这个例子中，我们向全局上下文添加了两个新方法:`addEventHandler()`和`removeEventHandler()`。在 IE 中，对于`addEventHandler()`，我们通过创建一个名为`fixContext()`的虚拟函数并将其绑定为事件处理程序来解决上下文问题。当事件调用`fixContext()`时，它使用`apply()`方法手动调用处理程序，这使我们能够强制目标元素成为执行上下文。

我们还提到，Internet Explorer 不会将一个`Event`对象作为参数传递给它的事件处理程序。也有一个简单的方法，如清单 3-26 所示:在事件处理程序中，只需检查是否有事件传入，如果没有，就从`window`对象中取出它(这是 IE 放置它的地方)。

***清单 3-26。*** 修复其他 IE 问题

```js
function clickHandler(event) {
  if(!event) {
    event = window.event;
  }
  // continue...
}
```

解决缺少捕获阶段的问题更加困难，但是这些修复解决了最糟糕的问题。如果您发现您需要一个更健壮的解决方案，许多 JavaScript 库可以很好地处理这个问题。特别是 jQuery 修复了所有问题，并为事件模型提供了许多有用的扩展。

摘要

在这一章中，我们介绍了浏览器中的一个重要特性，DOM，它为 JavaScript 提供了一个访问和操作已经加载到浏览器中的文档的接口。以下是本章的重点:

*   DOM 是一个独立的标准；它不受 JavaScript 标准的控制。
*   随着时间的推移，DOM 不断发展，浏览器合规性是一个持续的过程。
*   DOM 的结构就像一棵树，HTML 文档中的所有内容都用树来表示。
*   可以使用父/子/兄弟关系和方便的方法来遍历 DOM。
*   DOM 中的节点可以使用像`getElementById()`和`querySelector()`这样的方法直接访问。
*   DOM 提供了几个操作其成员的重要方法，包括改变其属性和内容的方法。
*   DOM 允许您根据需要创建节点，并像处理文档一样处理它们。
*   DOM 拥有丰富灵活的事件模型。。。哪个 Internet Explorer 不遵循。
*   事件处理程序可以添加到任何元素中，也可以很容易地删除。
*   事件处理可以委托给 DOM 中更高层的元素，因为事件通过 DOM 结构向上冒泡，最终到达 body 标记。
*   可以手动触发事件。
*   您可以创建自定义事件。

这一章标志着讨论章节的结束。在第四章中，我们将在一些实际项目中应用前三章中所涉及的所有内容。