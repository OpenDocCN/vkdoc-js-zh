# 一、面向对象的 JavaScript

如果你开发网站已经有一段时间了，你可能会听到其他程序员说 JavaScript 不是面向对象的编程语言，结果经常在同一句话中否定这种语言。作为 JavaScript 开发人员，我们有责任互相教育，教育任何对 JavaScript 语言持反对意见的人，因为它确实是一种面向对象的语言，而且是一种非常强大的语言。

实际上，当其他程序员放弃 JavaScript 时，他们经常贬低它，因为它不符合传统语言(如 C++、Java、PHP 和 Objective-C)的所有相同结构和约定。在我看来，这并不一定是负面的，因为 JavaScript 如果以正确的方式编写，实际上可以提供更大的灵活性，因为它没有强加这样一种僵化的结构。

在这一章中，我将解释如何利用 JavaScript 的能力，使用其他语言所采用的面向对象编程原则来编写代码，重点是通过 JavaScript 使之更加灵活的方法。我还将介绍该语言本身包含的一些内置对象，以及其中一些鲜为人知的方面。

Note

经典编程语言是一种通过称为类的蓝图或模板来定义和创建对象的语言，因此得名。

## JavaScript 中的对象

JavaScript 中的对象是一个独立的实体，由一个或多个相关的变量和函数组成，分别称为属性和方法。对象用于将相关的概念或功能组合在一起，通常是与现实世界或特定软件行为相关的东西。它们让开发人员更容易理解代码，最终也让代码更容易阅读和编写。

### 自定义对象

创建 JavaScript 代码中使用的对象的最简单方法是在定义变量时使用对象文字符号，用花括号表示。然后，可以使用清单 1-1 所示的格式，通过将属性和方法的名称和值封装在大括号中，将它们附加到对象上。这里我们创建一个新对象来表示一所房子，它有两个属性和两个方法。创建后，我们可以通过点符号在对象中读写属性和方法，其中对象名称由带有点(`.`)字符的属性或方法名称分隔。

清单 1-1。使用对象文字表示法创建对象

`var house = {`

`rooms: 7,`

`sharedEntrance: false,`

`lock: function() {},`

`unlock: function() {}`

`};`

`// Read out the values of the two properties`

`alert(house.rooms); // 7`

`alert(house.sharedEntrance); // false`

`// Execute the 'lock' method of the object`

`house.lock();`

`// Update the value for the 'rooms' property`

`house.rooms = 8;`

`// Add a completely new property dynamically`

`house.floors = 2;`

`// Read out the 'rooms' property again – notice it has now changed`

`alert(house.rooms); // 8`

假设我们想要表示另一种类型的财产，一套公寓。它类似于一栋房子，但通常房间较少，分布在一层，可能有一个通往街道的共用入口。让我们在一个新变量中将它表示为一个对象文字:

`var apartment = {`

`floors: 1,`

`rooms: 4,`

`sharedEntrance: true,`

`lock: function() {},`

`unlock: function() {}`

`};`

从概念上讲，公寓就像房子，但有不同的属性。如果我们选择以同样的方式表示更多类型的住宿，我们很快就会陷入这样的境地:改变我们想要在所有这些对象之间共享的属性的名称，或者为它们添加一个新的属性或方法，都会很困难或令人沮丧。理想情况下，我们会希望创建一个模板或蓝图来表示我们的对象的属性和方法，这样，如果我们想要更改属性名或添加新方法，我们就可以轻松地完成。JavaScript 允许我们通过构造函数创建这种对象模板，在其他经典语言中，构造函数通常被称为类。

### 班级

类是创建共享一组属性和方法的类似对象的模板或蓝图。像 Java 和 Objective-C 这样的编程语言允许开发者通过特定的关键字和结构来定义类。在 JavaScript 中，定义一个简单的函数会创建一些与类相同的行为。它与其他任何函数的不同之处不在于它是如何定义的，而在于如何从它创建对象。

Note

JavaScript 语言中一直有一个保留字叫做`class`，这意味着你不能用这个名字创建你自己的变量。它实际上从未在语言中被使用过；这个名字只是留作后用。看来这个关键字可能最终会在该语言的下一个版本中得到一些使用，该版本被称为 ECMAScript 6，目前正在起草中。

让我们创建一个构造函数，我们将使用它作为房子和公寓对象的蓝图。稍后我们将添加属性和方法。

`function Accommodation() {};`

这看起来和我们用 JavaScript 创建的其他函数没有什么不同。使用它作为模板创建对象涉及到使用关键字`new`，然后执行函数。

`var house = new Accommodation();`

`var apartment = new Accommodation();`

使用`new`关键字创建的任何对象都被认为是由函数表示的结构的对象实例，本质上它是作为这个模板或蓝图的实例创建的。以这种方式创建的每个对象实例不连接到从同一模板创建的任何其他实例；它们被视为完全独立的变量，只是共享相同的蓝图结构。尽管模板结构类似于经典编程语言中的一个类，但它并不完全相同。

我们将在本章后面更仔细地看一下构造函数 t。

#### 检测对象的构造函数

以这种方式从模板创建的任何对象文字都有一个额外的属性，称为`constructor`，它指向用来创建它的 JavaScript 构造函数。有了这些知识，您就可以通过直接比较`constructor`和构造函数来检查您的应用中是否有任何对象文字与您的某个构造函数匹配。

`house.constructor === Accommodation;     // true`

`apartment.constructor === Accommodation; // true`

您可以使用`instanceof`关键字执行类似的比较，它将一个对象文字与用于创建它的构造函数进行比较。

`house instanceof Accommodation;     // true`

`apartment instanceof Accommodation; // true`

事实上，因为`constructor`属性直接映射到用于创建实例的函数，所以理论上可以直接使用这个属性和`new`关键字创建新的实例。这是一种不常见的用法，但仍然值得注意。

`var apartment = new house.constructor();`

`apartment instanceof Accommodation; // true`

因为我们用一个空函数定义了我们的“类”,所以它没有任何我们想要用作每个对象实例的模板的属性和方法。有两种方式将属性和方法分配给一个“类”，通过它的原型和通过它的作用域。现在，让我们依次看一看每一个。

#### 使用原型分配属性和方法

在 JavaScript 中创建的每个函数以及每个构造函数都有一个`prototype`属性。这是一个包含属性和方法的对象，这些属性和方法与使用`new`关键字从“类”创建的任何对象实例相关联。我们可以在这个`prototype`对象上使用点符号，将我们自己的属性和方法添加到所有关联的对象实例中。我们指定的每一个属性，我们给它一个默认值，这样就不会有未定义的值。清单 1-2 显示了我们如何使用`prototype`关键字定义模板的属性和方法，或者“类”。

清单 1-2。使用 prototype 关键字和点标记法将属性和方法分配给构造函数

`// Define a constructor called Accommodation`

`function Accommodation() {}`

`// Assign properties to our "class" blueprint`

`Accommodation.prototype.floors = 0;`

`Accommodation.prototype.rooms = 0;`

`Accommodation.prototype.sharedEntrance = false;`

`// Assign methods to our "class" blueprint`

`Accommodation.prototype.lock = function() {};`

`Accommodation.prototype.unlock = function() {};`

`// Create object instances from our Accommodation "class"`

`var house = new Accommodation();`

`var apartment = new Accommodation();`

`// Read properties from object instances`

`alert(house.floors); // 0`

`alert(house.sharedEntrance); // false`

`// Write properties to object instances to set the correct values`

`house.floors = 2;`

`accommodation.sharedEntrance = true;`

`// Execute methods on object instances`

`house.unlock();`

`apartment.lock();`

因为原型是与我们用作“类”的函数相关联的对象属性，所以我们也可以使用对象文字符号而不是点符号。清单 1-3 显示了我们将如何做。

清单 1-3。使用对象文本向构造函数分配属性和方法

`// Define a constructor called Accommodation`

`function Accommodation() {}`

`// Assign properties and methods to our "class" blueprint with an object literal`

`Accommodation.prototype = {`

`floors: 0,`

`rooms: 0,`

`sharedEntrance: false,`

`lock: function() {},`

`unlock: function() {}`

`};`

`// Create object instances from our Accommodation "class"`

`var house = new Accommodation();`

`var apartment = new Accommodation();`

`// Read properties from object instances`

`alert(house.floors); // 0`

`alert(house.sharedEntrance); // false`

`// Write properties to object instances to set the correct values`

`house.floors = 2;`

`accommodation.sharedEntrance = true;`

`// Execute methods on object instances`

`house.unlock();`

`apartment.lock();`

关键字`prototype`的一个强大特性是，你可以向它添加属性和方法，甚至在对象实例被创建之后，那些新的属性和方法会自动添加到所有对象实例中，包括之前和之后创建的，如清单 1-4 所示。

清单 1-4。向预先存在的对象实例动态添加属性和方法

`// Define a constructor called Accommodation`

`function Accommodation() {};`

`// Assign properties and methods to our "class" blueprint with an object literal`

`Accommodation.prototype = {`

`floors: 0,`

`rooms: 0,`

`sharedEntrance: false,`

`lock: function() {},`

`unlock: function() {}`

`};`

`// Create an object instance`

`var house = new Accommodation();`

`// Dynamically add a new method to the "class" prototype`

`Accommodation.prototype.alarm = function() {};`

`// The existing object` `instance gains the new method automatically`

`house.alarm();`

#### 使用范围分配属性和方法

在函数中定义的任何变量或函数都限定在该函数的范围内，这意味着不能在该函数之外访问它——对于在函数中声明的变量和方法，函数就像沙盒开发环境或闭包。这对开发人员来说很好，因为这意味着一个函数中声明的变量不会影响另一个函数中的变量；相同的变量名甚至可以在不同的函数中使用而不会发生冲突。

在任何其他函数之外声明变量或函数，直接在 JavaScript 或 HTML 文件中声明，将该变量或函数置于全局范围内，这意味着它可以在代码中的任何地方使用，甚至在另一个函数中。事实上，由于作用域的原因，任何类型的嵌套函数都可以访问其父函数中声明的变量。清单 1-5 展示了这个原则。

清单 1-5。可变范围

`// Variable declared outside of any function is in global scope and available to access anywhere`

`var myLibrary = {`

`myName: "Dennis"`

`};`

`function doSomething() {`

`// Variable declared within a function is not accessible outside that function`

`var innerVariable = 123;`

`// The global variable is accessible from within the function`

`myLibrary.myName = "Hello";`

`function doSomethingElse() {`

`// Variables declared in a surrounding scope are accessible`

`innerVariable = 1234;`

`}`

`doSomethingElse();`

`alert(innerVariable); // 1234`

`}`

`doSomething();`

`// This property was overridden within the doSomething function`

`alert(myLibrary.myName); // "Hello"`

`// Trying to access a variable declared within a function` `from outside results in an error`

`alert(innerVariable); // ERROR!`

#### 上下文和`this`关键字

JavaScript 保留关键字`this`用于表示函数的上下文，在大多数情况下，它表示运行时封装函数的对象。当在一个对象之外使用时，它采用全局`window`对象。在一个对象的方法中使用`this`引用周围的对象，在本例中是`house`对象。美妙之处在于，通过引用`this`而不是对象的变量名，您可以随时轻松地更改变量名，而不会影响它所包含的方法的行为。因为`this`关键字变成了包围它所在函数的对象的同义词，所以可以在关键字本身上使用点符号，就像在对象上一样。清单 1-6 中的代码演示了上下文和`this`关键字。

清单 1-6。对 this 关键字使用点标记法

`// Outside of any function, 'this' represents the global 'window' object`

`alert(this === window); // true`

`// Because the doSomething function is called outside of an object, the keyword this adopts`

`// the global JavaScript window object in the browser.`

`function doSomething() {`

`alert(this === window); // true`

`}`

`doSomething();`

`var house = {`

`floors: 2,`

`isLocked: false,`

`lock: function() {`

`alert(this === house); // true, as the this keyword represents the object containing this method`

`// We can treat 'this' as equivalent to the 'house' object, including using dot notation`

`this.isLocked = true;`

`}`

`};`

`house.lock();`

`alert(house.isLocked); // true`

一个对象中的嵌套函数采用全局`window`对象，而不是周围的对象，这可能不是您所期望的行为，并且让许多人感到困惑。通过创建一个变量来存储包含周围对象的关键字`this`的值，然后使用该变量代替周围对象的名称，就可以解决这个问题。许多开发人员选择使用一个名为`that`的变量来存储对象的引用，如清单 1-7 所示。

清单 1-7。将 this 关键字的值存储到变量中

`var apartment = {`

`isLocked: false,`

`lock: function() {`

`var that = this;`

`// Set the isLocked property`

`this.isLocked = true;`

`function doSomething() {`

`alert(this === apartment); // false`

`alert(this === window); // true`

`alert(that === apartment); // true`

`// Overwrite the isLocked property of the object,`

`// accessing it through the stored variable`

`that.isLocked = false;`

`}`

`doSomething();`

`}`

`};`

`apartment.lock();`

`alert(apartment.isLocked); // false`

当与`new`关键字一起使用时，`this`关键字具有不同的值。在这种情况下，它指的是从构造函数创建的对象实例。因此，我们可以利用这种行为来设置所有对象实例的构造属性和方法，而不是使用`prototype`关键字，如清单 1-8 所示。

清单 1-8。在构造函数中使用 this 关键字

`// Define a new constructor to represent a type of accommodation`

`function Accommodation() {`

`// The 'this' keyword refers to the individual object instance created from this "class"`

`this.floors = 0;`

`this.rooms = 0;`

`this.sharedEntrance = false;`

`this.isLocked = false;`

`this.lock = function() {`

`// Using this within a function refers to its surrounding object, which in this`

`// case refers to the object instance, since it's that which calls the method`

`this.isLocked = true;`

`};`

`this.unlock = function() {`

`this.isLocked = false;`

`};`

`}`

`// Create object instances from the constructor`

`var house = new Accommodation();`

`var apartment = new Accommodation();`

`// Read and write properties and execute methods as normal with these object instances`

`alert(house.floors); // 0`

`house.floors = 2;`

`apartment.lock();`

JavaScript 开发人员为他们的对象实例声明属性和方法的最常见方式是结合使用`prototype`关键字和`this`关键字，前者用于方法，后者用于属性。每次从构造函数创建一个新的对象实例时，都会执行构造函数。这种组合方法用于避免每次实例化对象时都需要执行代码来初始化方法。通过在`prototype`关键字上定义方法，它们只被定义一次，并且可用于从该构造函数创建的每个对象，这使得对象创建更加有效。分配给`prototype`的方法可以引用`this`来获得对实例化对象的引用，如清单 1-9 所示。

清单 1-9。使用 this 和 prototype 关键字的组合来创建有效的构造函数

`// Create a constructor function to represent types of accommodation`

`function Accommodation() {`

`// Use the this keyword to set properties on the instantiated object`

`this.floors = 0;`

`this.isLocked = false;`

`}`

`// Define methods for instantiated objects using the prototype keyword`

`Accommodation.prototype.lock = function() {`

`// Methods can refer to the this keyword to reach those properties created`

`// in the constructor function`

`this.isLocked = true;`

`};`

`Accommodation.prototype.unlock = function() {`

`this.isLocked = false;`

`};`

`// Instantiate an object of the Accommodation type`

`var house = new Accommodation();`

`// Execute the 'lock' method`

`house.lock();`

`// Check that the 'isLocked' property` `was set as expected`

`alert(house.isLocked); // true`

开发人员更喜欢在构造函数中使用`this`设置属性的另一个原因是，它允许在执行时根据传递给构造函数的值来初始化某些属性。我个人更喜欢对那些我可能希望在创建时初始化的属性使用`this`关键字，并使用 prototype 和我的方法来设置其他属性。这样，构造函数就清除了在对象实例化时实际上不需要执行的任何代码，从而提高了代码的效率，如清单 1-10 所示。

清单 1-10。在构造函数中使用 this 关键字初始化属性

`// Define a constructor function with three parameters representing values to initialize`

`// properties of the instantiated object with`

`function Accommodation(floors, rooms, sharedEntrance) {`

`// Initialize three properties with values passed in when an object is instantiated`

`// from this "class". The Logical OR operation - || - allows a default value to be specified`

`// in case no value is passed in`

`this.floors = floors || 0;`

`this.rooms = rooms || 0;`

`this.sharedEntrance = sharedEntrance || false;`

`}`

`// Properties that don't need values set at instantiation time should be set with prototype`

`// as these are then defined and executed only once.`

`Accommodation.prototype.isLocked = false;`

`Accommodation.prototype.lock = function() {`

`this.isLocked = true;`

`};`

`Accommodation.prototype.unlock = function() {`

`this.isLocked = false;`

`};`

`// Instantiate an object from the "class", passing in two out of the possible three values`

`// for initialization. Arguments are passed in the order defined on the constructor function`

`var house = new Accommodation(2, 7);`

`alert(house.floors); // 2`

`alert(house.rooms); // 7`

`// A value for sharedEntrance wasn't passed into the constructor function, so its value`

`// defaults to false because of the Logical OR operation` `in the constructor function – see above`

`alert(house.sharedEntrance); // false`

随着“类”的增长，您可能会发现需要向构造函数传递一些参数，以便在对象实例中设置属性的初始值。虽然依次列出每个参数对于少量的函数输入很好，但是一旦参数的数量超过三个或四个，它很快就会变得笨拙和混乱。幸运的是，有一个对象文字形式的解决方案。通过将单个参数传递给构造函数，该函数由包含所有初始值的对象文字组成，以设置属性，我们不仅消除了多个函数参数的混淆，还提高了对代码的理解，因为对象文字描述的是名称-值对，而不是未命名的函数输入。这是我向任何需要两个或三个以上输入的函数传递参数的首选方式；您可以在清单 1-11 中看到这一点。

清单 1-11。使用对象文本作为构造函数的输入

`function Accommodation(defaults) {`

`// If no argument is passed, default to an empty object literal`

`defaults = defaults || {};`

`// If the defaults object contains a named property, set the property of the`

`// same name in the object instance to the supplied value, otherwise resort to a default`

`this.floors = defaults.floors || 0;`

`this.rooms = defaults.rooms || 0;`

`this.sharedEntrance = defaults.sharedEntrance || false;`

`}`

`Accommodation.prototype.isLocked = false;`

`Accomodation.prototype.lock = function() {`

`this.isLocked = true;`

`};`

`Accommodation.prototype.unlock = function() {`

`this.isLocked = false;`

`};`

`// Instantiate two objects from the Accommodation "class", passing in named arguments`

`// through an object literal`

`var house = new Accommodation({`

`floors: 2,`

`rooms: 7`

`});`

`var apartment` `= new Accommodation({`

`floors: 1,`

`rooms: 4,`

`sharedEntrance: true`

`});`

#### 链接方法

我们已经定义了被我们的对象实例采用的方法，这些方法像任何函数一样被执行，方法名后面有左括号和右括号。为了在我们的对象实例上连续执行许多方法，我们目前需要在新的一行上依次执行每一个方法，每次指定对象文字的名称。

`house.lock();`

`house.alarm();`

`house.unlock();`

通过对每个方法做一点小小的改变，我们可以允许方法链接，这意味着一个方法调用可以直接跟随另一个方法调用。如果您使用过 jQuery 库( [`http://bit.ly/jquerycom`](http://bit.ly/jquerycom) )，您可能会看到类似的行为，它允许这种相同类型的方法链接。

`house.lock().alarm().unlock();`

我们通过在“类”中每个方法末尾的关键字`this`简单地返回一个对对象实例的引用来做到这一点，如清单 1-12 所示，这返回了准备再次立即使用的对象实例。

清单 1-12。使用 this 关键字链接方法调用

`function Accommodation() {}`

`Accommodation.prototype.isLocked = false;`

`Accommodation.prototype.lock = function() {`

`this.isLocked = true;`

`// By returning the context, we are in fact returning an instance of the object instance`

`// which called this function. Since that object contains all the methods, we're able to`

`// call the other methods immediately after calling this one`

`return this;`

`};`

`Accommodation.prototype.unlock = function() {`

`this.isLocked = false;`

`return this;`

`};`

`Accommodation.prototype.alarm = function() {`

`alert("Sounding alarm!");`

`return this;`

`};`

`// Create an object instance`

`var house = new Accommodation();`

`// Because each method returns its context` `, which in this case is the object instance, we can`

`// chain method calls one after another`

`house.lock().alarm().unlock();`

#### 遗产

经典编程语言的一个关键方面是创建新类的能力，这些新类继承或扩展了与它们共享相似逻辑连接的父类的属性和方法。这些被称为子类或子类。这种相同类型的继承在 JavaScript 中也是可能的，尽管与经典语言的方式不尽相同。这里称为原型继承，它利用了 JavaScript 对象的所谓的`prototype`链，如清单 1-13 所示。

清单 1-13。使用原型继承创建子类

`// Define a "class" with two methods`

`function Accommodation() {}`

`Accommodation.prototype.lock = function() {};`

`Accommodation.prototype.unlock = function() {};`

`// Define a constructor function for what will become our subclass`

`function House(defaults) {`

`defaults = defaults || {};`

`// Initialize the floors property to '2' for all instances of this "class"`

`this.floors = 2;`

`// If a 'rooms' property is passed within an object literal to this constructor, use its`

`// value, otherwise default to 7 rooms`

`this.rooms = defaults.rooms || 7;`

`}`

`// Map an instance of the Accommodation "class" to the prototype of the House "class".`

`// This executes the constructor function for Accommodation with the 'new' keyword, which`

`// creates and returns an object containing all its properties and methods. This is passed into`

`// the prototype of the House "class", making that "class" inherit everything from Accommodation`

`House.prototype = new Accommodation();`

`// The 'constructor' property of an object instance points to the constructor function that`

`// created it. However, by mapping everything from Accommodation to House, we also copied over`

`// the 'constructor' value, which we now need to reset to point to the new subclass instead.`

`// If we miss this step, object literals created from the House "class" will report that they`

`// were created from the Accommodation "class" instead.`

`House.prototype.constructor = House;`

`// Create an instance of a House, inheriting properties` `and methods from Accommodation, also`

`var myHouse = new House();`

`// Pass in a value for 'rooms' to set that value at the point of object instantiation`

`var myNeighborsHouse = new House({`

`rooms: 8`

`});`

`alert(myHouse.rooms); // 7 (the default value set in the House constructor function)`

`alert(myNeighborsHouse.rooms); // 8`

`// Methods that were set on Accommodation are also available to objects created from House`

`myHouse.lock();`

`myNeighborsHouse.unlock();`

`// Objects created from House report that fact, thanks to us fixing the 'constructor'`

`// property earlier`

`alert(myHouse.constructor === House); // true`

`alert(myHouse.constructor === Accommodation); // false, since we pointed the constructor to House`

`// The instanceof keyword looks up the prototype chain, so can also be used to check if an`

`// object instance is derived from a particular parent "class"`

`alert(myNeighborsHouse instanceof House); // true`

`alert(myNeighborsHouse instanceof Accommodation); // true, since House inherits Accommodation`

我们使用了`prototype`关键字将方法和属性添加到构造函数中，然后这些方法和属性将可用于从该构造函数创建的对象实例。如果我们试图引用对象上的一个方法或属性，而这个方法或属性在构造函数的原型上并不存在，JavaScript 不会立即引发错误，而是会首先检查是否有同名的方法或属性存在于当前构造函数所继承的父构造函数上。

Caution

当创建一个子类时，确保将它的`constructor`属性指向它自己的构造函数，因为默认情况下这将指向父类的构造函数，直接从它的原型复制。

注意到`instanceof`关键字跟在原型链后面，这意味着它可以识别特定的对象实例是从特定的构造函数创建的，还是从继承该构造函数的任何构造函数创建的。原型链一直延伸到 JavaScript 中内置的`Object`类型，因为语言中的每个变量最终都是从这个类型继承而来的。

`alert(myHouse instanceof House); // true`

`alert(myHouse instanceof Accommodation); // true, since House inherits Accommodation`

`alert(myHouse instanceof Object); // true, since objects are inherited from JavaScript's`

`// built-in Object type`

##### 包装

当使用继承创建现有类的变体或专门化时，父“类”的所有属性和方法对子“类”都是可用的。您不需要在子类中声明或定义任何额外的东西就可以使用父类的属性和方法。这种能力被称为封装；子类只需要包含父类属性和方法之外的属性和方法的定义。

##### 多态性

当继承和扩展一个“类”以形成一个新的子类时，您可能会发现您需要用另一个同名的方法来替换一个方法，以执行类似的目的，但是要对该子类进行特定的修改。这就是所谓的多态性，在 JavaScript 中只要重写函数并给它一个与原始方法相同的名字就可以实现，如清单 1-14 所示。

清单 1-14。多态性

`// Define our parent Accommodation "class"`

`function Accommodation() {`

`this.isLocked = false;`

`this.isAlarmed = false;`

`}`

`// Add methods for common actions to all types of accommodation`

`Accommodation.prototype.lock = function() {`

`this.isLocked = true;`

`};`

`Accommodation.prototype.unlock = function() {`

`this.isLocked = false;`

`};`

`Accommodation.prototype.alarm = function() {`

`this.isAlarmed = true;`

`alert("Alarm activated");`

`};`

`Accommodation.prototype.deactivateAlarm = function() {`

`this.isAlarmed = false;`

`alert("Alarm deactivated");`

`};`

`// Define a subclass for House`

`function House() {}`

`// Inherit from Accommodation`

`House.prototype = new Accommodation();`

`// Redefine the 'lock' method specifically for the House "class" - known as Polymorphism`

`House.prototype.lock = function() {`

`// Execute the 'lock' method from the parent Accommodation "class". We can access this`

`// directly through the prototype property of the "class" definition. We pass our context`

`// to the function using the 'call' method of the function, ensuring that any references to`

`// 'this' within the 'lock' method refer to the current object instance of House`

`Accommodation.prototype.lock.call(this);`

`alert(this.isLocked); // true, showing that the call to the lock method above worked as expected`

`// Call the alarm method, inherited from Accommodation`

`this.alarm();`

`};`

`// Redefine the 'unlock' method in the same way`

`House.prototype.unlock = function() {`

`Accommodation.prototype.unlock.call(this);`

`this.deactivateAlarm();`

`};`

观察我们如何引用我们在新方法中变形的原始方法，只需在父“类”定义的`prototype`属性中直接引用它。因为该方法包含对其上下文`this`的引用，所以我们需要确保它引用从该子类创建的对象实例的上下文。我们通过执行`call`方法来做到这一点，该方法可用于 JavaScript 中的任何函数，用于将上下文从一个函数应用到另一个函数。

##### JavaScript 函数的`apply`和`call`方法

我们之前看了一下上下文。JavaScript 中的关键字`this`指的是当前方法周围的对象，在面向对象的 JavaScript 编程中，它指的是从“类”创建的特定对象实例。

如果您从当前上下文之外的另一个对象调用一个方法，那么该方法中对`this`的任何引用都将指向它周围的对象，而不是您正在其中执行代码的对象——您已经跳到了一个不同的上下文。当从其他对象调用方法时，我们需要一种方法来维护我们原来的`this`上下文。JavaScript 通过任何`function` — `apply`和`call`都可以使用的两种类似的方法提供了实现这一点的手段。

我们在前面关于多态性的章节中看到了使用的`call`方法，这是一种从子类中的父“类”调用函数的方式。在这种情况下，我们将从子类创建的对象实例的上下文直接传递给父类的`prototype`上的一个方法。在那个方法中任何对`this`的使用都是指对象实例，所以我们有一种从一个地方到另一个地方应用上下文的方法。如果还需要向函数传递参数，可以在上下文之后列出这些参数。`call`和`apply`的区别在于`apply`的参数应该包含在一个数组参数中，而它们应该用`call`连续列出，用逗号分隔，如清单 1-15 所示。

清单 1-15。函数的 apply 和 call 方法

`// Define a simple "class"`

`function Accommodation() {`

`this.isAlarmed = false;`

`}`

`// Create an object whose functions can be used in conjunction with an object in your code`

`// – also known as a 'mixin'`

`var AlarmSystem = {`

`arm: function(message) {`

`this.isAlarmed = true;`

`alert(message);`

`},`

`disarm: function(message) {`

`this.isAlarmed = false;`

`alert(message);`

`}`

`};`

`var myHouse = new Accommodation();`

`// Pass the object instance context into the 'arm' function using 'call'.`

`AlarmSystem.arm.call(myHouse, "Alarm activated");`

`// The 'arm' function's 'this' value was the object instance` `, therefore the 'isAlarmed' property`

`// of myHouse was changed`

`alert(myHouse.isAlarmed); // true`

`// The same effect can be achieved using 'apply', this time the parameters are sent as an array`

`AlarmSystem.disarm.apply(myHouse, ["Alarm deactivated"]);`

`alert(myHouse.isAlarmed); // false`

###### 参数对象

当执行一个函数时，我们传递括号中的任何参数，这些参数可以作为变量在该函数中使用。此外，JavaScript 中有一个保留关键字`arguments`，它出现在函数中，就像一个数组，包含按顺序传递给函数的参数列表。

假设您有一个函数，您希望使用它将作为参数传递给它的所有数字相加。因为您不希望指定参数的确切数目，所以您可以将它们留空，而是依赖于`arguments`伪数组，如清单 1-16 所示。我们称它为伪数组，因为它可以在一个`for`循环中迭代，但是不展示标准数组可用的其他方法，比如排序，在代码中处理它时不需要排序。

清单 1-16。参数对象

`// Create a function to add together any parameters ('arguments') passed to it`

`var add = function() {`

`// Create a variable to store the total of the addition in`

`var total = 0;`

`// The 'arguments' pseudo-array contains the arguments passed into this function.`

`// Loop through each and add them together to form a total`

`for (var index = 0, length = arguments.length; index < length; index++) {`

`total = total + arguments[index];`

`}`

`return total;`

`};`

`// Try the function out with different numbers of parameters`

`alert(add(1, 1)); // 2`

`alert(add(1, 2, 3)); // 6`

`alert(add(17, 19, 12, 25, 182, 42, 2)); // 299`

当与函数`apply`方法一起使用时，`arguments`伪数组发挥了自己的作用。因为该方法将参数作为数组传递给函数，所以我们有一种简单的方法从任何其他具有相同输入参数的函数中调用函数——我们有效地将参数从一个函数调用传递给另一个函数调用。这在对象继承和多态中很有用，允许我们将子类的方法的参数传递给父类的类似方法，如清单 1-17 所示。

清单 1-17。在子类中使用伪数组参数

`// Define our parent Accommodation "class"`

`function Accommodation() {`

`this.isAlarmed = false;`

`}`

`Accommodation.prototype.alarm = function(note, time) {`

`var message = "Alarm activated at " + time + " with the note: " + note;`

`this.isAlarmed = true;`

`alert(message);`

`};`

`// Define a subclass for House`

`function House() {`

`this.isLocked = false;`

`}`

`// Inherit from Accommodation`

`House.prototype = new Accommodation();`

`// Redefine the 'alarm' method specifically for the House "class". No need to list the arguments`

`// in the function definition here since we're going to simply pass them through to the same`

`// method on the parent "class"`

`House.prototype.alarm = function() {`

`// Set the 'isLocked' property on this object instance to 'true'`

`this.isLocked = true;`

`// Execute the 'alarm' method from the parent Accommodation "class", passing all the`

`// arguments from the execution of this method onto the parent method – no need to`

`// explicitly list the arguments!`

`Accommodation.prototype.alarm.apply(this, arguments` `);`

`};`

`// Create an object instance from the subclass and try it out`

`var myHouse = new House();`

`myHouse.alarm("Activating alarm", new Date()); // Alerts "Alarm activated at Fri Feb 14 2014`

`// 13:02:56 GMT+0100 (BST) with the note:`

`// Activating alarm"`

`alert(myHouse.isLocked); // true`

##### 对属性和方法的公共、私有和受保护的访问

在我们到目前为止的例子中，我们已经创建了“类”模板，它将属性和方法绑定到构造函数的`prototype`属性，或者绑定到使用`this`关键字从“类”创建的对象实例的范围。以这两种方式之一创建的每个属性和方法都被称为是公共的，也就是说，所有属性和方法对于从该“类”创建的所有对象实例都是可用的，因此对于可以访问该对象实例的代码库的任何其他部分也是可用的。

但是，在某些情况下，您可能希望限制某些属性和方法的公开，以便它们不能被自由访问、直接操作或从对象实例本身调用。许多经典编程语言都具有通过将属性和方法定义为 public、private 或 protected 来限制对它们的访问的能力。私有变量或函数不能从类定义之外读取或写入，受保护变量不能直接访问，但可以通过包装方法读取或写入。这样的包装方法通常被称为 getters 和 setters，它们允许你从对象实例中获取变量的值和/或设置它的值。通过只创建一个 getter 函数，可以在类定义之外将变量设为只读。在 JavaScript 中，对于私有或受保护的变量或函数，我们没有特定的符号，但是我们可以通过对声明“类”的方式进行一些更改来减少对属性和方法的访问

在一个构造函数中用`var`声明一个变量，使得这个变量的作用域仅限于这个函数——任何放在`prototype`对象上的方法都不能访问它，因为这个方法有自己的作用域。为了允许我们通过公共方法访问私有变量，我们需要创建一个包含两者的新范围。我们通过创建一个称为闭包的自执行函数来做到这一点，它完全包含了“类”的定义、私有变量和原型方法，如清单 1-18 所示。

尽管 JavaScript 语言中并不要求，但一个好的惯例是在任何私有变量或函数名前面加上一个下划线字符(`_`)来表示它是私有的。这将有助于您和项目中的其他开发人员更好地理解每个“类”的开发人员的意图

清单 1-18。公共、私有和受保护的属性和方法

`// We wrap our "class" definition code in a self-executing function which returns the "class" we`

`// create and places it into a variable for use throughout the rest of our code.`

`var Accommodation = (function() {`

`// Create our constructor function for our "class". Since we are inside a new function, we`

`// have a new scope, therefore we can use the same name as the variable we are returning`

`// our "class" to, for use in the rest of our code`

`function Accommodation() {}`

`// Any variable defined here is considered 'private', it isn't available outside this scope`

`// We can denote it as such by prefixing its name with an underscore.`

`var _isLocked = false,`

`_isAlarmed = false,`

`_alarmMessage = "Alarm activated!";`

`// Any function defined in this scope only (not on the prototype of the constructor`

`// function), is considered 'private' also`

`function _alarm() {`

`_isAlarmed = true;`

`alert(_alarmMessage);`

`}`

`function _disableAlarm() {`

`_isAlarmed = false;`

`}`

`// Any method placed on the prototype is going to be 'public', accessible outside this scope`

`// once the "class" is returned later on in this closure`

`Accommodation.prototype.lock = function() {`

`_isLocked = true;`

`_alarm();`

`};`

`Accommodation.prototype.unlock = function() {`

`_isLocked = false;`

`_disableAlarm();`

`};`

`// Create a 'getter' function to allow public read-only access to the value inside the`

`// private variable 'isLocked' – effectively making this variable 'protected'`

`Accommodation.prototype.getIsLocked = function() {`

`return _isLocked;`

`};`

`// Create a 'setter' function to allow public write-only access to the '_alarmMessage'`

`// private variable – effectively making it 'protected'`

`Accommodation.prototype.setAlarmMessage = function(message) {`

`_alarmMessage = message;`

`};`

`// Return the "class" we created in this scope to make it available to the surrounding scope`

`// and hence the rest of our code. Only the public properties` `and methods will be available`

`return Accommodation;`

`}());`

`// Create an object instance`

`var house = new Accommodation();`

`house.lock();  // Alerts “Alarm activated”`

`house._alarm();  // error! The '_alarm' function was never exposed publicly so it's not`

`// available directly to any object instance created from the "class"`

`alert(house._isLocked);// undefined ('_isLocked' is private and cannot be accessed outside`

`// the closure)`

`house.getIsLocked(); // true (returns the value of the '_isLocked' variable, but doesn't allow`

`// direct access to it, so it's a read-only value)`

`house.setAlarmMessage("The alarm is now activated!");`

`house.lock();  // Alerts "The alarm is now activated"`

一般来说，您应该将所有变量和函数声明为私有的，除非您特别需要公开它们。即使这样，也要考虑使用 getter 和/或 setter 方法来访问变量，将其他人对您的“类”的操作限制在严格要求的范围内，这将减少他们的代码出错的机会。

##### 简化继承

我们可以通过定义一个基础“类”来简化对象的构造和继承，从这个基础“类”可以创建所有其他的“类”。通过给这个“类”一个从自身继承的方法，并允许子类通过一个属性访问父类，我们使得创建和使用子类的任务变得更加简单。我们还可以将原型上设置方法的所有代码包装在一个对象文字中，甚至可以在该文字中包含我们的构造函数，从而使“类”的创建变得轻而易举。研究清单 1-19 中的代码，并随意在自己的项目中使用它来简化“类”的创建

清单 1-19。简化其他“类”创建的基础“类”

`// Define an object called Class with a create() method for use creating "classes".`

`// Use a closure to maintain inner functions without exposing them publicly.`

`var Class = (function() {`

`// The create() method defines and returns a new "class" when called, based on an object`

`// literal representing the public properties and methods for its prototype. A method named`

`// initialize() will be executed as the constructor function. If an optional`

`// 'parentPrototype' property is passed in, representing a parent "class", it creates the`

`// new "class" as a subclass of that.`

`function create(classDefinition, parentPrototype) {`

`// Define the constructor function of a new "class", using the initialize() method from`

`// the 'classDefinition' object literal if it exists`

`var _NewClass = function() {`

`if (this.initialize && typeof this.initialize === 'function') {`

`this.initialize.apply(this, arguments);`

`}`

`},`

`_name;`

`// If a 'parentPrototype' object has been passed in (when inheriting from other`

`// "classes"), inherit everything from the parent to this subclass`

`if (parentPrototype) {`

`_NewClass.prototype = new parentPrototype.constructor();`

`for (_name in parentPrototype) {`

`if (parentPrototype.hasOwnProperty(_name)) {`

`_NewClass.prototype[_name] = parentPrototype[_name];`

`}`

`}`

`}`

`// Define a function to create a closure and return a function to replace the one`

`// passed in, wrapping it and providing a __parent() method which points to the`

`// method of the same name from a parent "class", to enable support for polymorphism`

`function polymorph(thisFunction, parentFunction) {`

`return function () {`

`var output;`

`this.__parent = parentFunction;`

`output = thisFunction.apply(this, arguments);`

`delete this.__parent;`

`return output;`

`};`

`}`

`// Apply the newly provided "class" definition, overriding anything that already exists`

`// from the parentPrototype`

`for (_name in classDefinition) {`

`if (classDefinition.hasOwnProperty(_name)) {`

`// If we're attempting polymorphism, creating new methods named the same as`

`// ones from the parent "class", then we want to expose a way of calling the`

`// parent function of the same name in a simple way`

`if (parentPrototype && parentPrototype[_name] &&`

`typeof classDefinition[_name] === 'function') {`

`_NewClass.prototype[_name] = polymorph(classDefinition[_name], parentPrototype[_name]);`

`} else {`

`// If we're not attempting polymorphism, just map over the entry from the`

`// 'classDefinition' object literal to the prototype directly`

`_NewClass.prototype[_name] = classDefinition[_name];`

`}`

`}`

`}`

`// Ensure the constructor is set correctly, whether inherited` `or not (in case a`

`// 'constructor' property or method was passed in the 'classDefinition' object literal)`

`_NewClass.prototype.constructor = _NewClass;`

`// Define an extend() method on the "class" itself, pointing to the private extend()`

`// function, below, which allows the current "class" to be used as a parent for`

`// a new subclass`

`_NewClass.extend = extend;`

`return _NewClass;`

`}`

`// The extend() method is the same as the create() method but with an additional parameter`

`// containing the prototype from the parent "class" for inheriting from`

`function extend(classDefinition) {`

`return create(classDefinition, this.prototype);`

`}`

`// Expose the private create() method publicly under the same name`

`return {`

`create: create`

`};`

`}());`

我们可以使用这个基础“类”创建器以一种易于理解的方式创建和继承类，如清单 1-20 所示。

清单 1-20。运行中的基本“类”创建者

`// Define a "class" using Class.create, passing an object literal representing the public`

`// properties and methods to be made available to that "class". The 'initialize' method will`

`// become the constructor function of the new "class"`

`var Accommodation = Class.create({`

`isLocked: true,`

`isAlarmed: true,`

`lock: function() {`

`this.isLocked = true;`

`},`

`unlock: function() {`

`this.isLocked = false;`

`},`

`initialize: function() {`

`this.unlock();`

`}`

`});`

`// Create a subclass of Accommodation, using the 'extend' method that Class.create adds to any`

`// "classes" it creates, for simple inheritance. All the public properties and methods from the`

`// parent "class" are available to the subclass, with those of the same name overriding those`

`// from the parent.`

`var House = Accommodation.extend({`

`floors: 2,`

`lock: function() {`

`// Even though we're using polymorphism to replace the parent "class" of the same name,`

`// we can still access that parent "class" method using 'this.parent()'`

`this._parent();`

`alert("Number of floors locked: " + this.floors);`

`}`

`});`

`// Create objec` `t instances from the new "classes"`

`var myAccommodation = new Accommodation();`

`alert(myAccommodation instanceof Accommodation); // true`

`alert(myAccommodation instanceof House); // false`

`var myHouse = new House();`

`alert(myHouse.isLocked); // false (set by the parent "class"'s initialize method,`

`// inherited by House)`

`myHouse.lock(); // Alerts “Number of floors locked: 2”`

`alert(myHouse.isLocked); // true`

`alert(myHouse instanceof House); // true`

`alert(myHouse instanceof Accommodation); // true`

## 编码约定和命名

现在，我们已经介绍了 JavaScript 中面向对象编程的复杂性，让我们看看编码约定，以及我们命名变量和函数的方式，以暗示含义并确保大型团队中的所有开发人员以相似的方式编码。

JavaScript 允许您将变量存储在内存中，以便在整个代码中重用，方法是使用保留字`var`，后跟变量名和一个可选的初始值。类似地，通过在名字前面加上`function`关键字，可以将函数存储在内存中以便重复执行。只要遵守以下规则，您可以随意命名变量和函数:

其名称必须以下列之一开头:

*   一个字母，例如`a-z`、`A-Z`
*   一个下划线字符，`_`
*   `$`美元符号

在变量名的第一个字符后，允许数字(`0-9`)与上述数字一起出现。

以下是 JavaScript 中有效变量和函数名称的所有示例:

`var a;`

`function A() {};`

`var a1;`

`function _() {};`

`var _a;`

`function $() {};`

`var $_$;`

除了这些固定的规则之外，作为开发人员，我们希望在工作和维护时确保代码是可读和可理解的，因此我们使用许多开发人员和编程语言通用的命名约定。通过坚持这些变量命名的规则，您将理解如何在您的代码中使用变量，并且您也将更好地理解其他人编写的代码。

### 规则 1:使用描述性名称

这条规则是最重要的，所以我选择首先强调它。变量名用于表示存储在其中的数据，因此选择一个最能描述其用途的名称将有助于提高代码的可读性，从而使代码更容易理解，如下面的示例所示:

`var greeting = “Hello, world”;`

### 规则 2:以小写字母开头

用小写字母开始你的变量名，然后尽可能用小写字母继续你的变量名。这样做可以避免与 JavaScript 的内置类型和对象混淆，这些类型和对象都以大写字母开头，例如，`String`、`Object`、`Math`。例如:

`var age = 35;`

我在编码中使用的这条规则有一些特殊的例外。首先，当使用 jQuery 时，我更喜欢将定位的 DOM 元素存储在变量中，以避免在我的代码中稍后从页面中再次查找它们的需要。在这种情况下，我在这些变量名前面加上`$`，以区分 DOM 节点和代码中的其他变量。然后，`$`字符后的变量名称的剩余部分遵循与其他变量相同的规则，例如:

`var $body = $(document.body);`

第二个例外是命名要在代码中用作构造函数的函数。我们稍后将更详细地讨论构造函数，但本质上 JavaScript 中的内置类型是构造函数，例如`String`、`Number`、`Boolean`等等。本质上，这些是任何期望与关键字`new`一起使用的函数。这些名称的首字母应该大写，如下所示:

`function MyType() {};`

`var myTypeInstance = new MyType();`

第三个例外是，如前所述，当在一个构造函数中命名被设计为私有的变量和函数时，要在它们的名字前加上一个下划线(`_`)字符，以区别于那些打算公开的变量和函数。

`function MyType() {`

`var _myPrivateVariable;`

`};`

`var myTypeInstance = new MyType();`

### 规则 3:使用大小写来表示单词划分

规则 1 指导我们使用描述性名称，但是如果我们只使用小写字符，例如，当我们到达单词的边界时，我们创建的变量名将很难阅读。

`var myemailaddress = "den.odell@me.com";`

在变量名的第一个字母上，除了第一个单词之外，使用大写字符，这样名称更容易阅读，如下所示。

`var myEmailAddress = "den.odell@me.com";`

### 规则 4:使用全部大写字符来表示通用常量

这条规则涉及到通常在计算中使用的幻数。这些是在处理日期和时间，或者基于真实世界的常量值(如 Pi)进行计算时经常使用的杂散数字。许多开发人员只是在需要的时候使用这些数字，这是可行的，但经常会导致混乱。看看下面的例子，它演示了这一点。

`var today = new Date(),`

`todayInDays = today * 1000 * 60 * 60 * 24;`

如果不仔细检查，快速浏览一下这个代码示例就会发现一系列用途不明的数字。通过创建变量并命名这些数字，代码变得更容易理解。我们使用所有大写字符来表示这些是固定的数值，也称为常数，虽然这是许多其他编程语言的一个特性，但不是 JavaScript 中的特性，并且使用下划线(`_`)字符来实现单词分隔，如下面给出的更新示例所示:

`var today = new Date(),`

`MILLISECS_IN_1_SEC = 1000,`

`SECS_IN_1_MIN = 60,`

`MINS_IN_1_HOUR = 60,`

`HOURS_IN_1_DAY = 24,`

`todayInDays = today * MILLISECS_IN_1_SEC * SECS_IN_1_MIN * MINS_IN_1_HOUR * HOURS_IN_1_DAY;`

不可否认，这产生了更多的代码，但是我相信这是值得的，因为它提供了可读性。每个声明的常数可以在整个代码中重用，使得计算更容易理解。

### 规则 5:将变量声明放在每个函数块顶部的一个语句中

JavaScript 允许使用`var`关键字同时声明多个变量，通过用逗号(`,`)字符分割每个变量声明。明智的做法是确保在尝试使用变量之前声明它们，以避免在运行代码时出现错误。因此，我建议您将所有使用的变量声明为任何函数块或 JavaScript 文件的顶部，并将它们组合成一条语句。请注意，您不必将值初始化到稍后要初始化的任何变量中，只需预先声明所有变量。用逗号和换行符分隔每个变量，并将每个变量名称的开头与前一个对齐，以确保可读性，如以下示例所示:

`var myString = "Hello, world",`

`allStrongTags = /<strong>(.*?)</strong>/g,`

`tagContents = "&1",`

`outputString;`

`outputString = myString.replace(allStrongTags, tagContents);`

#### 变量和函数名托管

在许多其他常见的编程语言中，变量可以在任何代码块中定义，如`for`循环或任何通常用花括号`{`和`}`表示的代码块，并且它们的范围仅限于该代码块。然而，在 JavaScript 中，我们知道范围仅限于函数级，然而这可能会使一些习惯于用其他语言编程的开发人员出错；清单 1-21 展示了这一点。

清单 1-21。代码块和范围

`function myFunction() {`

`var myArray = ['January', 'February', 'March', 'April', 'May'],`

`myArrayLength = myArray.length,`

`counter = 0;`

`for (var index = 0; index < myArrayLength; index++) {`

`// Increment counter each time around the loop`

`counter = index + 1;`

`}`

`// The values of the variables should be as expected`

`alert(counter); // 5`

`alert(index); // 5 (since the loop increments before testing its condition)`

`alert(myArrayLength); // 5`

`if (myArrayLength > 0) {`

`// In many languages, defining variables in a code block like this keeps their scope`

`// locked to that code block. Not so in JavaScript, so beware defining variables locally`

`// to code blocks in this way`

`var counter,`

`index = 0,`

`myArrayLength;`

`counter = 0;`

`}`

`// The values of 'counter' and 'index' were altered within the 'if' statement, regardless of`

`// the use of the 'var' statement in that code block`

`alert(counter); // 0`

`alert(index); // 0`

`// Note that the value` `of 'myArrayLength' has not changed, despite it being redefined within`

`// the code block with the 'var' statement. This is because variable names are 'hoisted' to`

`// the top of functions by JavaScript before the function executes`

`alert(myArrayLength); // 5`

`}`

`// Execute the defined function`

`myFunction();`

JavaScript 展示了一种有趣的行为，通常被称为提升，在这种行为中，变量和函数声明在内部被提升到定义它们的函数块的顶部。这意味着任何变量名定义都是有效可用的，尽管不一定从其周围范围(通常是一个函数)的顶部初始化为一个值。为了最小化这可能导致的任何奇怪的影响，建议在任何函数开始时都列出该函数中要使用的所有变量，无论是初始化的还是其他的，因为这最好地模仿了 JavaScript 提升的内部行为，并减少了在未知变量定义和值代码中混淆的机会；清单 1-22 显示了这一点。

清单 1-22。以函数中使用的变量开始所有函数

`function myFunction() {`

`// All variables defined up front in the function to avoid being tripped up by hoisting`

`var myArray = ['January', 'February', 'March', 'April', 'May'],`

`myArrayLength = myArray.length,`

`counter = 0,`

`index = 0;`

`// The first statement within the for loop definition, which would normally be used to`

`// initialize a variable can be skipped now we've moved all variable declarations to`

`// the top of the function`

`for (; index < myArrayLength; index++) {`

`counter = index +1;`

`}`

`// The values of the variables` `should be as expected`

`alert(counter); // 5`

`alert(index); // 5`

`alert(myArrayLength); // 5`

`}`

`// Execute the function`

`myFunction();`

这同样适用于函数，由于提升，函数的名字在它们当前作用域的任何地方都是可用的，甚至在它们定义之前，如清单 1-23 所示。

清单 1-23。功能提升

`function myFunction() {`

`// Executing a function before its definition is possible due to 'hoisting' in JavaScript`

`doSomething(); // The function below is executed`

`function doSomething() {`

`alert("Doing something");`

`}`

`}`

`myFunction();`

## ECMAScript 5

1996 年，JavaScript 的创始人 Brendan Eich 将他的语言提交给标准机构 Ecma international 进行审核和标准化，该语言的第一个官方版本 ECMAScript 于 1997 年发布。JavaScript 不是 ECMAScript 的唯一实现；多年来，Adobe 一直在他们的 Flash 和 Flex 产品中使用一种称为 ActionScript 的风格。

从 1999 年开始，Ecma International 做了很少的工作，当时他们推出了该语言的第三个版本，在此期间没有看到该语言本身的变化，主要是因为对语言复杂性的分歧；出于这些原因，计划中的第四版被放弃了。这种情况在 2009 年底发生了变化，当时该组织发布了该语言的第五个版本(他们需要与他们的内部编号保持一致，尽管第四个版本被放弃了)。第六个版本正在计划中，尽管在撰写本文时还不知道发布日期。

由于浏览器制造商已经转向更有规律的发布时间表，尽管 ECMAScript 5 才推出两年，但浏览器对 ECMAScript 5 的支持却出人意料地好，各大浏览器制造商的最新版本产品都支持 ECMAScript 5。您可以通过访问 [`http://bit.ly/ecma_compat`](http://bit.ly/ecma_compat) 查看最新的功能支持矩阵。

作为一名试用者，我将在这一部分重点介绍该规范的几个主要特性，但是我鼓励您通过 [`http://bit.ly/ecma_5`](http://bit.ly/ecma_5) 在 ECMAScript 官方网站上阅读更多详细信息。

### JSON 数据格式解析

大多数专业 JavaScript 开发人员以前都会遇到 JSON 格式的数据。这是以字符串形式存储的数据，或者存储在文本文件中的数据，其格式非常类似于对象文字，例如下面显示的 JSON 格式的数据结构:

`{`

`"success": false,`

`"error_message": "The wrong parameters were passed to this web service."`

`}`

将这样的字符串转换成 JavaScript 对象文字，以便在函数中使用，这些函数通常涉及下载并包含 Doug Crockford 的 JSON 解析库，来自 [`http://bit.ly/crock_json`](http://bit.ly/crock_json) 的 json.js。然而，ECMAScript 5 将这个库嵌入到 JavaScript 语言中，使得以下函数可用于将 JSON 数据转换为对象文字，反之亦然:

`JSON.parse(stringOfJSONFormattedData); // returns an object literal`

`JSON.stringify(objectLiteral); // returns a string of JSON-formatted data`

### 严格模式

ECMAScript 5 引入了将函数或整个 JavaScript 文件置于新的严格编码模式的能力，只需在文件或函数中放置以下字符串。

`"use strict";`

包含该字符串的文件或函数中的任何代码都将遵循更严格的语言规则，这应该有助于避免潜在的错误和陷阱。现在，如果你试图使用一个没有定义的变量，JavaScript 将会在执行严格模式下的代码时抛出一个错误。如果您试图使用一个包含两个相同命名属性的对象文字(这是我以前犯过的一个错误)，如果您试图在变量或函数上使用`delete`关键字，而不是在一个想要使用该关键字的对象属性上，它也会报错。严格模式也将禁止使用`eval`来执行包含 JavaScript 代码的字符串，因为这可能是一个安全隐患，并从您自己编写的代码中夺走对代码的控制。

由一个简单的字符串强制执行的严格模式的优点是，旧的浏览器在遇到代码中的语句时不会出错，它们会简单地将它作为一个字符串执行，并且因为它没有被赋给变量值，所以会有效地忽略它。比较清单 1-24 中的两个函数，一个在正常模式下，一个在严格模式下。我已经开始在我的所有代码中使用这种新的严格模式，以确保我的代码质量足够高，我也向您推荐这种模式。

清单 1-24。演示 ECMAScript 5 严格模式

`// Define a function`

`function myFunction() {`

`// Using a previously undefined variable will implicitly create it as a global variable`

`counter = 1;`

`// Executing strings of JavaScript code using eval() throws no errors`

`eval("alert(counter)");`

`// The delete keyword is for removing properties and methods from an object, but`

`// calling it on a variable throws no error`

`delete counter;`

`}`

`// Execute the function`

`myFunction();`

`// Redefine the same function using ECMAScript 5 strict mode`

`function myFunction() {`

`// Enforce strict mode for the code` `within this function`

`"use strict";`

`counter = 1; // Throws an error when executed, since the 'counter' variable was not defined`

`eval("alert(counter)"); // Throws an error as 'eval' is to be avoided for security reasons`

`delete counter; // Throws an error since the 'delete' keyword is only to be used for`

`// removing named properties and methods from object literals`

`}`

`// Execute the function`

`myFunction();`

### 功能连接

我们已经看了 JavaScript 中所有函数可用的`apply`和`call`方法。ECMAScript 5 添加了另一个方法`bind`，它不执行函数，而是返回一个新函数，函数的上下文设置为传递到调用`bind`的第一个参数中的任何对象。

您可能在自己的代码中遇到过这种需求，特别是在引用事件处理程序时。如果您的事件处理函数是对象实例上的一个方法，您可能会尝试将它与您的处理函数一起使用，以执行另一个方法或访问对象实例上的一个属性。如果您尝试这样做，您可能会意识到事件处理程序的上下文是对发生的事件的引用，而不是方法的对象实例。这个函数的新的`bind`方法允许你改变这个行为，根据需要把你自己的上下文传递给处理程序，如清单 1-25 所示。

清单 1-25。函数绑定方法

`var header = document.createElement("header"),`

`mouseState = "up",`

`// Define an object containing three methods`

`eventHandlers = {`

`onClick: function() {`

`// If the context is wrong when 'onClick' is called, the next two calls will fail`

`this.onMouseDown();`

`this.onMouseUp();`

`},`

`onMouseDown: function() {`

`mouseState = "down";`

`},`

`onMouseUp: function() {`

`mouseState = "up";`

`}`

`};`

`// Force the correct context for 'eventHandlers.onClick' by using 'bind' to return a new`

`// function, bound to the context we require`

`header.addEventListener("click", eventHandlers.onClick.bind(eventHandlers), false);`

`// Add the <header> element to the page`

`document.body.appendChild(header);`

### 数组方法

大多数专业 JavaScript 开发人员每天都使用数组来循环、排序和组织数据。ECMAScript 5 为 JavaScript 开发人员的工具包提供了一些急需的新方法，用于处理这些类型的数据结构。

首先，也可能是最重要的，是能够轻松确定变量是否包含数组数据。这听起来可能很奇怪，但是要检测一个变量是否真的包含数组数据，需要将它转换成一个对象类型，并以字符串形式读出它的值——太疯狂了！要在 ECMAScript 5 中检测一个变量是否包含数组数据，只需调用`Array.isArray`方法，如清单 1-26 所示。

清单 1-26。ECMAScript 5 是一个数组方法

`var months = ["January", "Febraury", "March", "April", "May"],`

`items = {`

`"0": "January",`

`"1": "February",`

`"2": "March",`

`"3": "April",`

`"4": "May"`

`};`

`alert(Array.isArray(months)); // true`

`alert(Array.isArray(items)); // false`

遍历数组目前包括创建一个`for`循环，并遍历某种类型的索引计数器。ECMAScript 5 引入了一个新的`forEach`方法，允许更简单的循环；给这个方法提供一个函数，它对数组中的每一项执行一次这个函数，传入迭代的当前值、索引，最后传入对整个数组的引用，如清单 1-27 所示。

清单 1-27。ECMAScript 5 forEach 方法

`var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];`

`// The forEach method allows you to loop through each item in an array, executing a function`

`// each time`

`months.forEach(function(value, index, fullArray) {`

`alert(value + " is month number " + (index + 1) + " of " + fullArray.length);`

`});`

如果您曾经需要确定数组中的每个元素是否满足由函数定义的特定条件，那么您已经等待 ECMAScript 5 的新方法`every`太久了。如果数组中至少有一项匹配给定条件，类似的`some`方法将返回`true`。`every`和`some`方法都采用与`forEach`方法相同的参数，如清单 1-28 所示。

清单 1-28。ECMAScript 5 every 和一些方法

`var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],`

`// The every method loops through each item in an array, comparing it to a`

`// condition. If the condition returns true for every item in the array, the`

`// every method returns true, otherwise it returns false`

`everyItemContainsR = months.every(function(value, index, fullArray) {`

`// returns a true or false value indicating whether the current`

`// iteration matches your condition, in this case whether the value contains`

`// the letter 'r'`

`return value.indexOf("r") >= 0;`

`}),`

`// The some method` `loops through each item in an array, comparing it to a`

`// condition. If the condition returns true for any item in the array, the`

`// some method returns true, otherwise it returns false`

`someItemContainsR = months.some(function(value, index, fullArray) {`

`return value.indexOf("r") >= 0;`

`});`

`// Not every item contains the letter 'r'…`

`alert(everyItemContainsR); // false`

`// …but some do!`

`alert(someItemContainsR); // true`

新的`map`方法允许你从一个现有的数组创建一个全新的数组，在新数组形成时对每个项目执行一次函数，如清单 1-29 所示。

清单 1-29。ECMAscript 5 映射方法

`var daysOfTheWeek = ["Monday", "Tuesday", "Wednesday"],`

`// The map method allows a whole new array to be created by looping through an existing one,`

`// executing a function for each item to determine the equivalent item in the new array`

`daysFirstLetters = daysOfTheWeek.map(function(value, index, fullArray) {`

`return value + " starts with " + value.charAt(0);`

`});`

`alert(daysFirstLetters.join(", ")); // "Monday starts with M, Tuesday starts with T,`

`// Wednesday starts with W"`

ECMAScript 5 的新的`filter` array 方法创建了一个新的数组，就像`map`一样，但是只有符合特定条件的项目才被允许进入新的数组，如清单 1-30 所示。

清单 1-30。ECMAScript 5 筛选方法

`var months = ["January", "February", "March", "April", "May"],`

`// The filter method creates a cut-down array from an original array, only permitting those`

`// items that match a certain condition into the new array`

`monthsContainingR = months.filter` `(function(value, index, fullArray) {`

`// return a true or false value indicating whether the current array item should be`

`// included in your filtered array, i.e. whether its value contains the letter 'r'`

`return value.indexOf("r") >= 0;`

`});`

`// The only month that didn't contain the letter 'r' was 'May'`

`alert(monthsContainingR.join(", ")); // "January, February, March, April"`

### 对象方法

ECMAScript 5 引入了对 native `Object`类型的大量扩展，带来了许多其他编程语言中存在的 JavaScript 能力。首先，如果使用严格模式，它引入了锁定一个对象的能力，这样通过一个新的`Object.preventExtensions`方法和一个关联的`Object.isExtensible`方法，在你的代码中的某个点之后就不能添加额外的属性或方法，它允许你检测一个对象是否能够被添加，如清单 1-31 所示。

清单 1-31。ECMAScript 5 对象方法

`// Define a simple object with two properties`

`var personalDetails = {`

`name: "Den Odell",`

`email: "den.odell@me.com"`

`};`

`alert(Object.isExtensible(personalDetails)); // true, as by default all objects can be extended`

`// Prevent the 'personalDetails' object being added to`

`Object.preventExtensions(personalDetails);`

`alert(Object.isExtensible(personalDetails)); // false, as the object is now locked down`

`// Attempt to add a new property to the 'personalDetails' object`

`personalDetails.age = 35; // Throws an exception if using 'strict' mode as the object is locked`

如果你想锁定一个对象，甚至它现有的属性都不能被修改，你可以通过 ECMAScript 5 的新的`Object.freeze`方法，如清单 1-32 所示。

清单 1-32。ECMAScript 5 对象冻结方法

`// Define a simple object with two properties`

`var personalDetails = {`

`name: "Den Odell",`

`email: "den.odell@me.com"`

`};`

`// Lock down the object` `so that not even its existing properties can be manipulated`

`Object.freeze(personalDetails);`

`alert(Object.isFrozen(personalDetails)); // true`

`personalDetails.name = "John Odell"; // Throws an error if using strict mode as the object`

`// cannot be altered once frozen`

对象的每个属性现在都有一组选项，这些选项决定了如何在代码的其余部分使用它，称为属性描述符，表示为具有四个属性的对象文字。要读取属性的描述符，使用新的`Object.getOwnPropertyDescriptior`方法，如清单 1-33 所示。除了`value`属性之外，描述符中的所有属性都默认为`true`。

清单 1-33。ECMAScript 5 对象 getOwnPropertyDescriptor 方法

`// Define a simple object with two properties`

`var personalDetails = {`

`name: "Den Odell",`

`email: "den.odell@me.com"`

`};`

`Object.getOwnPropertyDescriptor(personalDetails, "name");`

`// Returns the following object literal representing the 'name' property:`

`// {`

`//  configurable: true,`

`//  enumerable: true,`

`//  value: "Den Odell",`

`//  writable: true`

`// }`

使用 ECMAscript 5，您可以创建属性并同时定义它们的属性描述符，如清单 1-34 所示。

清单 1-34。ECMAScript 5 属性定义

`// Define a simple object with two properties`

`var personalDetails = {`

`name: "Den Odell",`

`email: "den.odell@me.com"`

`};`

`// Define a new individual property for the object`

`Object.defineProperty(personalDetails, "age", {`

`value: 35,`

`writable: false,`

`enumerable: true,`

`configurable: true`

`});`

`// Define multiple new properties at the same time`

`Object.defineProperty` `(personalDetails, {`

`age: {`

`value: 35,`

`writable: false,`

`enumerable: true,`

`configurable: true`

`},`

`town: {`

`value: "London",`

`writable: true`

`}`

`});`

如果你需要生成一个在对象中使用的属性名的数组，ECMAScript 5 有新的`Object.keys`方法支持你，如清单 1-35 所示。

清单 1-35。ECMAScript 5 对象键方法

`// Define a simple object with two properties`

`var personalDetails = {`

`name: "Den Odell",`

`email: "den.odell@me.com"`

`},`

`keys = Object.keys(personalDetails);`

`alert(keys.join(", ")); // "name, email"`

ECMAScript 5 的`Object.create`方法提供了一个强大的新方法，用于从另一个对象的属性创建新对象。这个方法的一个可能的用途是复制一个现有的对象，如清单 1-36 所示。

清单 1-36。ECMAScript 5 对象创建方法

`// Define a simple object with two properties`

`var personalDetails = {`

`firstName: "Den",`

`lastName: "Odell"`

`},`

`// Create a duplicate of this object`

`fathersDetails = Object.create(personalDetails);`

`// Customize the duplicated object`

`fathersDetails.firstName = "John";`

`// The properties set via the original object are still intact`

`alert(fathersDetails.lastName); // "Odell"`

如果 ECMAScript 5 中有一个新方法，你应该多研究一下，那就是`Object.create`方法，因为它可以在我们本章所讨论的内容之前，打开一个全新的对象继承世界。ECMAScript5 提供了极大简化代码运行和可读性的机会，这只是学习如何最好地使用它的一个例子。

## 摘要

在本章中，我们已经介绍了面向对象 JavaScript 编程的基础知识，包括对象、“类”、继承以及其他经典编程语言中流行的其他编程特性。我分享了我在变量和函数命名约定方面的一些经验，以及我发现最有效的一些经验。最后，我们介绍了 ECMAScript 5，这是浏览器制造商支持的 JavaScript fast 的最新版本。

在下一章中，我们将探讨如何以一致和可读的方式记录代码，使代码更容易理解，从而更容易使用，从而更好地帮助自己和其他开发人员。