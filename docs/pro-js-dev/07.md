# 七、设计模式：行为型

在这一章中，我们将继续关注设计模式，重点是行为设计模式。我们在第五章中看到的创造性设计模式侧重于对象创建，而我们在前一章中看到的结构性设计模式侧重于对象结构，行为设计模式侧重于帮助代码库中多个对象之间的通信。这里的要点是让你更容易理解你的代码是如何作为一个整体运作的，而不是仅仅关注单个对象的构造和结构。让我们一起来看看八种行为设计模式，你可能会发现它们在你的代码中很有用，还有一些例子。

## 责任链模式

当基于同一个“类”的多个对象中的任何一个可以处理一个请求或方法调用时，就使用责任链模式。请求被发送给一个对象，如果它不是处理请求的最合适的对象，它就把请求传递给另一个对象来处理。所以它会一直继续下去，直到一个对象处理了请求，并通过对象链将操作的结果传递回原始请求或方法调用。链中的每个对象都知道另一个对象，如果链中的下一个对象不能完成请求，那么它可以处理请求。这种模式最适用于共同形成某种层次结构的对象，如清单 7-1 所示，你不希望将的实现暴露给代码的其他部分。

清单 7-1。责任链模式

`// Define an object listing different levels of logging in a system - info, warn, and error –`

`// each indicating something more severe than the last`

`var LogLevel = {`

`INFO: 'INFO',`

`WARN: 'WARN',`

`ERROR: 'ERROR'`

`},`

`log;`

`// Define a "class" to create appropriately formatted log messages for different logging levels`

`function LogFormatter(logLevel) {`

`this.logLevel = logLevel;`

`}`

`LogFormatter.prototype = {`

`// Define a property to store the successor to this object instance in the chain`

`// of responsibility`

`nextInChain: null,`

`// Define a method to set the successor in the chain of responsibility`

`setNextInChain: function(next) {`

`this.nextInChain = next;`

`},`

`// Define a method to create an appropriately formatted log message based on the current`

`// logging level`

`createLogMessage: function(message, logLevel) {`

`var returnValue;`

`// If the logging level assigned to the current object instance is the same as that`

`// passed in, then format the log message`

`if (this.logLevel === logLevel) {`

`// Format the log message as appropriate according to the logging level`

`if (logLevel === LogLevel.ERROR) {`

`returnValue = logLevel + ": " + message.toUpperCase();`

`} else if (logLevel === LogLevel.WARN) {`

`returnValue = logLevel + ": " + message;`

`} else {`

`returnValue = message;`

`}`

`// If the logging level assigned to the current object instance does not match that`

`// passed in, then pass the message onto the next object instance in the chain`

`// of responsibility`

`} else if (this.nextInChain) {`

`returnValue = this.nextInChain.createLogMessage(message, logLevel);`

`}`

`return returnValue;`

`}`

`};`

`// Define a singleton we can use for storing and outputting logs in a system`

`log = (function() {`

`// Define a storage array for log messages`

`var logs = [],`

`// Create object instances representing the three levels of logging - info, warn,`

`// and error`

`infoLogger = new LogFormatter(LogLevel.INFO),`

`warnLogger = new LogFormatter(LogLevel.WARN),`

`errorLogger = new LogFormatter(LogLevel.ERROR),`

`// Set the 'error' logging level to be the first and highest level in our chain of`

`// responsibility, which we'll store in the 'logger' variable`

`logger = errorLogger;`

`// Set the chain of responsibility hierarchy using the setNextInChain() method on each`

`// object instance - we're assuming that the 'error' logging level is the most important and`

`// is first in the chain`

`// The next in the logging hierarchy after 'error' should be 'warn' as this is`

`// less important`

`errorLogger.setNextInChain(warnLogger);`

`// The next in the chain after the 'warn' logging level should be 'info' as this is the`

`// least important level`

`warnLogger.setNextInChain(infoLogger);`

`return {`

`// Define a method for reading out the stored log messages`

`getLogs: function() {`

`return logs.join("\n");`

`},`

`// Define a method for formatting a log message appropriately according to its`

`// logging level`

`message: function(message, logLevel) {`

`// We call the createLogMessage() method on the first object instance in our`

`// hierarchy only, which in turn calls those further down the chain if it does not`

`// handle the specified logging level itself. The message passes further down the`

`// chain of responsibility until it reaches an object instance who can handle the`

`// specific logging level`

`var logMessage = logger.createLogMessage(message, logLevel);`

`// Add the formatted log message to the storage array`

`logs.push(logMessage);`

`}`

`};`

`}());`

`// Execute the message() method of the 'log' singleton, passing in a message and the logging`

`// level. The first object in the chain of responsibility handles the 'error' logging level, so`

`// the message is not passed down the chain of responsibility and is returned by the`

`// errorLogger object`

`log.message("Something vary bad happened", LogLevel.ERROR);`

`// This message is passed through the errorLogger object to the warnLogger object through the`

`// chain of responsibility since the errorLogger object is only told to handle messages with the`

`// 'error' logging level`

`log.message("Something bad happened", LogLevel.WARN);`

`// This message is passed through the errorLogger object to the warnLogger object, and onto the`

`// infoLogger object which is the one handling 'info' type log messages`

`log.message("Something happened", LogLevel.INFO);`

`// Output the stored logs`

`alert(log.getLogs());`

`// Outputs the following:`

`/*`

`ERROR: SOMETHING VERY BAD HAPPENED`

`WARN: Something bad happened`

`Something happened`

`*/`

当您有一个对象层次结构，并且希望在整个代码中访问它而不暴露这个结构时，最好使用责任链模式。要了解有关责任链模式的更多信息，请查看以下在线资源:

*   约瑟夫·齐默曼的《JavaScript 设计模式:责任链》(via [`http://bit.ly/chain_pattern`](http://bit.ly/chain_pattern) )
*   维基百科上的“责任链模式”(via [`http://bit.ly/chain_wiki`](http://bit.ly/chain_wiki) )

## 命令模式

command 模式用于在调用代码和对象的特定方法之间提供一个抽象层，确保所有调用都是通过该对象上的一个公共方法进行的，通常命名为`run()`或`execute()`。使用这种模式提供了在不影响调用代码的情况下更改底层代码和 API 的能力。清单 7-2 中的例子显示了一个简单的命令模式的例子，它把要执行的方法名和参数传递给一个单独的`execute()`方法。

清单 7-2。命令模式

`var cookie = (function() {`

`var allCookies = document.cookie.split(";"),`

`cookies = {},`

`cookiesIndex = 0,`

`cookiesLength = allCookies.length,`

`cookie;`

`for (; cookiesIndex < cookiesLength; cookiesIndex++) {`

`cookie = allCookies[cookiesIndex].split("=");`

`cookies[unescape(cookie[0])] = unescape(cookie[1]);`

`}`

`return {`

`get: function(name) {`

`return cookies[name] || "";`

`},`

`set: function(name, value) {`

`cookies[name] = value;`

`document.cookie = escape(name) + "=" + escape(value);`

`},`

`remove: function(name) {`

`// Remove the cookie by removing its entry from the cookies object and setting its`

`// expiry date in the past`

`delete cookies[name];`

`document.cookie = escape(name) + "=; expires=Thu, 01 Jan 1970 00:00:01 GMT;";`

`},`

`// Supply an execute() method, which is used to abstract calls to other methods so that`

`// other method names can be changed as needs be in future without affecting the API`

`// available to the rest of the code - provided this execute() method continues to exist`

`execute: function(command, params) {`

`// The command parameter contains the method name to execute, so check that the`

`// method exists and is a function`

`if (this.hasOwnProperty(command) && typeof this[command] === "function") {`

`// If the method exists and can be executed, then execute it, passing across the`

`// supplied params`

`return this[command].apply(this, params);`

`}`

`}`

`};`

`}());`

`// Set a cookie using the execute() method to indirectly call the set() method of the cookie`

`// singleton and supplying parameters to pass onto that method`

`cookie.execute("set", ["name", "Den Odell"]);`

`// Check that the cookie was set correctly using execute() with the "get" method`

`alert(cookie.execute("get", ["name"])); // Den Odell`

命令模式也可以在需要“撤消”功能的应用的上下文中使用，其中执行的语句可能需要在将来的某个时间点被撤销，例如，在文字处理 web 应用的上下文中。在这种情况下，命令是通过一个命令执行对象来传递的，该对象使用这个抽象来存储适当的函数，以反转传递给它的方法调用，如清单 7-3 所示，它显示了一个简单的命令执行对象和一个基于清单 7-2 中的代码使用 cookies 的例子。

清单 7-3。支持 web 应用中多级撤消的命令执行对象

`// Create a singleton for allowing execution of other methods and providing the ability to`

`// 'undo' the actions of those methods`

`var command = (function() {`

`// Create an array to store the 'undo' commands in order, also known as a 'stack'`

`var undoStack = [];`

`return {`

`// Define a method to execute a supplied function parameter, storing a second function`

`// parameter for later execution to 'undo' the action of the first function`

`execute: function(command, undoCommand) {`

`if (command && typeof command === "function") {`

`// If the first parameter is a function, execute it, and add the second`

`// parameter to the stack in case the command needs to be reversed at some point`

`// in future`

`command();`

`undoStack.push(undoCommand);`

`}`

`},`

`// Define a method to reverse the execution of the last command executed, using the`

`// stack of 'undo' commands`

`undo: function() {`

`// Remove and store the last command from the stack, which will be the one most`

`// recently added to it. This will remove that command from the stack, reducing the`

`// size of the array`

`var undoCommand = undoStack.pop();`

`if (undoCommand && typeof undoCommand === "function") {`

`// Check the command is a valid function and then execute it to effectively`

`// 'undo' the last command`

`undoCommand();`

`}`

`}`

`};`

`}());`

`// Wrap each piece of functionality that can be 'undone' in a call to the command.execute()`

`// method, passing the command to execute immediately as the first parameter, and the function`

`// to execute to reverse that command as the second parameter which will be stored until such`

`// point as it is needed`

`command.execute(function() {`

`// Using the code from Listing 7-2, set a cookie - this will be executed immediately`

`cookie.execute("set", ["name", "Den Odell"]);`

`}, function() {`

`// The reverse operation of setting a cookie is removing that cookie - this operation will`

`// be stored for later execution if the command.undo() method is called`

`cookie.execute("remove", ["name"]);`

`});`

`// Execute a second piece of functionality, setting a second cookie`

`command.execute(function() {`

`cookie.execute("set", ["company", "AKQA"]);`

`}, function() {`

`cookie.execute("remove", ["company"]);`

`});`

`// Check the value of the two cookies`

`alert(cookie.get("name"));    // Den Odell`

`alert(cookie.get("company")); // AKQA`

`// Reverse the previous operation, removing the 'company' cookie`

`command.undo();`

`// Check the value of the two cookies`

`alert(cookie.get("name"));    // Den Odell`

`alert(cookie.get("company")); // "" (an empty string), since the cookie has now been removed`

`// Reverse the first operation, removing the 'name' cookie`

`command.undo();`

`// Check the value of the two cookies`

`alert(cookie.get("name"));    // "", since the cookie has now been removed`

`alert(cookie.get("company")); // ""`

当您需要从代码的其余部分中抽象出特定的方法名时，最好使用 command 模式。通过按名称引用方法，就像存储在字符串中一样，底层代码可以随时更改，而不会影响代码的其余部分。要在线阅读有关命令模式的更多信息，请查阅以下资源:

*   《JavaScript 设计模式:命令》，作者 Joseph Zimmerman，Adobe Developer Connection(通过 [`http://bit.ly/command_pattern`](http://bit.ly/command_pattern) )
*   彼得·米肖的《JavaScript 中的命令模式》(经由 [`http://bit.ly/command_js`](http://bit.ly/command_js) )

## 迭代器模式

顾名思义，交互模式允许应用中的代码在一组数据上迭代或循环，而不需要知道数据是如何在内部存储或构造的。迭代器通常提供一组标准方法，用于移动到集合中的下一项，并检查当前项是集合中的第一项还是最后一项。

清单 7-4 显示了一个通用“类”的例子，它可以迭代`Array`类型和`Object`类型的数据。这个迭代器的实例可以使用提供的方法`rewind()`、`current()`、`next()`、`hasNext()`和`first()`手动操作和查询，或者可以使用其`each()`方法提供自动自迭代，其中函数回调参数为数据集中的每一项执行一次，提供了一个有用的`for`循环的等效形式。

清单 7-4。迭代器模式

`// Define a generic iterator "class" for iterating/looping over arrays or object-like data`

`// structures`

`function Iterator(data) {`

`var key;`

`// Store the supplied data in the 'data' property`

`this.data = data || {};`

`this.index = 0;`

`this.keys = [];`

`// Store an indicator to show whether the supplied data is an array or an object`

`this.isArray = Object.prototype.toString.call(data) === "[object Array]";`

`if (this.isArray) {`

`// If the supplied data is an array, store its length for fast access`

`this.length = data.length;`

`} else {`

`// If object data is supplied, store each property name in an array`

`for (key in data) {`

`if (data.hasOwnProperty(key)) {`

`this.keys.push(key);`

`}`

`}`

`// The length of the property name array is the length of the data to iterate over,`

`// so store this`

`this.length = this.keys.length;`

`}`

`}`

`// Define a method to reset the index, effectively rewinding the iterator back to the start of`

`// the data`

`Iterator.prototype.rewind = function() {`

`this.index = 0;`

`};`

`// Define a method to return the value stored at the current index position of the iterator`

`Iterator.prototype.current = function() {`

`return this.isArray ? this.data[this.index] : this.data[this.keys[this.index]];`

`};`

`// Define a method to return the value stored at the current index position of the iterator,`

`// and then advance the index pointer to the next item of data`

`Iterator.prototype.next = function() {`

`var value = this.current();`

`this.index = this.index + 1;`

`return value;`

`};`

`// Define a method to indicate whether the index position is at the end of the data`

`Iterator.prototype.hasNext = function() {`

`return this.index < this.length;`

`};`

`// Define a method to reset the index of the iterator to the start of the data and return`

`// the first item of data`

`Iterator.prototype.first = function() {`

`this.rewind();`

`return this.current();`

`};`

`// Define a method to iterate, or loop, over each item of data, executing a callback`

`// function each time, passing in the current data item as the first parameter to`

`// that function`

`Iterator.prototype.each = function(callback) {`

`callback = typeof callback === "function" ? callback : function() {};`

`// Iterate using a for loop, starting at the beginning of the data (achieved using the`

`// rewind() method) and looping until there is no more data to iterate over (indicated`

`// by the hasNext() method)`

`for (this.rewind(); this.hasNext();) {`

`// Execute the callback function each time through the loop, passing in the current`

`// data item value and incrementing the loop using the next() method`

`callback(this.next());`

`}`

`};`

清单 7-4 中的代码可以像清单 7-5 中所示的那样使用，它展示了使用通用迭代器“class”对存储的数据进行迭代和循环的不同方式

清单 7-5。正在使用的迭代器模式

`// Define an object and an array which we can use to iterate over`

`var user = {`

`name: "Den Odell",`

`occupation: "Head of Web Development",`

`company: "AKQA"`

`},`

`daysOfWeek = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],`

`// Create instances of the Iterator "class" using these two different types of data`

`userIterator = new Iterator(user),`

`daysOfWeekIterator = new Iterator(daysOfWeek),`

`// Create three arrays for storing outputs of interations to be displayed later`

`output1 = [],`

`output2 = [],`

`output3 = [];`

`// The userIterator is ready for use, so let's use a for loop to iterate over the stored data –`

`// note how we don't need to supply the first argument to the for loop as the data is already`

`// reset and initialized in its start position, and we don't require the last argument since the`

`// next() method call within the for loop body performs the advancement of the index position`

`// for us`

`for (; userIterator.hasNext();) {`

`output1.push(userIterator.next());`

`}`

`// Since we iterated over an object, the resulting data consists of the values stored in each of`

`// the object's properties`

`alert(output1.join(", ")); // Den Odell, Head of Web Development, AKQA`

`// Before iterating over the same data again, its index must be rewound to the start`

`userIterator.rewind();`

`// Iterate over the object properties using a while loop, which continues to execute until the`

`// iterator has no further data items`

`while (userIterator.hasNext()) {`

`output2.push(userIterator.next());`

`}`

`alert(output2.join(", ")); // Den Odell, Head of Web Development, AKQA`

`// Iterate over the array data using the Iterator's built-in each() method - using this`

`// approach requires no manual work to manipulate the position of the index, simply pass a`

`// callback function`

`daysOfWeekIterator.each(function(item) {`

`output3.push(item);`

`});`

`alert(output3.join(", ")); // Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday`

当您需要为代码的其余部分提供一种标准方式来遍历复杂的数据结构，而又不暴露数据最终是如何存储或表示的时候，最好使用迭代器模式。要在线了解迭代器模式的更多信息，请查阅以下在线资源:

*   DoFactory 上的“JavaScript 迭代器设计模式”(通过 [`http://bit.ly/iterator_pattern`](http://bit.ly/iterator_pattern) )
*   维基百科上的“迭代器模式”(via [`http://bit.ly/iterator_wiki`](http://bit.ly/iterator_wiki) )

## 观察者模式

观察者模式用于由许多独立的代码模块组成的大型代码库中，这些代码模块相互依赖或者必须相互通信。在这样的代码库中，从一个模块到其他模块的硬编码引用提供了所谓的紧耦合，即需要明确了解系统中的每个其他模块，以便整个代码能够一起正确运行。然而，理想情况下，大型代码库中的模块应该是松散耦合的。没有明确地引用其他模块；相反，整个代码库都会触发和监听系统范围的事件，就像标准 DOM 事件处理的定制版本一样。

例如，如果一个模块负责通过 Ajax 进行的所有客户端-服务器通信，而另一个模块负责在将表单传输到服务器之前对其进行渲染和验证，那么当用户成功提交和验证表单时，代码库可以触发一个全局的“表单已提交”事件以及表单中的数据，通信模块将监听这些数据。然后，通信模块将执行其任务，向服务器发送数据，并在自身触发“接收到响应”事件之前接收其响应，表单模块将监听该事件。收到该事件后，表单模块可以显示一条消息，表明表单已成功提交，所有这些都不需要任何一个模块相互了解——每个模块唯一知道的是一组全局配置的事件名，系统中的任何模块都可以触发或响应这些事件名。

实现观察者模式的系统必须有三个对系统代码库可用的全局方法:`publish()`，它通过名称触发事件，传递任何可选数据；`subscribe()`，它允许模块分配一个函数，当特定的命名事件被触发时执行；和`unsubscribe()`，它取消了函数的设计，这样当指定的事件被触发时，它将不再被执行。清单 7-6 中的代码演示了一个简单的对象，它可以在您的应用中全局使用，以实现 observer 模式中的这些方法。

清单 7-6。观察者模式

`// Define an object containing global publish(), subscribe(), and unsubscribe() methods to`

`// implement the observer pattern`

`var observer = (function() {`

`// Create an object for storing registered events in by name along with the associatedw`

`// callback functions for any part of the full code base that subscribes to those`

`// event names`

`var events = {};`

`return {`

`// Define the subscribe() method, which stores a function along with its associated`

`// event name to be called at some later point when the specific event by that name`

`// is triggered`

`subscribe: function(eventName, callback) {`

`// If an event by the supplied name has not already been subscribed to, create an`

`// array property named after the event name within the events object to store`

`// functions to be called at a later time when the event by that name is triggered`

`if (!events.hasOwnProperty(eventName)) {`

`events[eventName] = [];`

`}`

`// Add the supplied callback function to the list associated to the specific`

`// event name`

`events[eventName].push(callback);`

`},`

`// Define the unsubscribe() method, which removes a given function from the list of`

`// functions to be executed when the event by the supplied name is triggered`

`unsubscribe: function(eventName, callback) {`

`var index = 0,`

`length = 0;`

`if (events.hasOwnProperty(eventName)) {`

`length = events[eventName].length;`

`// Cycle through the stored functions for the given event name and remove the`

`// function matching that supplied from the list`

`for (; index < length; index++) {`

`if (events[eventName][index] === callback) {`

`events[eventName].splice(index, 1);`

`break;`

`}`

`}`

`}`

`},`

`// Define the publish() method, which executes all functions associated with the given`

`// event name in turn, passing to each the same optional data passed as arguments to`

`// the method`

`publish: function(eventName) {`

`// Store all parameters but the first passed to this function as an array`

`var data = Array.prototype.slice.call(arguments, 1),`

`index = 0,`

`length = 0;`

`if (events.hasOwnProperty(eventName)) {`

`length = events[eventName].length;`

`// Cycle through all of the functions associated with the given event name and`

`// execute them each in turn, passing along any supplied parameters`

`for (; index < length; index++) {`

`events[eventName][index].apply(this, data);`

`}`

`}`

`}`

`};`

`}());`

清单 7-7 中的代码演示了如何使用清单 7-6 中给出的观察者模式的`publish()`、`subscribe()`和`unsubscribe()`方法。假设它运行在一个 HTML 页面的上下文中，该页面包含一个具有有效`action`属性的`<form id=` `"my-form"` `>`标签，并且包含几个表示表单字段的`<input type=` `"text"` `>`标签。

清单 7-7。正在使用的观察者模式

`// Define a module for Ajax communication, with a dependency on the observer object`

`// from Listing 7-6`

`(function(observer) {`

`// Define a function for performing an Ajax POST based on a supplied URL, form-encoded data`

`// string, and a callback function to execute once a response has been received from`

`// the server`

`function ajaxPost(url, data, callback) {`

`var xhr = new XMLHttpRequest(),`

`STATE_LOADED = 4,`

`STATUS_OK = 200;`

`xhr.onreadystatechange = function() {`

`if (xhr.readyState !== STATE_LOADED) {`

`return;`

`}`

`if (xhr.status === STATUS_OK) {`

`// Execute the supplied callback function once a successful response has been`

`// received from the server`

`callback(xhr.responseText);`

`}`

`};`

`xhr.open("POST", url);`

`// Inform the server that we will be sending form-encoded data, where names and values`

`// are separated by the equals sign (=) character, and name/value pairs are separated by`

`// the ampersand (&) character`

`xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");`

`// POST the data to the server`

`xhr.send(data);`

`}`

`// Subscribe to the global, custom "form-submit" event and, when this event is triggered by`

`// another module in the code base, make a Ajax POST request to the server using the`

`// supplied URL and data. Trigger the "ajax-response" event when complete, passing in the`

`// server's response from the Ajax call`

`observer.subscribe("form-submit", function(url, formData) {`

`ajaxPost(url, formData, function(response) {`

`// Trigger the global "ajax-response" event, passing along the data returned from`

`// the server during the Ajax POST`

`observer.publish("ajax-response", response);`

`});`

`});`

`}(observer));`

`// Define a module for handling submission of a simple form on the page containing text fields`

`// only with an ID of "my-form". Note that neither of the modules in this code listing reference`

`// each other, they only reference the observer object which handles all communication between`

`// modules in the system. Each module is said to be "loosely-coupled" as it has no hardcoded`

`// dependency on any other module`

`(function(observer) {`

`// Get a reference to a form on the current HTML page with ID "my-form"`

`var form = document.getElementById("my-form"),`

`// Get the "action" attribute value from the form, which will be the URL we perform an`

`// Ajax POST to`

`action = form.action,`

`data = [],`

`// Get a reference to all <input> fields within the form`

`fields = form.getElementsByTagName("input"),`

`index = 0,`

`length = fields.length,`

`field,`

`// Create a HTML <p> tag for use as a thank you message after form submission has`

`// taken place`

`thankYouMessage = document.createElement("p");`

`// Define a function to execute on submission of the form which uses the observer pattern to`

`// submit the form field data over Ajax`

`function onFormSubmit(e) {`

`// Prevent the default behavior of the submit event, meaning a normal in-page HTML form`

`// submission will not occur`

`e.preventDefault();`

`// Loop through all <input> tags on the page, creating an array of name/value pairs of`

`// the data entered into the form`

`for (; index < length; index++) {`

`field = fields[index];`

`data.push(escape(field.name) + "=" + escape(field.value));`

`}`

`// Trigger the global "form-submit" event on the observer object, passing it the URL to`

`// use for the Ajax POST and the form data to be sent. The Ajax communication module is`

`// listening for this event and will handle everything pertaining to the submission of`

`// that data to the server.`

`observer.publish("form-submit", action, data.join("&"));`

`}`

`// Wire up the onFormSubmit() function to the "submit" event of the form`

`form.addEventListener("submit", onFormSubmit, false);`

`// Subscribe to the global, custom "ajax-response" event, and use the server's response data`

`// sent along with the event to populate a Thank You message to display on the page beside`

`// the form`

`observer.subscribe("ajax-response", function(response) {`

`thankYouMessage.innerHTML = "Thank you for your form submission.<br>The server responded with: " + response;`

`form.parentNode.appendChild(thankYouMessage);`

`});`

`}(observer));`

observer 模式允许您删除代码中模块之间的硬编码引用，以维护自定义的系统范围的事件列表。随着代码库的增长和模块数量的增加，可以考虑使用这种模式来简化代码，并将模块彼此分离。请注意，如果在您的模块之一中发生错误，并且没有触发应该触发的事件，错误的来源可能不会立即显现出来，并且可能需要额外的调试。我建议在开发期间将您自己的调试日志记录添加到您的 observer 对象中，以允许您更容易地跟踪代码中的事件。

当您希望将模块松散地耦合在一起以减少杂乱无章的代码时，最好使用观察者模式。要在线阅读有关这种流行模式的更多信息，请查看以下资源:

*   “JavaScript 设计模式:观察者”，作者 Joseph Zimmerman，Adobe Developer Connection(通过 [`http://bit.ly/observer_pattern`](http://bit.ly/observer_pattern) )
*   罗布·多德森的《JavaScript 设计模式:观察者》(经由 [`http://bit.ly/observer_js`](http://bit.ly/observer_js) )

## 中介模式

中介模式是观察者模式的一种变体，在一个关键方面有所不同。观察者模式定义了一个全局对象，用于在整个系统中发布和订阅事件，而中介模式定义了用于特定目的的本地化对象，每个对象都有相同的`publish()`、`subscribe()`和`unsubscribe()`方法。随着您的代码库变得越来越大，observer 模式被证明会产生大量难以管理的事件，因此可以使用 mediator 模式将这个较大的事件列表分成较小的组。观察者模式是通过一个全局单例对象实现的，而中介者模式是通过使用一个“类”来实现的，因此可以根据需要创建尽可能多的对象实例来支持代码的特性。清单 7-8 显示了用来在你的代码中实现中介模式的“类”。注意与清单 7-6 中为实现观察者模式而创建的对象的相似之处。

清单 7-8。中介模式

`// Define a "class" containing publish(), subscribe(), and unsubscribe() methods to implement`

`// the mediator pattern. Note the similarilty to the observer pattern, the only difference is`

`// that we are creating a "class" here for creating object instances from later, and that we`

`// initialize the events array afresh for each object instance to avoid all instances sharing`

`// the same array in memory.`

`function Mediator() {`

`this.events = {};`

`}`

`Mediator.prototype.subscribe = function(eventName, callback) {`

`if (!this.events.hasOwnProperty(eventName)) {`

`this.events[eventName] = [];`

`}`

`this.events[eventName].push(callback);`

`};`

`Mediator.prototype.unsubscribe = function(eventName, callback) {`

`var index = 0,`

`length = 0;`

`if (this.events.hasOwnProperty(eventName)) {`

`length = this.events[eventName].length;`

`for (; index < length; index++) {`

`if (this.events[eventName][index] === callback) {`

`this.events[eventName].splice(index, 1);`

`break;`

`}`

`}`

`}`

`};`

`Mediator.prototype.publish = function(eventName)` `{`

`var data = Array.prototype.slice.call(arguments, 1),`

`index = 0,`

`length = 0;`

`if (this.events.hasOwnProperty(eventName)) {`

`length = this.events[eventName].length;`

`for (; index < length; index++) {`

`this.events[eventName][index].apply(this, data);`

`}`

`}`

`};`

清单 7-8 中的中介模式可以如清单 7-9 所示实现，创建中介对象来表示代码中的特定特性，并允许代码库中有模块。假设它运行在包含一个`<form id=` `"my-form"` `>`标签的 HTML 页面的上下文中，该标签包含几个表示表单字段的`<input type=` `"text"` `>`标签。

清单 7-9。正在使用的中介模式

`// Define two mediators for our code base, one pertaining to code for a forms feature, and`

`// another to enable a message logging feature.`

`// The formsMediator will feature two events: "form-submit", and "ajax-response", whereas`

`// the loggingMediator will feature three events, "log", "retrieve-log", and "log-retrieved".`

`// Note how we're able to separate events for different features in our code using the`

`// mediator pattern`

`var formsMediator = new Mediator(),`

`loggingMediator = new Mediator();`

`// Define a module for Ajax communication which POSTs some supplied data to the server when a`

`// "form-submit" event is triggered within the formsMediator`

`(function(formsMediator) {`

`function ajaxPost(url, data, callback) {`

`var xhr = new XMLHttpRequest(),`

`STATE_LOADED = 4,`

`STATUS_OK = 200;`

`xhr.onreadystatechange = function() {`

`if (xhr.readyState !== STATE_LOADED) {`

`return;`

`}`

`if (xhr.status === STATUS_OK) {`

`callback(xhr.responseText);`

`}`

`};`

`xhr.open("POST", url);`

`xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");`

`xhr.send(data);`

`}`

`formsMediator.subscribe("form-submit", function(url, formData) {`

`ajaxPost(url, formData, function(response) {`

`formsMediator.publish("ajax-response", response);`

`});`

`});`

`}(formsMediator));`

`// Define a module for handling submission of a simple form on the page containing text fields`

`// only with an ID of "my-form". When the form is submitted, the "form-submit" event is`

`// triggered within the formsMediator`

`(function(formsMediator) {`

`var form = document.getElementById("my-form"),`

`action = form.action,`

`data = [],`

`fields = form.getElementsByTagName("input"),`

`index = 0,`

`length = fields.length,`

`field,`

`thankYouMessage = document.createElement("p");`

`function onFormSubmit(e) {`

`e.preventDefault();`

`for (; index < length; index++) {`

`field = fields[index];`

`data.push(escape(field.name) + "=" + escape(field.value));`

`}`

`formsMediator.publish("form-submit", action, data.join("&"));`

`}`

`form.addEventListener("submit", onFormSubmit, false);`

`formsMediator.subscribe("ajax-response", function(response) {`

`thankYouMessage.innerHTML = "Thank you for your form submission.<br>The server responded with: " + response;`

`form.parentNode.appendChild(thankYouMessage);`

`});`

`}(formsMediator));`

`// Define a module for logging messages within the system to aid with debugging of issues that`

`// might occur. Uses the loggingMediator to separate the logging feature of the code base`

`// separate from that handling the form submission with the formsMediator`

`(function(loggingMediator) {`

`// Create an array to store the logs`

`var logs = [];`

`// When the "log" event is triggered on the loggingMediator, add an object to the logs`

`// containing a supplied message and the date / time that the message was received at`

`loggingMediator.subscribe("log", function(message) {`

`logs.push({`

`message: message,`

`date: new Date()`

`});`

`});`

`// When the "retrieve-log" event is triggered on the loggingMediator, trigger the`

`// "log-retrieved" event, passing along the current state of the stored logs`

`loggingMediator.subscribe("retrieve-log", function() {`

`loggingMediator.publish("log-retrieved", logs);`

`});`

`}(loggingMediator));`

`// Define a module which allows the stored logs in the loggingMediator to be displayed on screen`

`(function(loggingMediator) {`

`// Create a button which, when clicked, will display the current state of the log`

`var button = document.createElement("button");`

`button.innerHTML = "Show logs";`

`button.addEventListener("click", function() {`

`// Trigger the "retrieve-log" event within the loggingMediator. This triggers the`

`// "log-retrieved" event, passing along the current state of the logs`

`loggingMediator.publish("retrieve-log");`

`}, false);`

`// When the "log-retrieved" event occurs, display the logs on screen`

`loggingMediator.subscribe("log-retrieved", function(logs) {`

`var index = 0,`

`length = logs.length,`

`ulTag = document.createElement("ul"),`

`liTag = document.createElement("li"),`

`listItem;`

`// Loop through each log in the list of logs, rendering the date / time and message`

`// stored within a <li> tag`

`for (; index < length; index++) {`

`listItem = liTag.cloneNode(false);`

`listItem.innerHTML = logs[index].date.toUTCString() + ": " + logs[index].message;`

`ulTag.appendChild(listItem);`

`}`

`// Add the <ul> tag containing all the <li> tags representing the log data to the bottom`

`// of the page`

`document.body.appendChild(ulTag);`

`});`

`// Add the button to the bottom of the current page`

`document.body.appendChild(button);`

`}(loggingMediator));`

`// Define a module which logs events that occur within the formsMediator. This is the only`

`// module in this example to use more than one mediator`

`(function(formsMediator, loggingMediator) {`

`// Use the loggingMediator's "log" events to log the URL the form is submitted to when the`

`// "form-submit" event is triggered within the formsMediator`

`formsMediator.subscribe("form-submit", function(url) {`

`loggingMediator.publish("log", "Form submitted to " + url);`

`});`

`// Log the response from the server that is supplied when the "ajax-response" event is`

`// triggered within the formsMediator`

`formsMediator.subscribe("ajax-response", function(response) {`

`loggingMediator.publish("log", "The server responded to an Ajax call with: " + response);`

`});`

`}(formsMediator, loggingMediator));`

随着代码库的增长，您可能会发现从观察者模式转移到中介者模式是有意义的，这样可以将系统的事件组织成更易于管理的特性。

当您希望在一个非常大的代码库中将模块松散地耦合在一起时，最好使用 mediator 模式，如果使用 observer 模式，要处理的事件数量将会非常多。要了解有关中介模式的更多信息，请查看以下在线资源:

*   HB Stone 的《JavaScript 设计模式:中介者》(via[`bit . ly/Mediator _ pattern`](http://bit.ly/mediator_pattern)
*   Addy Osmani 的《大规模 JavaScript 应用架构的模式:中介者》(via [`http://bit.ly/mediator_js`](http://bit.ly/mediator_js) )

## 纪念品图案

memento 模式定义了对象数据在存储器中以静态形式的存储，使得它可以在代码执行过程中的稍后时间被恢复；这就好像您可以在任何时候拍摄一个对象的快照，然后您可以恢复它。清单 7-10 显示了一个简单的“类”,通过将对象的快照存储为 JSON 格式的字符串表示，并提供存储和恢复原始 JavaScript 对象的方法，可以用来实现这种模式。

清单 7-10。纪念品图案

`// Define a simple "class" to be used to implement the memento pattern. It can be used to`

`// provide the ability to save and restore a snapshot of an object in memory.`

`// Certain older browsers (e.g. Internet Explorer 7) do not support the JSON.stringify() and`

`// JSON.parse() methods natively. For these, you should include Doug Crockford's json2.js`

`// library found at`[`https://github.com/douglascrockford/JSON-js`](https://github.com/douglascrockford/JSON-js)

`function Memento() {`

`// Define an object in memory to store snapshots of other objects under a specified key`

`this.storage = {};`

`}`

`// Define a method to save the state of any object under a specified key`

`Memento.prototype.saveState = function(key, obj) {`

`// Convert the supplied object to a string representation in JSON format`

`this.storage[key] = JSON.stringify(obj);`

`};`

`// Define a method to restore and return the state of any object stored under a specified key`

`Memento.prototype.restoreState = function(key) {`

`var output = {};`

`// If the supplied key exists, locate the object stored there`

`if (this.storage.hasOwnProperty(key)) {`

`output = this.storage[key];`

`// Convert the stored value from a JSON string to a proper object`

`output = JSON.parse(output)` `;`

`}`

`return output;`

`};`

清单 7-11 展示了清单 7-10 中 memento“class”的应用。

清单 7-11。正在使用的纪念品图案

`// Define an instance of a memento to allow us to save and restore the state of objects`

`var memento = new Memento(),`

`// Define an object whose state we wish to be able to save and restore`

`user = {`

`name: "Den Odell",`

`age: 35`

`};`

`// Save the current state of the user object using the memento`

`memento.saveState("user", user);`

`// Prove that the state of the object is save in JSON format by reading from the storage object`

`// of the memento directly`

`alert(memento.storage["user"]); // {"name":"Den Odell","age":35}`

`// Now change the values in the user object as you wish`

`user.name = "John Smith";`

`user.age = 21;`

`// Output the current state of the user object`

`alert(JSON.stringify(user)); // {"name":"John Smith","age":21}`

`// Whenever you wish to restore the last saved state of the user object, simply call the restoreState() method of the memento`

`user = memento.restoreState("user");`

`// Output the new value of the user object, which has been restored to its last saved state`

`alert(JSON.stringify(user)); // {"name":"Den Odell","age":35}`

当您需要在应用执行的特定时刻存储和恢复应用中对象的快照时，最好使用 memento 模式。要在线阅读有关 memento 模式的更多信息，请查看以下资源:

*   DoFactory 上的“JavaScript Memento 设计模式”(通过 [`http://bit.ly/memento_pattern`](http://bit.ly/memento_pattern) )
*   维基百科上的“纪念模式”(通过[`bit . ly/Memento _ wiki`](http://bit.ly/memento_wiki))

## 承诺模式

当处理异步函数时，通常会将回调函数传递给这样的函数。该函数在完成工作后，将代表我们执行回调函数。这正如我们所希望的那样工作；唯一的问题是，它可能会创建更难阅读、更模糊的代码——您必须知道调用的函数是异步函数，传递给它的函数被用作回调函数。如果您希望在执行回调之前等待几个异步函数的结果完成，这会使结果代码更加模糊，难以理解。进入 promises 模式，这是一个创建于 20 世纪 70 年代的设计模式，但在 CommonJS 小组( [`http://bit.ly/common_js`](http://bit.ly/common_js) )的工作中针对 JavaScript 进行了更新。它定义了一种从异步调用返回承诺的方法，然后可以将该方法与对另一个函数的调用链接起来，该函数只有在承诺完成时才会执行，这发生在异步调用完成时。这样做的好处是确保回调与异步函数的调用充分分离，从而提高代码的清晰度，使代码更具可读性，从而更易于理解和维护。

承诺在 JavaScript 中表现为包含一个`then()`方法的对象实例，一旦相关的异步函数完成执行，就会执行该方法。考虑一个简单的 Ajax 调用，它需要一个回调函数作为第二个参数，执行如下:

`ajaxGet("/my-url", function(response) {`

`// Do something with response`

`}).`

使用 promises 模式，对同一个 Ajax 调用生成的 JavaScript 如下所示:

`ajaxGet("/my-url").then(function(response) {`

`// Do something with response`

`});`

您可能认为这两者之间没有什么区别，但事实上后者更加清晰:它清楚地告诉我们，一旦第一个函数完成，第二个函数将会执行，而这仅仅是暗示了前者的情况。一旦与多个异步调用一起使用，promises 模式比使用回调的等价代码更加清晰。例如，考虑下面的代码，它对一个 URL 进行 Ajax 调用，然后对另一个 URL 进行第二次 Ajax 调用:

`ajaxGet("/my-url", function() {`

`ajaxGet("/my-other-url", function() {`

`// Do something`

`});`

`});`

使用 promises 模式，这段代码被简化为更容易理解的代码，并且避免了嵌套代码的层次，这种层次在链中的异步调用越多，就会变得越极端:

`ajaxGet("/my-url").then(ajaxGet("/my-other-url")).then(function() {`

`// Do something`

`});`

当在标准 JavaScript 中发生了大量同步异步调用之后，试图执行单个回调时，事情会变得更加复杂。使用 promises 模式，您可以简单地将一个承诺数组传递给它的`all()`方法，它将同时执行每个承诺，当数组中的每个方法都实现了它自己的承诺时，返回一个承诺，如下所示:

`Promise.all([ajaxGet("/my-url"), ajaxGet("/my-other-url")]).then(function() {`

`// Do something with the data returned from both calls`

`});`

清单 7-12 显示了 JavaScript 中表示承诺的“类”。我在 [`http://bit.ly/js_promises`](http://bit.ly/js_promises) 的 GitHub 项目中管理这个代码的独立版本，你可以在你的项目中自由使用。

清单 7-12。承诺模式

`// Define a "class" representing a promise, allowing readable and understandable code to be`

`// written to support asynchronous methods and their callbacks. Instances created from this`

`// "class" adhere to the Promises/A+ specification detailed at`[`http://promisesaplus.com`](http://promisesaplus.com/)

`// pass all the official unit tests found at`[`https://github.com/promises-aplus/promises-tests`](https://github.com/promises-aplus/promises-tests)

`// which prove compliance of this specification.`

`var Promise = (function() {`

`// Define the three possible states a promise can take - "pending" - the default value`

`// meaning it has not resolved yet, "fulfilled" - meaning the promise has resolved`

`// successfully, and "rejected" - meaning the promise has failed and an error has occurred`

`var state = {`

`PENDING: "pending",`

`FULFILLED: "fulfilled",`

`REJECTED: "rejected"`

`};`

`// Define the "class" to represent a promise. If an asynchronous function is passed in at`

`// the point of instantiation, it will be executed immediately`

`function Promise(asyncFunction) {`

`var that = this;`

`// Define a property to represent the current state of the promise, set to "pending" by`

`// default`

`this.state = state.PENDING;`

`// Define a property to be used to store a list of callback functions to call once the`

`// asynchronous method has completed execution`

`this.callbacks = [];`

`// Define a property to store the value returned by the asynchronous method represented`

`// by this promise`

`this.value = null;`

`// Define a property to store the details of any error that occurs as a result of`

`// executing the asynchronous method`

`this.error = null;`

`// Define two functions which will be passed to the asynchronous function`

`// represented by this promise. The first will be executed if the asynchronous`

`// function executed successfully, the second will be executed if the execution`

`// failed in some way`

`function success(value) {`

`// Executes the resolve() method of this promise, which will ensure that any`

`// functions linked to this promise to be executed once its asynchronous method`

`// has executed successfully is executed at this point`

`that.resolve(value);`

`}`

`function failure(reason) {`

`// Executes the reject() method of this promise, which will execute any`

`// linked callback functions for displaying or handling errors. Any furthe` `r`

`// associated promises chained to this one will not be executed.`

`that.reject(reason);`

`}`

`// If an asynchronous function is passed to this promise at instantiation, it is`

`// executed immediately, and the success() and failure() functions defined above`

`// are passed in as function parameters. The asynchronous function must ensure it`

`// executes the most appropriate of these two functions depending on the outcome`

`// of the behaviour it is attempting to perform`

`if (typeof asyncFunction === "function") {`

`asyncFunction(success, failure);`

`}`

`}`

`// Define a then() method, the crux of the Promises/A+ spec, which allows callbacks to`

`// be associated to the result of the asynchronous function's execution depending on`

`// whether that function completed its task successfully or not. It allows chaining of`

`// promises to each other to allow further asynchronous functions to be executed at`

`// the point at which the current one is completed successfully`

`Promise.prototype.then = function(onFulfilled, onRejected) {`

`// Create a new promise (and return it at the end of this method) to allow for`

`// chaining of calls to then()`

`var promise = new Promise(),`

`// Define a callback object to be stored in this promise and associate the new`

`// promise instance to it to act as the context of any callback methods`

`callback = {`

`promise: promise`

`};`

`// If a function was provided to be executed on successful completion of the`

`// asynchronous function's action, store that function in the callback object`

`// together with its newly created promise as context`

`if (typeof onFulfilled === "function") {`

`callback.fulfill = onFulfilled;`

`}`

`// If a function was provided to be executed on unsuccessful completion of the`

`// asynchronous function's action, store that function in the callback object`

`// together with the new context promise`

`if (typeof onRejected === "function") {`

`callback.reject = onRejected;`

`}`

`// Add the callback object to the list of callbacks`

`this.callbacks.push(callback);`

`// Attempt to execute the stored callbacks (will only do this if the asynchronous`

`// function has completed execution by this point - if not, it will be called at`

`// such time as it has by other code in the "class")`

`this.executeCallbacks();`

`// Return the newly created promise, to allow for chaining of other asynchronous`

`// functions through repeated calls to the then() method`

`return promise;`

`};`

`// Define a method to execute any callbacks associated with this promise if the`

`// associated asynchronous function has completed execution`

`Promise.prototype.executeCallbacks = function() {`

`var that = this,`

`value,`

`callback;`

`// Define two functions to use as defaults to execute if an equivalent function has`

`// not been stored in the list of callbacks tied to this promise`

`function fulfill(value) {`

`return value;`

`}`

`function reject(reason) {`

`throw reason;`

`}`

`// Only execute the callbacks if the promise is not in its pending state, i.e. that`

`// the asynchronous function has completed execution`

`if (this.state !== state.PENDING) {`

`// Point 2.2.4 of the Promises/A+ spec dictates that callback functions should`

`// be executed asynchronously, outside of the flow of any other calls to then()`

`// which might take place. This ensures the whole chain of promises is in place`

`// before calls to the callbacks take place. Using a setTimeout with a delay of`

`// 0 milliseconds gives the JavaScript engine a split second to complete the`

`// process of going through the promise chain before any callbacks are run.`

`// Browsers have a minimum delay value possible for a setTimeout call so in`

`// reality the callbacks will be executed after, typically, 4 milliseconds`

`setTimeout(function() {`

`// Loop through all the callbacks associated with this promise and execute`

`// them each in turn, selecting the callback's fulfill method if the promise`

`// was fulfilled (by the asynchronous function completing execution`

`// successfully), or its reject method if the function returned an error`

`// during execution`

`while(that.callbacks.length) {`

`callback = that.callbacks.shift();`

`// Wrap the execution of the callback in a try/catch block, in case it`

`// throws an error. We don't want the promise chain to stop executing if`

`// an error is thrown, rather we want to reject the promise, allowing`

`// the calling code to handle the error itself`

`try {`

`// Execute the appropriate callback method based on the state of`

`// the promise. If no callback method has been associated, fall`

`// back to the default fulfill() and reject() functions defined at`

`// the top of the executeCallbacks() method, above`

`if (that.state === state.FULFILLED) {`

`value = (callback.fulfill || fulfill)(that.value);`

`} else {`

`value = (callback.reject || reject)(that.error);`

`}`

`// Pass the result of executing the callback function to the`

`// resolve() method, which will either mark the promise as fulfilled`

`// or continue to further execute chained calls to the then() method`

`callback.promise.resolve(value);`

`} catch (reason) {`

`// If an error is thrown by the callback`

`callback.promise.reject(reason);`

`}`

`}`

`}, 0);`

`}`

`};`

`// The fulfill() method will mark this promise as fulfilled provided it has not already`

`// been fulfilled or rejected before. Any associated callbacks will be executed at`

`// this point`

`Promise.prototype.fulfill = function(value) {`

`// Only transition the promise to the fulfilled state if it is still in the pending`

`// state, and a value is passed to this method when it is executed`

`if (this.state === state.PENDING && arguments.length) {`

`this.state = state.FULFILLED;`

`this.value = value;`

`this.executeCallbacks();`

`}`

`};`

`// The reject() method will mark this promise as rejected provided it has not already`

`// been fulfilled or rejected before. Any associated callbacks will be executed at`

`// this point`

`Promise.prototype.reject = function(reason) {`

`// Only transition the promise to the rejected state if it is still in the pending`

`// state, and a value is passed to this method when it is executed`

`if (this.state === state.PENDING && arguments.length) {`

`this.state = state.REJECTED;`

`this.error = reason;`

`this.executeCallbacks();`

`}`

`};`

`// The resolve() method takes the return value from a successfull call to a promise's`

`// fulfill() callback and uses it to fulfill the promise if it is the last promise in`

`// a chain of then() method calls. If it is not the last promise, it continues down`

`// the promise chain, recursively fulfilling and rejecting the linked promises as`

`// appropriate`

`Promise.prototype.resolve = function(value) {`

`var promise = this,`

`// Detect the type of the value returned from the fulfill() callback method. If`

`// this is the last promise in a chain, this should be the result of executing`

`// the asynchronous function itself. If this promise has other chained promises`

`// then the value passed to this method will contain another promise which will`

`// call the resolve() method again, recursively`

`valueIsThisPromise = promise === value,`

`valueIsAPromise = value && value.constructor === Promise,`

`// The term "thenable" refers to an object that looks like a promise in that it`

`// contains a then() method of its own, yet isn't an instance of this Promise`

`// "class" - useful for connecting promises created by other implementations of`

`// the Promises/A+ spec together`

`valueIsThenable = value && (typeof value === "object" || typeof value === "function"),`

`isExecuted = false,`

`then;`

`// Reject this promise if the value passed to this method represents the same`

`// promise represented here - otherwise we could potentially get stuck in a loop`

`if (valueIsThisPromise) {`

`// The Promises/A+ spec dictates that should this promise be the same as the`

`// one passed to this method, then a TypeError should be passed to the reject()`

`// method, effectively stopping execution of further promises in the chain`

`promise.reject(new TypeError());`

`// If the value passed to the resolve() method is another instance of this Promise`

`// "class", then either fulfill or reject the current promise based on the state of`

`// the provided promise`

`} else if (valueIsAPromise) {`

`// If the promise passed into this method has already been fulfilled or`

`// rejected, pass on the value or error contained within it to this promise`

`if (value.state === state.FULFILLED) {`

`promise.fulfill(value.value);`

`} else if (value.state === state.REJECTED) {`

`promise.reject(value.error);`

`// If the promise passed into this method hasn't yet been fulfilled or rejected,`

`// execute its then() method to ensure the current promise will get resolved`

`// or rejected along with that promise once it has completed execution of its`

`// asynchronous function`

`} else {`

`value.then(function(value) {`

`promise.resolve(value);`

`}, function(reason) {`

`promise.reject(reason);`

`});`

`}`

`// If the value passed to the resolve() method is not an instance of this Promise`

`// "class" but resembles a promise in that it is an object containing its own`

`// then() method, then execute its then() method, fulfilling or rejecting the`

`// current promise based on the state of this promise. This comes in useful when`

`// attempting to connect promises created with other implementations of the same`

`// spec together with this one`

`} else if (valueIsThenable) {`

`// Wrap execution in a try/catch block in case an error is thrown in the`

`// underlying code of the other promise implementation`

`try {`

`then = value.then;`

`// If the object stored in the value variable contains a then() method,`

`// execute it to ensure the current promise gets fulfilled or rejected when`

`// that promise does`

`if (typeof then === "function") {`

`then.call(value, function(successValue) {`

`if (!isExecuted) {`

`isExecuted = true;`

`promise.resolve(successValue);`

`}`

`}, function(reason) {`

`if (!isExecuted) {`

`isExecuted = true;`

`promise.reject(reason);`

`}`

`});`

`} else {`

`promise.fulfill(value);`

`}`

`} catch (reason) {`

`if (!isExecuted) {`

`isExecuted = true;`

`promise.reject(reason);`

`}`

`}`

`// If the value passed to the resolve() method is not a promise, then fulfill the`

`// current promise using its value. Any associated callbacks will then be executed`

`} else {`

`promise.fulfill(value);`

`}`

`};`

`// Add a bonus method, Promise.all(), which isn't part of the Promises/A+ spec, but is part`

`// of the spec for ECMAScript 6 Promises, which bring the benefits of promises straight into`

`// the JavaScript language itself.`

`//`

`// The method accepts an array of promises, each representing an asynchronous function,`

`// which are executed simultaneously, and returns a single promise, allowing a single`

`// then() method to be executed at such point all the supplied promsies are fulfilled. The`

`// value passed on fulfillment contains an array of all the returned values of the`

`// individual promises, in the same order as the promises in the original array passed to`

`// this method`

`Promise.all = function(promises) {`

`var index = 0,`

`promiseCount = promises.length;`

`// Return a single promise representing all the promises supplied to this method. It`

`// will be fulfilled as soon as every one of the supplied promises have been fulfilled.`

`return new Promise(function(fulfill, reject) {`

`var promise,`

`results = [],`

`resultsCount = 0;`

`// Execute an onSuccess() function each time one of the supplied promises is`

`// fulfilled, adding its resulting value to an array in the same index position as`

`// the promise was in the original array`

`function onSuccess(result, index) {`

`results[index] = result;`

`resultsCount++;`

`// If we have collected the results for all of the promises, then fulfill the`

`// current single promise, passing across the array of fulfilled values from`

`// the individual promises`

`if (resultsCount === promiseCount) {`

`fulfill(results);`

`}`

`}`

`// If any of the supplied promises are rejected, then reject the current promise`

`function onError(error) {`

`reject(error);`

`}`

`// Resolve a given promise, executing onSuccess() if fulfilled, or onError() if not`

`function resolvePromise(index, promise) {`

`promise.then(function(value) {`

`onSuccess(value, index);`

`}, onError);`

`}`

`// Loop through all the promises supplied to this method, resolving each in turn`

`for (; index < promiseCount; index++) {`

`promise = promises[index];`

`resolvePromise(index, promise);`

`}`

`});`

`};`

`return Promise;`

`}());`

看一下清单 7-13，它展示了如何利用清单 7-12 中的`Promise`“class ”,在你的代码中创建和使用承诺的例子。

清单 7-13。正在使用的承诺模式

`// Define a variable to use as a counter further down in this code`

`var millisecondCount = 0;`

`// Define a method to get the data returned by a GET request to a given URL. Returns a promise`

`// to which callback functions can be hooked into using its then() method.`

`function ajaxGet(url) {`

`// Return a new promise, initializing it with the asynchronous function to perform the Ajax`

`// request. When the promise executes the function, it will pass in two function parameters,`

`// the first should be called by our code if and when the asynchronous request succeeds, and`

`// the second should be called if and when an error occurs in the execution of the`

`// asynchronous request.`

`return new Promise(function(fulfill, reject) {`

`var xhr = new XMLHttpRequest(),`

`STATE_LOADED = 4,`

`STATUS_OK = 200;`

`xhr.onreadystatechange = function() {`

`if (xhr.readyState !== STATE_LOADED) {`

`return;`

`}`

`// If the Ajax GET request returns data successfully, execute the fulfill method`

`if (xhr.status === STATUS_OK) {`

`fulfill(xhr.responseText);`

`// If the Ajax request does not return data successfully, execute the reject method`

`} else {`

`reject("For the URL '" + url + "', the server responded with: " + xhr.status);`

`}`

`};`

`// Perform the Ajax GET request`

`xhr.open("GET", url);`

`xhr.send();`

`});`

`}`

`// Define a method which waits a given number of milliseconds before continuing. Returns`

`// a promise.`

`function wait(milliseconds) {`

`return new Promise(function(fulfill, reject) {`

`// If the value provided for milliseconds is a number greater than 0, call the`

`// setTimeout method to wait that number of milliseconds before executing the fulfill`

`// method`

`if (milliseconds && typeof milliseconds === "number" && milliseconds > 0) {`

`setTimeout(function() {`

`fulfill(milliseconds);`

`}, milliseconds);`

`// If the value provided for milliseconds is not a number or is less than or equal to`

`// 0, then reject the promise immediately`

`} else {`

`reject("Not an acceptable value provided for milliseconds: " + milliseconds);`

`}`

`});`

`}`

`// Define two functions for use if a particular promise is fulfilled or rejected, respectively`

`function onSuccess(milliseconds) {`

`alert(milliseconds + "ms passed");`

`}`

`function onError(error) {`

`alert(error);`

`}`

`// EXAMPLE 1: Success`

`// Execute the wait() function with a value we know will cause it to succeed, and show that`

`// the first of the two supplied functions to the then() method is executed`

`wait(500).then(onSuccess, onError); // After 0.5 seconds, outputs: "500ms passed"`

`// EXAMPLE 2: Error`

`// Execute the wait() function with a value we know will cause it to error. Because this`

`// rejects immediately, this will alert the user before the result of example 1 is known`

`wait(0).then(onSuccess, onError); // "Not an acceptable value provided for milliseconds: 0"`

`// EXAMPLE 3: Chaining`

`// Multiple promises can be chained together using the then() method which allows operations to`

`// be executed in order once the result of the execution of the previous asynchronous function`

`// is known. This considerably simplifies the nesting of callbacks which would be necessary`

`// without the use of promises.`

`wait(1000)`

`.then(function(milliseconds) {`

`// After a delay of 1 second, increment the counter by the number of milliseconds`

`// passed into the function parameter (in this case, 1000)`

`millisecondCount += milliseconds;`

`// Returning a promise in this function means that the operation indicated by that`

`// promise will be executed once the previous operation is complete`

`return wait(1600);`

`})`

`.then(function(milliseconds) {`

`// By this point, 2600 milliseconds have passed, and this is stored in our counter`

`// variable`

`millisecondCount += milliseconds;`

`// Return another promise, indicating that a delay of 400 milliseconds should now`

`// take place before the function specified in the following then() statement is`

`// executed`

`return wait(400);`

`})`

`.then(function(milliseconds) {`

`// Increment the counter by the 400 milliseconds just passed, making its total 3000`

`millisecondCount += milliseconds;`

`// Finally, output the combined value of the counter, which indicates the number of`

`// milliseconds passed since the first operation in this chain began`

`alert(millisecondCount + "ms passed"); // After 3 seconds, outputs: "3000ms passed"`

`});`

`// EXAMPLE 4: Multiple Promises`

`// Different promises can be chained together, since as in this example, which gets a page by`

`// the URL /page1.html (assuming it exists on the server), then waits 3 seconds before getting`

`// another page by the URL /page2.html (again, assuming it exists).`

`ajaxGet("/page1.html")`

`.then(function() {`

`return wait(3000);`

`})`

`.then(function() {`

`return ajaxGet("/page2.html");`

`})`

`.then(function() {`

`// This alert will fire only if both /page1.html and /page2.html exist and can`

`// be accessed`

`alert("/page1.html and /page2.html received, with a 3s gap between requests");`

`});`

`// EXAMPLE 5: Simultaneous Promises`

`// The Promise.all() method accepts an array of promises which will be resolved simultaneously,`

`// passing the results as an array to the success function passed to its then() method. Get`

`// both /page1.html and /page2.html simultaneously, and when they are both complete, execute`

`// the success callback function with the contents of both files in the array parameter passed`

`// into this function, in the same order as in the array of promises. If any of the supplied`

`// promises fails, the error callback function will be executed, with the detail of the first`

`// error that occurred passed into this function parameter.`

`Promise.all([ajaxGet("/page1.html"), ajaxGet("/page2.html")])`

`.then(function(files) {`

`alert("/page1.html = " + files[0].length + " bytes. /page2.html = " + files[1].length + " bytes.");`

`}, function(error) {`

`alert(error);`

`});`

当代码中出现许多异步操作，导致嵌套回调函数混乱时，最好使用 promises 模式。它允许将回调函数链接到异步调用，使代码更容易理解，因此更容易开发和维护。要在线阅读有关承诺模式的更多信息，请查看以下资源:

*   “Promises/A+ Specification”由 Promises/A+组织(通过 [`http://bit.ly/promises_aplus`](http://bit.ly/promises_aplus) )提供
*   里斯·布雷特-鲍恩的《承诺模式》(via [`http://bit.ly/promises_js`](http://bit.ly/promises_js) )

## 战略模式

策略模式适用于这样的情况:您有一个包含大型条件语句(`if` … `else`或`switch`)的“类”，其中每个选项都会导致该“类”的特定行为以不同的方式改变。与其管理一个大的条件语句，不如将每个行为拆分成单独的对象，每个对象称为一个策略。在任何时候，只有其中一个应用于原始对象，称为客户端。拥有多个策略对象也有助于提高代码的质量，因为策略对象可以彼此独立地进行单元测试。

清单 7-14 显示了一个应用策略模式的“类”的例子——它包含了许多条件语句，这些语句改变了从它创建的对象的一个非常特殊的行为。

清单 7-14。将策略模式应用于的代码已经成熟

`// Define a "class" representing a form field in an HTML page`

`function FormField(type, displayText){`

`this.type = type || "text";`

`this.displayText = displayText || "";`

`// Create a new <input> tag, setting its field type to the value supplied upon instantiation`

`this.element = document.createElement("input");`

`this.element.setAttribute("type", this.type);`

`// Create a new <label> tag, setting its text to the value supplied upon instantiation`

`this.label = document.createElement("label");`

`this.label.innerHTML = this.displayText;`

`// Add the <label> and <input> tags to the current page`

`document.body.appendChild(this.label);`

`document.body.appendChild(this.element);`

`}`

`// Give each form field object instance three methods`

`FormField.prototype = {`

`// Return the current value stored in the form field`

`getValue: function() {`

`return this.element.value;`

`},`

`// Set a new value for the form field`

`setValue: function(value) {`

`this.element.value = value;`

`},`

`// Return a true / false value depending on whether the value in the form field is valid`

`isValid: function() {`

`var isValid = false,`

`value;`

`// If this is a <input type="text"> field, it is considered valid if its value is not`

`// an empty string`

`if (this.type === "text") {`

`isValid = this.getValue() !== "";`

`// If this is a <input type="email"> field, it is considered valid if its value is not`

`// an empty string, contains the "@" character and contains the "." character after "@"`

`} else if (this.type === "email") {`

`value = this.getValue();`

`isValid = value !== "" && value.indexOf("@") > 0 && value.indexOf(".",             value.indexOf("@")) > 0;`

`// If this is a <input type="number"> field, it is considered valid if its value is`

`// a number`

`} else if (this.type === "number") {`

`value = this.getValue();`

`isValid = !isNaN(parseInt(value, 10));`

`// This could go on a while as there are 24 possible <input> types in HTML5\. We need a`

`// way to simplify this to make it easier to understand and extend in future - this is`

`// where the strategy pattern comes into play, as shown in Listing 7-14`

`} else {`

`// etc.`

`}`

`return isValid;`

`}`

`};`

清单 7-15 中的代码展示了我们如何通过应用策略模式将清单 7-14 中的代码重构为一个更有效、更易于管理的结构。

清单 7-15。战略模式

`// Define a "class" representing a form field in an HTML page. Note a new object is passed into`

`// the third parameter at instantiation, containing a strategy object. This object contains a`

`// specific implementation of the isValid() method pertaining to the specific type of form field`

`// we are creating - for example, a "text" field would require an isValid() method that checks`

`// to see if the stored value is not an empty string, so we create an object containing this`

`// method and pass it in through the strategy object at instantiation time`

`function FormField(type, displayText, strategy){`

`this.type = type || "text";`

`this.displayText = displayText || "";`

`this.element = document.createElement("input");`

`this.element.setAttribute("type", this.type);`

`this.label = document.createElement("label");`

`this.label.innerHTML = this.displayText;`

`// Check to see if the strategy object passed in contains the isValid() method to use and,`

`// if so, store the stragety object for use when the isValid() method of this object is`

`// executed. If no strategy object is supplied, use a default`

`if (strategy && typeof strategy.isValid === "function") {`

`this.strategy = strategy;`

`} else {`

`this.strategy = {`

`isValid: function() {`

`return false;`

`}`

`};`

`}`

`document.body.appendChild(this.label);`

`document.body.appendChild(this.element);`

`}`

`FormField.prototype = {`

`getValue: function() {`

`return this.element.value;`

`},`

`setValue: function(value) {`

`this.element.value = value;`

`},`

`// Replace the previous isValid() method with one that simply calls the isValid() method`

`// provided by the stored strategy object - no more extensive if..else statements, making`

`// the code for this "class" much smaller and easier to manage`

`isValid: function() {`

`return this.strategy.isValid.call(this);`

`}`

`};`

`// Define three strategy objects for three different types of form field to be used with the`

`// FormField "class" when it is instantiated. Here we provide specific implementations for the`

`// isValid() method, but we could have extended these to include more methods and/or properties`

`// to meet our needs. In cases like this, we would have created a strategy "class" and created`

`// these objects as instances of that "class". Here we have simple objects so it is smarter to`

`// keep the code short and to the point`

`var textFieldStrategy = {`

`// Specific functionality for validation of a <input type="text"> field`

`isValid: function() {`

`return this.getValue() !== "";`

`}`

`},`

`emailFieldStrategy = {`

`// Specific functionality for validation of a <input type="email"> field`

`isValid: function() {`

`var value = this.getValue();`

`return value !== "" && value.indexOf("@") > 0 && value.indexOf(".",             value.indexOf("@")) > 0;`

`}`

`},`

`numberFieldStrategy = {`

`// Specific functionality for validation of a <input type="number"> field`

`isValid: function() {`

`var value = this.getValue();`

`return !isNaN(parseInt(value, 10));`

`}`

`};`

清单 7-15 中的代码可以如清单 7-16 所示使用。

清单 7-16。正在使用的策略模式

`// Create three form fields for our HTML page, each with different types. We pass in the type,`

`// the text for the associated <label> tag, and the strategy object associated with this field`

`// type to provide the required behavior for field value validation`

`var textField = new FormField("text", "First Name", textFieldStrategy),`

`emailField = new FormField("email", "Email", emailFieldStrategy),`

`numberField = new FormField("number", "Age", numberFieldStrategy);`

`// Set values for each form field we know will validate`

`textField.setValue("Den Odell");`

`emailField.setValue("denodell@me.com");`

`numberField.setValue(35);`

`// Check to see if the values in the fields validate correctly`

`alert(textField.isValid());   // true`

`alert(emailField.isValid());  // true`

`alert(numberField.isValid()); // true`

`// Change the values in the fields to ones we know will fail validation`

`textField.setValue("");`

`emailField.setValue("denodell");`

`numberField.setValue("Den Odell");`

`// Check to ensure the isValid() method is working correctly, reflecting the new field values`

`alert(textField.isValid());   // false`

`alert(emailField.isValid());  // false`

`alert(numberField.isValid()); // false`

当您需要管理大量条件逻辑来实现“类”中方法的行为时，最好使用策略模式要了解有关策略模式的更多信息，请查看以下在线资源:

*   迈克尔·索科尔的《JavaScript 中的策略设计模式》(经由 [`http://bit.ly/strategy_pattern`](http://bit.ly/strategy_pattern) )
*   迈克·彭尼斯的《JavaScript 中的策略模式》(经由 [`http://bit.ly/strategy_js`](http://bit.ly/strategy_js) )

## 摘要

在这一章中，我们已经看到了行为设计模式，你可以在你自己的 JavaScript 应用中使用这些模式来简化不同对象之间的通信。这些是 JavaScript 开发的瑞士军刀中的工具，但是像所有工具一样，您需要知道何时何地最好地使用它们。熟悉本章中的模式及其用例，并确保在代码中认识到需要使用设计模式之前，不要使用它。

在下一章中，我们将着眼于架构设计模式，它实际上是我们已经讨论过的现有设计模式的组合，用来解决大型 JavaScript 代码库中的特定问题。