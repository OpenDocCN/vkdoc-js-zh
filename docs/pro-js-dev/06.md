# 六、设计模式：结构型

在这一章中，我们将继续关注设计模式，重点是结构设计模式。我们在前一章中看到的创造性设计模式集中在对象创建上，而结构化设计模式帮助你将对象组合成一个更大、更结构化的代码库。它们是灵活的、可维护的、可扩展的，并且确保如果系统的一部分发生变化，您不需要完全重写其余部分来适应。结构化设计模式还可以用来帮助与其他代码结构进行交互，您需要在应用中轻松地使用这些代码结构。让我们一起来看看你可能会发现在你的代码中有用的八种结构设计模式，以及一些例子。

## 适配器模式

adapterpattern 是一种有用的设计模式，当您需要将两个或更多通常不会连接在一起的代码组件连接在一起时，可以使用它；类似地，当您开发的 API 被更新，不再以相同的方式调用时，它就变得有用了——提供了一个适配器来连接新旧版本，有助于 API 用户的迁移，他们可以利用您代码中的其他改进，而不会破坏他们的代码。清单 6-1 中的例子展示了如何使用这种模式为你的代码创建一个适配器来映射一个新的 API 接口到一个旧的接口。

清单 6-1。适配器模式

`// Imagine the following interface exists deep in your large code base for making Ajax requests`

`// over HTTP`

`var http = {`

`makeRequest: function(type, url, callback, data) {`

`var xhr = new XMLHttpRequest(),`

`STATE_LOADED = 4,`

`STATUS_OK = 200;`

`xhr.onreadystatechange = function() {`

`if (xhr.readyState !== STATE_LOADED) {`

`return;`

`}`

`if (xhr.status === STATUS_OK) {`

`callback(xhr.responseText);`

`}`

`};`

`xhr.open(type.toUpperCase(), url);`

`xhr.send(data);`

`}`

`};`

`// The http.makeRequest() method defined above could be called as follows, for getting and`

`// updating user data in a system for a user with an ID of "12345":`

`http.makeRequest("get", "/user/12345", function(response) {`

`alert("HTTP GET response received. User data: " + response);`

`});`

`http.makeRequest("post", "/user/12345", function(response) {`

`alert("HTTP POST response received. New user data: " + response);`

`}, "company=AKQA&name=Den%20Odell");`

`// Now imagine in a refactor of your project, you decide to introduce a new structure using a`

`// namespace and splitting out the makeRequest() method into separate methods for HTTP GET`

`// and POST requests`

`var myProject = {`

`data: {`

`ajax: (function() {`

`function createRequestObj(callback) {`

`var xhr = new XMLHttpRequest(),`

`STATE_LOADED = 4,`

`STATUS_OK = 200;`

`xhr.onreadystatechange = function() {`

`if (xhr.readyState !== STATE_LOADED) {`

`return;`

`}`

`if (xhr.status === STATUS_OK) {`

`callback(xhr.responseText);`

`}`

`};`

`return xhr;`

`}`

`return {`

`get: function(url, callback) {`

`var requestObj = createRequestObj(callback);`

`requestObj.open("GET", url);`

`requestObj.send();`

`},`

`post: function(url, data, callback) {`

`var requestObj = createRequestObj(callback);`

`requestObj.open("POST", url);`

`requestObj.send(data);`

`}`

`};`

`}())`

`}`

`};`

`// These new get() and post() methods could be called as follows:`

`myProject.data.ajax.get("/user/12345", function(response) {`

`alert("Refactored HTTP GET response received. User data: " + response);`

`});`

`myProject.data.ajax.post("/user/12345", "company=AKQA&name=Den%20Odell", function(response) {`

`alert("Refactored HTTP POST response received. New user data: " + response);`

`});`

`// To avoid rewriting every call to the http.makeRequest() method in the rest of your code`

`// base, you could create an adapter to map the old interface to the new methods. The adapter`

`// needs to take the same input parameters as the original method it is designed to replace,`

`// and calls the new methods internally instead`

`function httpToAjaxAdapter(type, url, callback, data) {`

`if (type.toLowerCase() === "get") {`

`myProject.data.ajax.get(url, callback);`

`} else if (type.toLowerCase() === "post") {`

`myProject.data.ajax.post(url, data, callback);`

`}`

`}`

`// Finaly, apply the adapter to replace the original method. It will then map the old`

`// interface to the new one without needing to rewrite the rest of your code at the same time`

`http.makeRequest = httpToAjaxAdapter;`

`// Use the new adapter in the same way as the original method - internally it will call the`

`// newer code, but externally it will appear identical to the old makeRequest() method`

`http.makeRequest("get", "/user/12345", function(response) {`

`alert("Adapter HTTP GET response received. User data: " + response);`

`});`

`http.makeRequest("post", "/user/12345", function(response) {`

`alert("Adapter HTTP POST response received. New user data: " + response);`

`}, "company=AKQA&name=Den%20Odell");`

适配器模式最适合在需要将本来不能组合在一起的代码连接在一起时使用，例如，当外部 API 被更新时——您创建一个适配器来将新方法映射到旧方法，以避免需要对依赖于这些方法的代码的其余部分进行更改。

要在线阅读有关适配器模式的更多信息，请查看以下资源:

*   “JavaScript 设计模式:适配器”，作者 Joseph Zimmerman，Adobe Developer Connection(通过 [`http://bit.ly/adapter_pattern`](http://bit.ly/adapter_pattern) )
*   维基百科上的“适配器设计模式”(via [`http://bit.ly/adapter_wiki`](http://bit.ly/adapter_wiki) )

## 复合模式

复合模式为一个或多个对象创建了一个界面，而最终用户不需要知道他们正在处理多少个对象。当你想简化其他人访问你的函数的方式时，它就派上用场了；无论是将单个对象还是一组对象传递给同一个方法，都没有区别。清单 6-2 显示了复合模式的一个简单例子，允许用户向一个或多个 DOM 节点添加类名，而不需要知道他们是否需要向方法传递一个或多个 DOM 节点。

清单 6-2。复合模式

`// Define a singleton containing methods to get references to page elements and to add`

`// class names to those elements`

`var elements = {`

`// Define a method to get DOM elements by tag name. If one element is found, it is`

`// returned as an individual node, or multiple elements are found, an array of those`

`// found elements are returned`

`get: function(tag) {`

`var elems = document.getElementsByTagName(tag),`

`elemsIndex = 0,`

`elemsLength = elems.length,`

`output = [];`

`// Convert the found elements structure into a standard array`

`for (; elemsIndex < elemsLength; elemsIndex++) {`

`output.push(elems[elemsIndex]);`

`}`

`// If one element is found, return that single element, otherwise return the array`

`// of found elements`

`return output.length === 1 ? output[0] : output;`

`},`

`// Define a composite method which adds an class name to one or more elements, regardless`

`// of how many are passed when it is executed`

`addClass: function(elems, newClassName) {`

`var elemIndex = 0,`

`elemLength = elems.length,`

`elem;`

`// Determine if the elements passed in are an array or a single object`

`if (Object.prototype.toString.call(elems) === "[object Array]") {`

`// If they are an array, loop through each elements and add the class name to each`

`for (; elemIndex < elemLength; elemIndex++) {`

`elem = elems[elemIndex];`

`elem.className += (elem.className === "" ? "" : " ") + newClassName;`

`}`

`} else {`

`// If a single element was passed in, add the class name value to it`

`elems.className += (elems.className === "" ? "" : " ") + newClassName;`

`}`

`}`

`};`

`// Use the elements.get() method to locate the single <body> element on the current page, and`

`// potentially numerous <a> elements`

`var body = elements.get("body"),`

`links = elements.get("a");`

`// The composite elements.addClass() method gives the same interface to single elements`

`// as it does to multiple elements, simplifying its use considerably`

`elements.addClass(body, "has-js");`

`elements.addClass(links, "custom-link");`

当您不希望与您的方法交互的开发人员担心有多少对象作为参数传递给它们，从而简化方法调用时，最好使用复合模式。

要在线阅读关于复合模式的更多信息，请查阅以下资源:

*   Joseph Zimmerman 在 Adobe Developer Connection 上发表的“JavaScript 设计模式:复合”(通过 [`http://bit.ly/composite_pattern`](http://bit.ly/composite_pattern) )
*   维基百科上的“复合模式”(via [`http://bit.ly/composite_wiki`](http://bit.ly/composite_wiki) )

## 装饰图案

装饰模式是一种扩展和定制从“类”创建的对象的方法和属性的方式，而不需要创建大量可能变得难以管理的子类。这是通过有效地将对象包装在另一个实现相同公共方法的对象中来实现的，其中相关方法根据我们试图增强的行为被覆盖。清单 6-3 中的代码展示了一个创建几个装饰器的例子，每个装饰器都用额外的属性和行为来扩充一个现有的对象。

清单 6-3。装饰图案

`var FormField = function(type, displayText){`

`this.type = type || "text";`

`this.displayText = displayText || "";`

`};`

`FormField.prototype = {`

`createElement: function() {`

`this.element = document.createElement("input");`

`this.element.setAttribute("type", this.type);`

`this.element.setAttribute("placeholder", this.displayText);`

`return this.element;`

`},`

`isValid: function() {`

`return this.element.value !== "";`

`}`

`};`

`// The form field deocorator, which implements the same public methods as FormField`

`var FormFieldDecorator = function(formField) {`

`this.formField = formField;`

`};`

`FormFieldDecorator.prototype = {`

`createElement: function() {`

`this.formField.createElement();`

`},`

`isValid: function() {`

`return this.formField.isValid();`

`}`

`};`

`var MaxLengthFieldDecorator = function(formField, maxLength) {`

`FormFieldDecorator.call(this, formField);`

`this.maxLength = maxLength || 100;`

`};`

`MaxLengthFieldDecorator.prototype = new FormFieldDecorator()` `;`

`MaxLengthFieldDecorator.prototype.createElement = function() {`

`var element = this.formField.createElement();`

`element.setAttribute("maxlength", this.maxLength);`

`return element;`

`};`

`var AutoCompleteFieldDecorator = function(formField, autocomplete) {`

`FormFieldDecorator.call(this, formField);`

`this.autocomplete = autocomplete || "on";`

`};`

`AutoCompleteFieldDecorator.prototype = new FormFieldDecorator();`

`AutoCompleteFieldDecorator.prototype.createElement = function() {`

`var element = this.formField.createElement();`

`element.setAttribute("autocomplete", this.autocomplete);`

`return element;`

`};`

清单 6-3 中创建的装饰器可以如清单 6-4 所示用于生成一个表示表单中表单字段的对象，使用这些装饰器而不是通过子类来扩充它的属性和行为。

清单 6-4。正在使用的装饰模式

`// Create an empty <form> tag and a new FormField object to represent`

`// a <input type="search"> field`

`var form = document.createElement("form"),`

`formField = new FormField("search", "Enter your search term");`

`// Extend the formField object using our decorators to add maxlength and autocomplete properties`

`// to the resulting form field element. Note how we pass the extended formField object into each`

`// decorator in turn, which extends it further.`

`formField = new MaxLengthFieldDecorator(formField, 255);`

`formField = new AutoCompleteFieldDecorator(formField, "off");`

`// Create the HTML form field element and add it to the <form> element`

`form.appendChild(formField.createElement());`

`// Add an event handler to the <form> tag's submit event, preventing the form from submitting if`

`// the form field we added contains no value`

`form.addEventListener("submit", function(e) {`

`// Stop the form from submitting`

`e.preventDefault();`

`// Test to see if our form field is valid, i.e. that it contains a value`

`if (formField.isValid()) {`

`// If it does, go ahead and submit the form`

`form.submit();`

`} else {`

`// If it doesn't, alert the user that something is wrong and they need to correct it`

`alert("Please correct the issues in the form field.");`

`}`

`}, false);`

`// Add the <form> field to the current page once it has loaded`

`window.addEventListener("load", function() {`

`document.body.appendChild(form);`

`}, false);`

当您需要快速简单地增加从一个“类”创建的对象实例的行为，而不必求助于从它创建一长串继承的子类时，最好使用装饰模式。要在线阅读关于装饰模式的更多信息，请查阅以下资源:

*   Addy Osmani 的《探索 JavaScript 中的装饰模式》(via [`http://bit.ly/decorator_pattern`](http://bit.ly/decorator_pattern) )
*   斯托扬·斯特凡诺夫关于多布斯博士的“JavaScript 中的装饰模式”(通过 [`http://bit.ly/decorator_js`](http://bit.ly/decorator_js) )

## 立面图案

外立面图案很常见；它只是编写一个函数来简化对一个或多个更大、可能更复杂的函数的访问。可能有人会说，任何简单地调用另一个函数的函数都是这种模式的一个例子，但是我发现最好是从简化一些原本需要多个步骤的事情的角度来考虑，或者提供一个访问更大系统的单点，这将使其他开发人员访问该系统更加容易。清单 6-5 中的代码演示了一个简单的外观，它提供了一个包装器来简化跨浏览器 Ajax 调用。

清单 6-5。立面图案

`// Define a function which acts as a façade to simplify and facilitate cross-browser Ajax calls,`

`// supporting browsers all the way back to Internet Explorer 5`

`function ajaxCall(type, url, callback, data) {`

`// Get a reference to an Ajax connection object relevant to the current browser`

`var xhr = (function() {`

`try {`

`// The standard method, used in all modern browsers`

`return new XMLHttpRequest();`

`}`

`catch(e) {}`

`// Older versions of Internet Explorer utilise an ActiveX object installed on the`

`// user's machine`

`try {`

`return new ActiveXObject("Msxml2.XMLHTTP.6.0");`

`}`

`catch(e) {}`

`try {`

`return new ActiveXObject("Msxml2.XMLHTTP.3.0");`

`}`

`catch(e) {}`

`try {`

`return new ActiveXObject("Microsoft.XMLHTTP");`

`}`

`catch(e) {}`

`// If no relevant Ajax connection object can be found, throw an error`

`throw new Error("Ajax not supported in this browser.");`

`}()),`

`STATE_LOADED = 4,`

`STATUS_OK = 200;`

`// Execute the given callback method once a succesful response is received from the server`

`xhr.onreadystatechange = function() {`

`if (xhr.readyState !== STATE_LOADED) {`

`return;`

`}`

`if (xhr.status === STATUS_OK) {`

`callback(xhr.responseText);`

`}`

`};`

`// Use the browser's Ajax connection object to make the relevant call to the given URL`

`xhr.open(type.toUpperCase(), url);`

`xhr.send(data);`

`}`

清单 6-5 中的外观模式可以用在你的代码中，如清单 6-6 所示，掩盖了跨浏览器 Ajax 操作背后的复杂性。

清单 6-6。正在使用的立面图案

`// The ajaxCall() facade function can make cross-browser Ajax calls as follows`

`ajaxCall("get", "/user/12345", function(response) {`

`alert("HTTP GET response received. User data: " + response);`

`});`

`ajaxCall("post", "/user/12345", function(response) {`

`alert("HTTP POST response received. New user data: " + response);`

`}, "company=AKQA&name=Den%20Odell");`

当您希望通过单个函数或方法来提供对一系列函数或方法调用的访问，以便简化代码库的其余部分，使其更容易遵循，因此将来更易于维护和扩展时，最好使用外观模式。要在线阅读有关外观模式的更多信息，请查看以下资源:

*   Joseph Zimmerman 在 Adobe Developer Connection 上的“JavaScript 设计模式:外观”(通过 [`http://bit.ly/facade_pattern`](http://bit.ly/facade_pattern) )
*   卡尔·丹利的“正面图案”(经由 [`http://bit.ly/facade_js`](http://bit.ly/facade_js) )

## 轻量级模式

flyweight 模式是一种优化模式；这对于创建大量相似对象的代码非常有用，否则这些对象会消耗大量内存。它用一些共享对象代替了大量的相似对象，使得代码更轻，性能更好；因此得名，它来自拳击界，指的是最轻重量级的运动员，那些最敏捷的运动员。清单 6-7 显示了一个例子，这个例子说明了 flyweight 模式旨在解决的一个问题，即对象的低效存储。

清单 6-7。低效的对象实例

`// Create a "class" to store data to related to employees working for one or more different`

`// companies`

`function Employee(data) {`

`// Represent an employee's ID within an organisation`

`this.employeeId = data.employeeId || 0;`

`// Represent an employee's social security number`

`this.ssId = data.ssId || "0000-000-0000";`

`// Represent an employee's name`

`this.name = data.name || "";`

`// Represent an employee's occupation`

`this.occupation = data.occupation || "";`

`// Represent an employee's company name, address and country`

`this.companyName = data.companyName || "";`

`this.companyAddress = data.companyAddress || "";`

`this.companyCountry = data.companyCountry || "";`

`}`

`// Create three methods to get the employee's name, occupation and company details from the`

`// stored object`

`Employee.prototype.getName = function() {`

`return this.name;`

`};`

`Employee.prototype.getOccupation = function() {`

`return this.occupation;`

`};`

`Employee.prototype.getCompany = function() {`

`return [this.companyName, this.companyAddress, this.companyCountry].join(", ");`

`};`

`// Create four employee objects - note that two share the same company information, and two`

`// share the same ssId and name. As more objects are created, the amount of data repeated will`

`// grow, consuming more memory due to inefficiency`

`var denOdell = new Employee({`

`employeeId: 1456,`

`ssId: "1234-567-8901",`

`name: "Den Odell",`

`occupation: "Head of Web Development",`

`companyName: "AKQA",`

`companyAddress: "1 St. John's Lane, London",`

`companyCountry: "GB"`

`}),`

`steveBallmer = new Employee({`

`employeeId: 3,`

`ssId: "8376-940-1673",`

`name: "Steve Ballmer",`

`occupation: "Ex-CEO",`

`companyName: "Microsoft",`

`companyAddress: "1 Microsoft Way, Redmond, WA",`

`companyCountry: "US"`

`}),`

`billGates = new Employee({`

`employeeId: 1,`

`ssId: "7754-342-7584",`

`name: "Bill Gates",`

`occupation: "Founder",`

`companyName: "Microsoft",`

`companyAddress: "1 Microsoft Way, Redmond, WA",`

`companyCountry: "US"`

`}),`

`billGatesPhilanthropist = new Employee({`

`employeeId: 2,`

`ssId: "7754-342-7584",`

`name: "Bill Gates",`

`occupation: "Philanthropist",`

`companyName: "Gates Foundation",`

`companyAddress: "500 Fifth Avenue North, Seattle, WA",`

`companyCountry: "US"`

`});`

flyweight 模式是通过尝试解构一个现有的“类”来应用的，这样可以最小化对象实例之间可能重复的任何数据。这是通过研究重复数据的任何当前对象实例并创建单独的“类”来表示该数据来实现的。然后，单个对象实例可以表示重复的数据，这些数据可以从原始“类”的多个对象实例中引用，从而减少存储的数据，从而减少应用的内存占用。

每个当前对象实例的任何数据核心都称为该“类”的内部数据，任何可以从对象中提取、单独存储和引用的数据都称为其外部数据。在清单 6-7 中，与雇员相关的内在数据——本质上是唯一的——是它的`employeeId`和`occupation`值。目前复制在多个`Employee`对象上的公司数据可以单独提取和存储；每个人的数据也是如此，比如他们的`name`和`ssId`值。因此，一个雇员可以用四个属性来表示:`employeeId`、`occupation`、`company`、`person`。最后两个属性引用其他对象实例。

flyweight 模式分三个阶段应用，如清单 6-8 所示:首先，创建新的“类”来表示外部数据；第二，通过应用工厂模式来确保先前创建的对象不会被重新创建；最后，通过编写代码，以与最初相同的方式创建对象，允许所有 flyweight 的繁重工作在幕后进行。

清单 6-8。轻量级模式

`// The first stage of applying the flyweight pattern is to extract intrinsic data from`

`// extrinsic data in the objects we wish to make more memory-efficient`

`//`

`// There are two sets of extrinsic data in an Employee object from Listing 6-7 - people data`

`// and company data. Let's create two "classes" to represent those types of data`

`//`

`// A Person object represents an individual's social security number and their name`

`function Person(data) {`

`this.ssId = data.ssId || "";`

`this.name = data.name || "";`

`}`

`// A Company object represents a company's name, address and country details`

`function Company(data) {`

`this.name = data.name || "";`

`this.address = data.address || "";`

`this.country = data.country || "";`

`}`

`// The second stage of the flyweight pattern is to ensure any objects representing unique`

`// extrinsic data are only created once and stored for use in future. This is achieved by`

`// harnessing the factory pattern for each of the new extrinsic data "classes" to abstract`

`// away the creation of the object instance so that if a previously-existing object is found,`

`// that can be returned instead of creating a new instance`

`var personFactory = (function() {`

`// Create a variable to store all instances of the People "class" by their ssId`

`var people = {},`

`personCount = 0;`

`return {`

`// Provide a method to create an instance of the People "class" if one does not`

`// already exist by the given ssId provided in the data input. If one exists,`

`// return that object rather than creating a new one`

`createPerson: function(data) {`

`var person = people[data.ssId],`

`newPerson;`

`// If the person by the given ssId exists in our local data store, return their`

`// object instance, otherwise create a new one using the provided data`

`if (person) {`

`return person;`

`} else {`

`newPerson = new Person(data);`

`people[newPerson.ssId] = newPerson;`

`personCount++;`

`return newPerson;`

`}`

`},`

`// Provide a method to let us know how many Person objects have been created`

`getPersonCount: function() {`

`return personCount;`

`}`

`};`

`}()),`

`// Create a similar factory for Company objects, storing company data by name`

`companyFactory = (function() {`

`var companies = {},`

`companyCount = 0;`

`return {`

`createCompany: function(data) {`

`var company = companies[data.name],`

`newCompany;`

`if (company) {`

`return company;`

`} else {`

`newCompany = new Company(data);`

`companies[newCompany.name] = newCompany;`

`companyCount++;`

`return newCompany;`

`}`

`},`

`getCompanyCount: function() {`

`return companyCount;`

`}`

`};`

`}()),`

`// The third stage of the flyweight pattern is to allow the creation of objects in a`

`// simliar way to that in Listing 6-7, providing all the handling of data storage in the`

`// most efficient way in a transparent way to the end user`

`//`

`// Create an object with methods to store employee data and to return data from each`

`// object by their employeeId. This simplifies the end user's code as they do not need to`

`// access methods on underlying objects directly, they only need interface with this handler`

`employee = (function() {`

`// Create a data store for all employee objects created`

`var employees = {},`

`employeeCount = 0;`

`return {`

`// Provide a method to add employees to the data store, passing the provided data`

`// to the Person and Company factories and storing the resulting object, consisting`

`// of the enployeeId, occupation, person object reference, and company object`

`// reference in the local data store`

`add: function(data) {`

`// Create or locate Person or Company objects that correspond to the provided`

`// data, as appropriate`

`var person = personFactory.createPerson({`

`ssId: data.ssId,`

`name: data.name`

`}),`

`company = companyFactory.createCompany({`

`name: data.companyName,`

`address: data.companyAddress,`

`country: data.companyCountry`

`});`

`// Store a new object in the local data store, containing the employeeId,`

`// their occupation, and references to the company they work for and their`

`// unique personal data, including their name and social security number`

`employees[data.employeeId] = {`

`employeeId: data.employeeId,`

`occupation: data.occupation,`

`person: person,`

`company: company`

`};`

`employeeCount++;`

`},`

`// Provide a method to return the name of an employee by their employeeId - the`

`// data is looked up from the associated Person object`

`getName: function(employeeId) {`

`return employees[employeeId].person.name;`

`},`

`// Provide a method to return the occupation of an employee by their employeeId`

`getOccupation: function(employeeId) {`

`return employees[employeeId].occupation;`

`},`

`// Provide a method to return the address of the company an employee works for -`

`// the data is looked up from the associated Company object`

`getCountry: function(employeeId) {`

`var company = employees[employeeId].company;`

`return [company.name, company.address, company.country].join(", ");`

`},`

`// Provide a utlility method to tell us how many employees have been created`

`getTotalCount: function() {`

`return employeeCount;`

`}`

`};`

`}());`

清单 6-8 中的 flyweight 代码可以如清单 6-9 所示使用，它复制了清单 6-7 的行为。应用 flyweight 模式的原始内存消耗对象中的重复数据越多，共享的对象就越多，因此减少了应用的内存占用，证明了这种设计模式的有用性。

清单 6-9。正在使用的轻量级模式

`// Create four employee objects - note that two share the same company information, and two`

`// share the same ssId and name. Behind the scenes, the flyweight pattern from Listing 6-8`

`// ensures that repeated person and company data is stored in the most efficient way possible.`

`var denOdell = employee.add({`

`employeeId: 1456,`

`ssId: "1234-567-8901",`

`name: "Den Odell",`

`occupation: "Head of Web Development",`

`companyName: "AKQA",`

`companyAddress: "1 St. John's Lane, London",`

`companyCountry: "GB"`

`}),`

`steveBallmer = employee.add({`

`employeeId: 3,`

`ssId: "8376-940-1673",`

`name: "Steve Ballmer",`

`occupation: "Ex-CEO",`

`companyName: "Microsoft",`

`companyAddress: "1 Microsoft Way, Redmond, WA",`

`companyCountry: "US"`

`}),`

`billGates = employee.add({`

`employeeId: 1,`

`ssId: "7754-342-7584",`

`name: "Bill Gates",`

`occupation: "Founder",`

`companyName: "Microsoft",`

`companyAddress: "1 Microsoft Way, Redmond, WA",`

`companyCountry: "US"`

`}),`

`billGatesPhilanthropist = employee.add({`

`employeeId: 2,`

`ssId: "7754-342-7584",`

`name: "Bill Gates",`

`occupation: "Philanthropist",`

`companyName: "Gates Foundation",`

`companyAddress: "500 Fifth Avenue North, Seattle, WA",`

`companyCountry: "US"`

`});`

`// We've created three objects representing people by ssId and name - Den Odell, Steve Ballmer`

`// and Bill Gates`

`alert(personFactory.getPersonCount()); // 3`

`// We've created three objects representing companies by name, address and country - AKQA,`

`// Microsoft and the Gates Foundation`

`alert(companyFactory.getCompanyCount()); // 3`

`// We've created four objects representing employees, with two unique properties and two`

`// properties linking to existing person and company objects. The more employee objects we`

`// create with shared person and company data, the less data we're storing in our application`

`// and the more effective the flyweight pattern becomes`

`alert(employee.getTotalCount()); // 4`

当您有大量具有相似共享属性名称-值对的对象时，最好使用 flyweight 模式，这些对象可以被分成更小的对象，这些对象之间通过引用共享数据，以便减少代码的内存占用，提高代码的效率。要在线阅读更多关于 flyweight 模式的内容，请查阅以下资源:

*   Addy Osmani 在《MSDN》杂志上发表的“用 Flyweight 模式管理应用资源”(via [`http://bit.ly/flyweight_pattern`](http://bit.ly/flyweight_pattern) )
*   Gurpreet Singh 的“轻量级模式”(via [`http://bit.ly/flyweight_js`](http://bit.ly/flyweight_js) )

## 混合模式

mixin 模式通过快速方便地将一组方法和属性从一个对象直接应用到另一个对象，或者直接应用到“类”的原型，使得所有对象实例都可以访问这些属性和方法，从而避免了对大量子类化和继承链的需求。尽管这听起来像是“黑客”，特别是对于那些从传统的面向对象背景开始接触 JavaScript 的开发人员来说，这种模式直接利用了 JavaScript 语言的优势及其对原型的使用，而不是其他语言所应用的严格的经典继承，并且如果小心使用，可以简化开发和代码维护。清单 6-10 中的代码展示了如何使用 mixin 模式简单快速地将一组通用方法应用到多个对象上。

清单 6-10。混合模式

`// Define a mixin which enables debug logging, to be applied to any object or "class"`

`var loggingMixin = {`

`// Define a storage array for logs`

`logs: [],`

`// Define a method to store a message in the log`

`log: function(message) {`

`this.logs.push(message);`

`},`

`// Define a method to read out the stored logs`

`readLog: function() {`

`return this.logs.join("\n");`

`}`

`},`

`element,`

`header,`

`textField,`

`emailField;`

`// Function to apply methods and properties from one object to another, which we'll use to apply`

`// the mixin to other objects`

`function extendObj(obj1, obj2) {`

`var obj2Key;`

`for (obj2Key in obj2) {`

`if (obj2.hasOwnProperty(obj2Key)) {`

`obj1[obj2Key] = obj2[obj2Key];`

`}`

`}`

`return obj1;`

`}`

`// Define a singleton to which we will apply the mixin, though will function fine without it`

`element = {`

`allElements: [],`

`create: function(type) {`

`var elem = document.createElement(type);`

`this.allElements.push(elem);`

`// Use the mixin method log(), ensuring it exists first before calling it. If the mixin`

`// is not applied, then the method will still function fine`

`if (typeof this.log === "function") {`

`this.log("Created an element of type: " + type);`

`}`

`return elem;`

`},`

`getAllElements: function() {`

`return this.allElements;`

`}`

`};`

`// Define a simple "class" to which we will apply the mixin`

`function Field(type, displayText) {`

`this.type = type || "";`

`this.displayText = displayText || "";`

`// Ensure the mixin method log() exists before executing`

`if (typeof this.log === "function") {`

`this.log("Created an instance of Field");`

`}`

`}`

`Field.prototype = {`

`getElement: function() {`

`var field = document.createElement("input");`

`field.setAttribute("type", this.type);`

`field.setAttribute("placeholder", this.displayText);`

`if (typeof this.log === "function") {`

`this.log("Created a DOM element with placeholder text: " + this.displayText);`

`}`

`return field;`

`}`

`};`

`// Apply the mixin directly to the 'element' object by essentially copying over methods and`

`// properties from the mixin to the singleton`

`element = extendObj(element, loggingMixin);`

`// Apply the mixin to the Field "class" prototype, making its methods available to each object`

`// instance created from it`

`Field.prototype = extendObj(Field.prototype, loggingMixin);`

`// Create a new DOM element using the element.create() method`

`header = element.create("header");`

`// Create two object instances, both of which receive the getElement method from the prototype`

`textField = new Field("text", "Enter the first line of your address");`

`emailField = new Field("email", "Enter your email address");`

`// Add the elements stored in these objects to the current page`

`document.body.appendChild(textField.getElement());`

`document.body.appendChild(emailField.getElement());`

`// Output the logs stored via the mixin`

`alert(loggingMixin.readLog());`

`// Outputs the following - note how all the logs from each usage of the mixin are`

`// stored together:`

`/*`

`Created an element of type: header`

`Created an instance of Field`

`Created an instance of Field`

`Created a DOM element with placeholder text: Enter the first line of your address`

`Created a DOM element with placeholder text: Enter your email address`

`*/`

如果您研究清单 6-10 中的代码，您可能会注意到一些意想不到的事情:尽管将 mixin 独立地应用于 singleton 和“class”，但是所有记录的数据都存储在一起。对任何包含该方法的对象调用`readLog()`方法都会输出相同的结果。发生这种情况是因为当`extendObj()`函数将 objectlike 属性从一个对象复制到另一个对象时，比如本例中的`logs`数组(记住数组是 JavaScript 中的一种对象类型)，这些是通过引用复制的，而不是实际的数据副本。每次从任何对象访问该属性时，都使用相同的属性，最初来自`loggingMixin`对象。在这个例子中，我们希望看到所有的日志，所以这是有用的；然而，在您自己的代码中使用这种模式时，这可能不是您需要的结果。如果你想为复制的属性创建单独的副本，更新`extendObj()`函数，如清单 6-11 所示。

清单 6-11。更新了 extendObj()函数以复制属性，而不是通过引用复制

`// Update extendObj() to duplicate object-based properties rather than point to them`

`// by reference`

`function extendObj(obj1, obj2) {`

`var obj2Key,`

`value;`

`for (obj2Key in obj2) {`

`if (obj2.hasOwnProperty(obj2Key)) {`

`value = obj2[obj2Key];`

`// If the value being copied is an array, then copy a duplicate of that array using`

`// the slice() method`

`if (Object.prototype.toString.apply(value) === "[object Array]") {`

`obj1[obj2Key] = value.slice();`

`// Otherwise, if the value being copied in an object, and not an array, then copy`

`// across a duplicate of that object using a recursive call to this function`

`} else if (typeof obj2[obj2Key] === "object") {`

`obj1[obj2Key] = extendObj({}, value);`

`// Otherwise, copy across the value as usual`

`} else {`

`obj1[obj2Key] = value;`

`}`

`}`

`}`

`return obj1;`

`}`

当您希望快速地将一组属性和方法直接从一个对象应用到另一个对象，或者应用到一个“类”以供其所有对象实例使用时，mixin 模式是最好的选择，而不需要求助于复杂的子类化和继承。要在线阅读更多关于 mixin 模式的内容，请参考以下资源:

*   安格斯·克罗尔的《JavaScript Mixins 的新观点》(via [`http://bit.ly/mixin_pattern`](http://bit.ly/mixin_pattern) )
*   《JavaScript Mixins:超越简单对象扩展》作者吴镇男·贝利(via [`http://bit.ly/mixins_beyond`](http://bit.ly/mixins_beyond) )

## 模块模式

模块模式可能是专业 JavaScript 开发人员最常用的模式。事实上，我们已经在前面的章节中两次讨论了模式的基础:第一次是在第一章中讨论公共、私有和受保护变量时，第二次是在第四章中讨论改进 JavaScript 压缩的方法时。这一切都基于自执行函数闭包，它允许我们创建一个沙盒代码区域，可以访问全局变量和函数，但不会将其中声明的变量或函数暴露给周围的作用域，除非使用`return`语句显式声明。自执行函数的最简单示例如下所示:

`(function() {`

`// Any variables or functions declared within this function aren't accessible outside it`

`}());`

我们可以使用这种模式将我们的代码库划分成更小的、相关的代码块，我们称之为模块，这就是该模式的名字。这些模块中的每一个都应该清楚地说明它们对代码的其他部分的依赖性，如果有的话，这些部分应该作为参数传递给函数，如下所示:

`(function($) {`

`// We very clearly define jQuery as a dependency for this 'module', making it available`

`// internally through the $ variable`

`}(jQuery));`

Tip

在函数内访问 JavaScript 参数比在函数外访问全局变量更快，因为语言解释器不必执行离开当前函数范围来搜索变量的额外步骤。

模块模式的基本形式是通过使用函数闭包内的`return`语句来传递回任何可能对其他模块或主应用本身有用的声明代码来完成的。清单 6-12 显示了模块模式的完整形式，基于上一章的清单 5-10。

清单 6-12。模块模式

`// The module pattern is distinctive as it uses a combination of a self-executing anonymous`

`// function closure, with any dependencies passed in as parameters, and an optional return`

`// statement which allows code created within the closure to be made available externally`

`// Our only dependency is the 'document' object which contains the browser's cookie data. As an`

`// added security measure, we can include a final listed parameter named 'undefined' to which we`

`// never pass a value. This ensures that the variable named 'undefined' always contains an`

`// undefined value provided we always ensure we never pass in a value to this parameter.`

`// Otherwise it might be possible for other code, whether through malicious reasons or`

`// otherwise, to overwrite this value as it is not a reserved word in the language causing all`

`// kinds of havoc to the way our code behaves.`

`var cookie = (function(document, undefined) {`

`var allCookies = document.cookie.split(";"),`

`cookies = {},`

`cookiesIndex = 0,`

`cookiesLength = allCookies.length,`

`cookie;`

`for (; cookiesIndex < cookiesLength; cookiesIndex++) {`

`cookie = allCookies[cookiesIndex].split("=");`

`cookies[unescape(cookie[0])] = unescape(cookie[1]);`

`}`

`// Return any methods, properties or values that you wish to make available to the rest of`

`// your code base. In this case, the following two methods will be exposed through the`

`// 'cookie' variable, creating a singleton`

`return {`

`get: function(name) {`

`return cookies[name] || "";`

`},`

`set: function(name, value) {`

`cookies[name] = value;`

`document.cookie = escape(name) + "=" + escape(value);`

`}`

`};`

`// Pass in any dependencies at the point of function execution`

`}(document));`

在通过单例对象结构利用命名空间的大型代码库中，模块模式的使用方式与我们看到的略有不同；在这种情况下，我们传入一个依赖项，然后在函数闭包结束时返回，使用该模块用新的属性和方法来增加单例。清单 6-13 显示了模块模式应用于名称空间的扩充，这是它最常见的用途之一。

清单 6-13。使用模块模式扩充名称空间

`// Define a namespace which we will populate with code modules`

`var myData = {};`

`// Ajax module, added to the myData namespace through augmentation`

`// The namespace is passed in as a parameter and, once it has been augmented with new method, is`

`// finally returned back, overwriting the original namespace with the new, augmented one`

`myData = (function(myNamespace, undefined) {`

`// Add an 'ajax' object property to the namespace and populate it with related methods`

`myNamespace.ajax = {`

`get: function(url, callback) {`

`var xhr = new XMLHttpRequest(),`

`LOADED_STATE = 4,`

`OK_STATUS = 200;`

`xhr.onreadystatechange = function() {`

`if (xhr.readyState !== LOADED_STATE) {`

`return;`

`}`

`if (xhr.status === OK_STATUS) {`

`callback(xhr.responseText);`

`}`

`};`

`xhr.open("GET", url);`

`xhr.send();`

`}`

`};`

`// Return the new, augmented namespace back to the myData variable`

`return myNamespace;`

`// We can use the following defence mecahnism, which reverts to an empty object if the myData`

`// namespace object does not yet exist. This is useful when you have modules split over several`

`// files in a large namespace and you're unsure if the namespace passed in has been initialized`

`// elsewhere before`

`}(myData || {}));`

`// Cookies module, added to the myData namespace through augmentation`

`// As before, the namespace is passed in, augmented, and then returned, overwriting the original`

`// namespace object. At this point, the myData namespace contains the Ajax module code`

`myData = (function(myNamespace, undefined) {`

`// Add a 'cookies' object property to the namespace and populate it with related methods`

`myNamespace.cookies = {`

`get: function(name) {`

`var output = "",`

`escapedName = escape(name),`

`start = document.cookie.indexOf(escapedName + "="),`

`end = document.cookie.indexOf(";", start);`

`end = end === -1 ? (document.cookie.length - 1) : end;`

`if (start >=0) {`

`output = document.cookie.substring(start + escapedName.length + 1, end);`

`}`

`return unescape(output);`

`},`

`set: function(name, value) {`

`document.cookie = escape(name) + "=" + escape(value);`

`}`

`};`

`return myNamespace;`

`}(myData || {}));`

`// Execute methods directly through the myData namespace object, which now contains both Ajax`

`// and Cookies modules`

`myData.ajax.get("/user/12345", function(response) {`

`alert("HTTP GET response received. User data: " + response);`

`});`

`myData.cookies.set("company", "AKQA");`

`myData.cookies.set("name", "Den Odell");`

`alert(myData.cookies.get("company")); // AKQA`

`alert(myData.cookies.get("name"));    // Den Odell`

当您希望将大型代码库分解成更小的、可管理的、自包含的部分时，最好使用模块模式，每个部分都有一组清晰的依赖项和定义明确的目的。由于它们的沙箱特性，它们的自执行功能块也是通过混淆和编译创建较小文件的主要领域，我们在第四章中讨论过这些主题。在第九章中，我们将会看到一种使用异步模块定义(AMD) API 来定义模块并将模块加载到 JavaScript 代码中的替代方法，但是现在如果你想在线阅读更多关于模块模式的内容，请查阅以下资源:

*   本·切瑞的《JavaScript 模块模式:深入研究》(via [`http://bit.ly/module_pattern`](http://bit.ly/module_pattern) )
*   雷蒙德·卡姆登的《JavaScript 设计模式——揭示模块模式》(via [`http://bit.ly/revealing_module`](http://bit.ly/revealing_module) )

## 代理模式

代理模式是一种定义代理或替代对象或方法的模式，用于替换或增强现有的对象或方法，以提高其性能或添加额外的功能，而不会影响已经使用该对象或方法的代码的其他部分。我和许多其他专业 JavaScript 开发人员使用这种模式的最常见方式是在不改变方法或函数名的情况下包装现有的方法或函数，如清单 6-14 所示。

清单 6-14。代理模式

`// To proxy the myData.cookies.get() method from Listing 6-13, we begin by storing the current`

`// method in a variable`

`var proxiedGet = myData.cookies.get;`

`// Override the get() method with a new function which proxies the original and augments its`

`// behavior`

`myData.cookies.get = function() {`

`// Call the proxied (original) method to get the value it would have produced`

`var value = proxiedGet.apply(this, arguments);`

`// Do something with the value returned from the proxied method`

`value = value.toUpperCase();`

`// Return the manipulated value with the same type as the proxied method, so that the use of`

`// this new method does not break any existing calls to it`

`return value;`

`};`

代理模式的一个变种叫做虚拟代理，它可以通过延迟对象实例化，从而延迟构造函数的执行，直到来自对象实例的方法被实际调用，来提高性能和内存使用，如清单 6-15 所示。

清单 6-15。虚拟代理模式

`// Define a "class" for constructing an object representing a simple form field`

`function FormField(type, displayText){`

`this.type = type || "text";`

`this.displayText = displayText || "";`

`// Create and initialize a form field DOM element`

`this.element = document.createElement("input");`

`this.element.setAttribute("type", this.type);`

`this.element.setAttribute("placeholder", this.displayText);`

`}`

`// Define two methods for object instances to inherit`

`FormField.prototype = {`

`getElement: function() {`

`return this.element;`

`},`

`isValid: function() {`

`return this.element.value !== "";`

`}`

`};`

`// Now replace the FormField "class" with a proxy that implements the same methods, yet delays`

`// calling the original constructor function until those methods are actually called, saving on`

`// memory resources and improving performance`

`// Optionally, use the module pattern to localise the scope of the proxy "class", passing in the`

`// original FormField "class" and returning the proxied version of it`

`FormField = (function(FormField) {`

`// Define a proxy constructor, similar to the original FormField "class"`

`function FormFieldProxy(type, displayText) {`

`this.type = type;`

`this.displayText = displayText;`

`}`

`FormFieldProxy.prototype = {`

`// Define a property to store the reference to the object instance of the original`

`// "class" once instantiated`

`formField: null,`

`// Define a new 'initialize' method whose task it is to create the object instance of`

`// FormField if it does not already exist and execute the constructor function from the`

`// original "class"`

`initialize: function() {`

`if (!this.formField) {`

`this.formField = new FormField(this.type, this.displayText);`

`}`

`},`

`// Proxy the original methods with new ones that call the intialize() method to`

`// instantiate the FormField "class" only when one of these methods are called`

`getElement: function() {`

`this.initialize();`

`return this.formField.getElement();`

`},`

`isValid: function() {`

`this.initialize();`

`return this.formField.isValid();`

`}`

`};`

`// Return the proxied "class" to replace the original with`

`return FormFieldProxy;`

`}(FormField));`

`// Create two object instances, both of which will actually be calling the proxy rather than the`

`// original "class", meaning the DOM elements will not be created at this stage, saving memory`

`// and improving performance`

`var textField = new FormField("text", "Enter the first line of your address"),`

`emailField = new FormField("email", "Enter your email address");`

`// Add the elements stored in these objects to the current page when loaded - at this point the`

`// getElement() method is called, which in turn calls initialize(), creating an instance of the`

`// original "class" and executing its constructor function which performs the actual DOM element`

`// creation. This ensures the memory used to store the DOM element is only taken up at the exact`

`// point it is required`

`window.addEventListener("load", function() {`

`document.body.appendChild(textField.getElement());`

`document.body.appendChild(emailField.getElement());`

`}, false);`

`// Execute another method from the proxy, this time the object instance of the original "class"`

`// won't be recreated and the stored instance will be used instead`

`alert(emailField.isValid()); // false`

对于可能同时进行多个调用的对象，可以通过延迟或分组调用(如 Ajax 请求或其他与网络相关的调用)来进一步扩展代理模式，以提高性能和减少内存。

当您需要覆盖一个对象或“类”上的特定方法的行为时，最好使用代理模式，或者应用代理模式来提高现有“类”的性能，以便在调用它的一个方法之前，它不会被实际实例化。要在线阅读有关代理模式的更多信息，请查看以下资源:

*   关于使用 jQuery 的“JavaScript 中的代理模式”(通过 [`http://bit.ly/proxy_pattern`](http://bit.ly/proxy_pattern) )
*   “JavaScript 设计模式:代理”，作者 Joseph Zimmerman，Adobe Developer Connection(通过 [`http://bit.ly/proxy_js`](http://bit.ly/proxy_js) )

## 摘要

在这一章中，我们研究了结构化设计模式，你可以在适当的时候使用这些模式来帮助你构建大型的 JavaScript 应用并提高它们的性能。这些是 JavaScript 开发的瑞士军刀中的工具，但是像所有工具一样，您需要知道何时何地最好地使用它们。记住那句古老的格言:“当你有一把锤子时，一切看起来都像钉子。”熟悉本章中的模式及其用例，并确保在代码中认识到需要使用设计模式之前，不要使用它。

在下一章中，我们将会看到一些行为设计模式，它们可以用来简化 JavaScript 应用代码库中不同对象之间的通信。