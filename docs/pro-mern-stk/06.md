# 六、MongoDB

在本章中，我将讨论 MongoDB、数据库层和 MERN 堆栈中的 M。到目前为止，我们在用作数据库的 Express 服务器内存中存在一系列问题。我们将用真正的持久性来代替它，并从 MongoDB 数据库中读取和写入问题列表。

为了实现这一点，我们需要在云上安装或使用 MongoDB，习惯它的 shell 命令，安装 Node.js 驱动程序以从 Node.js 访问它，最后修改服务器代码以替换 API 调用，从而从 MongoDB 数据库而不是内存中的问题数组中读取和写入。

## MongoDB 基础知识

这是一个介绍性的部分，在这里我们不会修改应用。我们将在这一节中讨论这些核心概念:MongoDB、文档和集合。然后，我们将设置 MongoDB，并通过使用 mongo shell 读写数据库的示例来探索这些概念。

### 文档

MongoDB 是一个文档数据库，这意味着记录的等价物是一个文档，或者一个对象。在关系数据库中，您按照行和列来组织数据，而在文档数据库中，整个对象可以写成一个文档。

对于简单的对象，这似乎与关系数据库没有什么不同。但是假设你有嵌套对象(称为*嵌入*文档)和数组的对象。现在，当使用关系数据库时，通常需要多个表。例如，在一个关系数据库中，一个发票对象可以存储在一个`invoice`表(用于存储发票细节，如客户地址和交货细节)和一个`invoice_items`表(用于存储货物中每一项的细节)的组合中。在 MongoDB 中，整个 Invoice 对象将被存储为一个文档。这是因为一个文档可以以嵌套的方式包含数组和其他对象，所包含的对象不必分离到其他文档中。

文档是由字段和值对组成的数据结构。字段的值可能包括对象、数组和对象数组等等，嵌套的深度与您希望的一样。MongoDB 文档类似于 JSON 对象，所以很容易把它们看作 JavaScript 对象。与 JSON 对象相比，MongoDB 文档不仅支持原始数据类型——布尔、数字和字符串——还支持其他常见的数据类型，如日期、时间戳、正则表达式和二进制数据。

发票对象可能如下所示:

```js
{
  "invoiceNumber" : 1234,
  "invoiceDate" : ISODate("2018-10-12T05:17:15.737Z"),
  "billingAddress" : {
    "name" : "Acme Inc.",
    "line1" : "106 High Street",
    "city" : "New York City",
    "zip" : "110001-1234"
  },
  "items" : [
    {
      "description" : "Compact Flourescent Lamp",
      "quantity" : 4,
      "price" : 12.48
    },
    {
      "description" : "Whiteboard",
      "quantity" : 1,
      "price" : 5.44
    }
  ]
}

```

在这个文档中，有数字、字符串和日期数据类型。此外，还有一个嵌套对象(`billingAddress`)和一个对象数组(`items`)。

### 收集

集合就像关系数据库中的表:它是一组文档。就像在关系数据库中一样，集合可以有主键和索引。但是与关系数据库相比，还是有一些不同之处。

MongoDB 中规定了一个主键，它有一个保留的字段名`_id`。即使在创建文档时没有提供`_id`字段，MongoDB 也会创建这个字段，并为每个文档自动生成一个惟一的键。通常情况下，自动生成的 ID 可以按原样使用，因为即使当多个客户端同时向数据库写入数据时，它也很方便，并且可以保证生成惟一的键。MongoDB 使用一种称为`ObjectId`的特殊数据类型作为主键。

`_id`字段被自动索引。除此之外，还可以在其他字段上创建索引，这包括嵌入文档中的字段和数组字段。索引用于有效地访问集合中的文档子集。

与关系数据库不同，MongoDB 不要求您为集合定义模式。惟一的要求是集合中的所有文档必须有一个惟一的`_id`，但是实际的文档可能有完全不同的字段。但是实际上，集合中的所有文档都有相同的字段。尽管在应用的初始阶段，灵活的模式对于模式更改可能非常方便，但是如果没有在应用代码中添加某种模式检查，这可能会导致问题。

从 3.6 版本开始，MongoDB 已经支持模式的概念，尽管它是可选的。你可以在 [`https://docs.mongodb.com/manual/core/schema-validation/index.html`](https://docs.mongodb.com/manual/core/schema-validation/index.html) 阅读所有关于 MongoDB 模式的内容。模式可以强制允许和必需的字段及其数据类型，就像 GraphQL 一样。但是它也可以验证其他东西，比如字符串长度和整数的最小和最大值。

但是由于模式冲突而产生的错误并没有给出足够的细节来说明从 3.6 版本开始哪些验证检查失败了。在 MongoDB 的未来版本中，这一点可能会有所改进，到那时就值得考虑添加全面的模式检查了。对于问题跟踪器应用，我们将不使用 MongoDB 的模式验证特性，相反，我们将在后端代码中实现所有必要的验证。

### 数据库

数据库是许多集合的逻辑分组。因为没有像 SQL 数据库中那样的外键，所以数据库的概念只是一个逻辑分区名称空间。大多数数据库操作从单个集合中读取或写入，但是`$lookup`(聚合管道中的一个阶段)相当于 SQL 数据库中的一个连接。这个阶段可以合并同一个数据库中的文档。

此外，备份和其他管理任务是作为一个单元在数据库上进行的。一个数据库连接被限制为只能访问一个数据库，因此要访问多个数据库，需要多个连接。因此，将应用的所有集合保存在一个数据库中是很有用的，尽管一个数据库服务器可以托管多个数据库。

### 查询语言

与关系数据库中通用的类似英语的 SQL 不同，MongoDB 查询语言由*方法*组成，以实现各种操作。读写操作的主要方法是 CRUD 方法。其他方法包括聚合、文本搜索和地理空间查询。

所有方法都对集合进行操作，并将参数作为指定操作细节的 JavaScript 对象。每种方法都有自己的规范。例如，要插入一个文档，唯一需要的参数就是文档本身。对于查询，参数是查询过滤器和要返回的字段列表(也称为*投影*)。

查询过滤器是一个 JavaScript 对象，由零个或多个属性组成，其中属性名是要匹配的字段的名称，属性值由另一个带有运算符和值的对象组成。例如，要匹配字段`invoiceNumber`大于 1，000 的所有文档，可以使用以下查询过滤器:

```js
{ "invoiceNumber": { $gt: 1000 } }

```

因为没有用于查询或更新的“语言”,所以可以非常容易地以编程方式构造查询过滤器。

与关系数据库不同，MongoDB 鼓励非规范化，也就是说，将文档的相关部分存储为嵌入式子文档，而不是作为关系数据库中的独立集合(表)。以人(姓名、性别等)为例。)及其联系信息(主要地址、次要地址等)。).在关系数据库中，这需要为人员和联系人创建单独的表，然后在需要所有信息时将这两个表连接起来。另一方面，在 MongoDB 中，它可以存储为同一个人文档中的联系人列表。这是因为集合的连接对于 MongoDB 中的大多数方法来说并不自然:最方便的`find()`方法一次只能操作一个集合。

### 装置

在您尝试在您的计算机上安装 MongoDB 之前，您可能想要尝试一个能够让您访问 MongoDB 的托管服务。有许多服务，但以下是受欢迎的，并有一个免费版本，您可以使用一个小的测试或沙盒应用。对于我们将作为本书的一部分构建的问题跟踪器应用来说，这些都非常好。

*   MongoDB Atlas ( [`https://www.mongodb.com/cloud/atlas`](https://www.mongodb.com/cloud/atlas) ):我简称这个为 Atlas。一个小数据库(共享 RAM，512 MB 存储)是免费的。

*   mLab(之前为 MongoLab) ( [`https://mlab.com/`](https://mlab.com/) ): mLab 已经宣布被 MongoDB Inc .收购，最终可能会并入 Atlas 本身。沙盒环境是免费的，限制为 500 MB 的存储空间。

*   Compose ( [`https://www.compose.com`](https://www.compose.com) ):在许多其他服务中，Compose 提供 MongoDB 作为服务。有 30 天的试用期，但是没有永久免费的沙盒选项。

在这三个中，我发现 Atlas 是最方便的，因为主机的位置有许多选择。当连接到数据库时，它让我选择一个离我的位置最近的数据库，这样可以最小化延迟。mLab 不提供群集—可以单独创建数据库。Compose 不是永久免费的，您可能需要 30 多天来完成这本书。

任何托管选项的缺点是，除了访问数据库时的小的额外延迟之外，您需要互联网连接。这意味着您可能无法在无法访问互联网的地方测试您的代码，例如在飞机上。相比之下，在您的计算机上安装 MongoDB 可能会更好，但安装比注册一个基于云的选项需要更多的工作。

即使使用云选项之一，您也需要下载并安装 mongo shell 才能远程访问数据库。每项服务都附带了关于这一步骤的说明。注册这些服务时，请选择 MongoDB 3.6 或更高版本。按照服务提供商给出的说明，通过使用 mongo shell 连接到集群或数据库来测试注册。

如果您选择在您的计算机上安装 MongoDB(它可以很容易地安装在 OS X、Windows 和大多数基于 Linux 的发行版上)，请查找安装说明，每个操作系统的安装说明都是不同的。您可以按照 mongodb 网站( [`https://docs.mongodb.com/manual/installation/`](https://docs.mongodb.com/manual/installation/) 或在您的搜索引擎中搜索“MongoDB 安装”)上的说明来安装 MongoDB。

选择 MongoDB 版本 3.6 或更高版本，最好是最新的，因为一些示例使用了仅在版本 3.6 中引入的特性。大多数本地安装选项都允许您将服务器、shell 和工具安装在一起。检查情况是否如此；如果没有，您可能需要单独安装它们。

在本地安装之后，确保您已经启动了 MongoDB 服务器(守护进程或服务的名称是 mongod ),如果安装过程尚未启动它的话。通过运行 mongo shell 来测试安装，如下所示:

```js
$ mongo

```

在 Windows 系统上，您可能需要在命令后面追加`.exe`。根据您的安装方法，该命令可能需要路径。如果 shell 成功启动，它还将连接到本地 MongoDB 服务器实例。如果您在本地安装了 MongoDB 4 . 0 . 2 版，您应该会看到控制台上打印的 MongoDB 版本、它所连接的数据库(默认为 test)以及一个命令提示符，如下所示:

```js
MongoDB shell version v4.0.2
connecting to: mongodb://127.0.0.1:27017
MongoDB server version: 4.0.2
>

```

您看到的消息可能与此略有不同，尤其是如果您安装了不同版本的 MongoDB。但是您确实需要看到提示`>`，在那里您可以键入更多的命令。相反，如果您看到一条错误消息，请重新执行安装和服务器启动过程。

### 蒙哥贝壳

mongo shell 是一个交互式 JavaScript shell，非常像 Node.js shell。在交互式 shell 中，除了 JavaScript 的全部功能之外，还有一些非 JavaScript 的便利。在这一节中，我们将讨论通过 shell 可能实现的基本操作，这些操作是最常用的。关于 shell 所有功能的完整参考，您可以在 [`https://docs.mongodb.com/manual/mongo/`](https://docs.mongodb.com/manual/mongo/) 查看 mongo shell 文档。

我们将在 mongo shell 中输入的命令已经收集在一个名为`mongo_commands.txt`的文件中。这些命令已经过测试，可以在 Atlas 或本地安装中正常工作，但是您可能会发现其他选项中有所变化。例如，mLab 只允许您连接到数据库(而不是集群)，因此它不允许在 mLab 中的数据库之间切换。

### 注意

如果您在键入命令时发现某些东西不能按预期工作，请在 GitHub 资源库( [`https://github.com/vasansr/pro-mern-stack-2`](https://github.com/vasansr/pro-mern-stack-2) )中交叉检查这些命令。这是因为错别字可能是在书的制作过程中引入的，或者最后一刻的更正可能错过了这本书。另一方面，GitHub 库反映了最新的和经过测试的代码和命令。

要使用 MongoDB，您需要连接到数据库。让我们从查找哪些数据库可用开始。显示当前数据库的命令是:

```js
> show databases

```

这将列出数据库及其占用的存储。例如，在 MongoDB 的全新本地安装中，您将看到以下内容:

```js
admin         0.000GB
config        0.000GB
local         0.000GB

```

这些是 MongoDB 用于内部记账等的系统数据库。我们不会使用这些来创建我们的集合，所以我们最好改变当前的数据库。要识别当前数据库，命令是:

```js
> db

```

mongo shell 连接到的默认数据库称为`test`，这就是您可能看到的该命令的输出。现在让我们看看这个数据库中存在哪些集合。

```js
> show collections

```

您会发现这个数据库中没有任何集合，因为它是全新安装的。此外，您还会发现，当我们列出可用数据库时，数据库`test`并未列出。这是因为数据库和集合实际上只在对它们的第一次写操作时创建。

让我们切换到名为`issuetracker`的数据库，而不是使用默认数据库:

```js
> use issuetracker

```

这将导致确认新数据库是`issuetracker`的输出:

```js
switched to db issuetracker

```

让我们确认该数据库中也没有集合:

```js
> show collections

```

该命令不应返回任何内容。现在，让我们创建一个新集合。这是通过在集合中创建一个文档来实现的。集合作为全局对象`db`的属性被引用，与集合同名。名为`employees`的集合可以简称为`db.employees`。让我们使用`insertOne()`方法在`employees`集合中插入一个新文档。该方法接受要插入的文档作为参数:

```js
> db.employees.insertOne({ name: { first: 'John', last: 'Doe' }, age: 44 })

```

该命令的结果将显示操作的结果和创建的新文档的 ID，如下所示:

```js
{
     "acknowledged" : true,
     "insertedId" : ObjectId("5bbc487a69d13abf04edf857")
}

```

除了`insertOne()`方法之外，任何集合上都有许多方法可用。输入“`db.employees.`”后按两下 Tab 键可以看到可用方法的列表(按 Tab 键前需要输入末尾的句点)。您可能会发现如下所示的输出:

```js
db.employees.addIdIfNeeded(              db.employees.getWriteConcern(
db.employees.aggregate(                  db.employees.group(
db.employees.bulkWrite(                  db.employees.groupcmd(
db.employees.constructor                 db.employees.hasOwnProperty
db.employees.convertToCapped(            db.employees.hashAllDocs(
db.employees.convertToSingleObject(      db.employees.help(
db.employees.copyTo(                     db.employees.initializeOrderedBulkOp(
db.employees.count(                      db.employees.initializeUnorderedBulkOp(
db.employees.createIndex(                db.employees.insert(
db.employees.createIndexes(              db.employees.insertMany(
db.employees.dataSize(                   db.employees.insertOne(
...

```

这就是 mongo shell 的自动完成功能。请注意，您可以让 mongo shell 自动完成任何方法的名称，方法是在输入方法的开头几个字符后按 Tab 字符。

现在让我们检查文档是否已经在集合中创建。为此，我们可以对集合使用`find()`方法。没有任何参数，该方法只列出集合中的所有文档:

```js
> db.employees.find()

```

这将显示我们刚刚创建的文档，但是它的格式并不“漂亮”。它将全部打印在一行中，并且可能不方便地换到下一行。为了获得更清晰的输出，我们可以对`find()`方法的结果使用`pretty()`方法:

```js
> db.employees.find().pretty()

```

这应该会显示更清晰的输出，如下所示:

```js
{
     "_id" : ObjectId("5bbc487a69d13abf04edf857"),
     "name" : {
            "first" : "John",
            "last" : "Doe"
     },
     "age" : 44
}

```

在这个时间点，如果您执行`show collections`和`show databases`，您会发现`employees`集合和`issuetracker`数据库确实已经被创建，并在它们各自命令的输出中列出。让我们在同一个集合中插入另一个文档，并尝试处理集合中的多个文档:

```js
> db.employees.insertOne({ name: { first: 'Jane', last: 'Doe' }, age: 54 })

```

现在，既然我们已经在 shell 中拥有了 JavaScript 的全部功能，让我们尝试使用它来体验一下。让我们将结果收集到一个 JavaScript 数组变量中，而不是在屏幕上打印结果。`find()`方法的结果是一个可以迭代的游标。在`cursor`对象中，还有除了`pretty()`之外的方法，其中一个就是`toArray()`。该方法从查询中读取所有文档，并将它们放在一个数组中。所以，让我们使用这个方法，并将其结果赋给一个数组变量。

```js
> let result = db.employees.find().toArray()

```

现在，变量`result`应该是一个包含两个元素的数组，每个元素都是一个`employee`文档。让我们使用 JavaScript 数组方法`forEach()`遍历它们并打印每个雇员的名字:

```js
> result.forEach((e) => print('First Name:', e.name.first))

```

这将产生如下输出:

```js
First Name: John
First Name: Jane

```

在 Node.js 中，`console.log`方法可用于在控制台上打印对象。另一方面，mongo shell 提供了用于相同目的的`print()`方法，但是它只打印字符串。在打印之前，需要使用实用函数`tojson()`将对象转换成字符串。还有另外一种方法，叫做`printjson()`，把对象打印成 JSON。让我们用它来检查嵌套文档`name`的内容，而不仅仅是名字:

```js
> result.forEach((e) => printjson(e.name))

```

现在，您应该看到`name`对象被扩展成名和姓，如下所示:

```js
{ "first" : "John", "last" : "Doe" }
{ "first" : "Jane", "last" : "Doe" }

```

除了提供一种访问数据库和集合的方法的机制之外，shell 本身做得很少。它是 JavaScript 引擎，它构成了 shell 的基础，并赋予了 shell 很大的灵活性和强大的功能。

在下一节中，我们将讨论集合的更多方法，比如您刚刚了解到的`insertOne()`。许多编程语言都可以通过驱动程序访问这些方法。mongo shell 只是另一个可以访问这些方法的工具。您会发现其他编程语言中可用的方法和参数与 mongo shell 中的非常相似。

### 练习:MongoDB 基础知识

1.  使用 shell，显示一个在`cursor`对象上可用的方法列表。提示:在 [`https://docs.mongodb.com/manual/tutorial/access-mongo-shell-help/`](https://docs.mongodb.com/manual/tutorial/access-mongo-shell-help/) 查找 mongo shell 文档以获得 mongo Shell 帮助。

本章末尾有答案。

## MongoDB CRUD 操作

因为 mongo shell 是最容易尝试的，所以让我们使用 shell 本身来探索 MongoDB 中可用的 CRUD 操作。我们将继续使用我们在上一节中创建的`issuetracker`数据库。但是让我们清空数据库，这样我们可以重新开始。collection 对象提供了一个方便的方法来擦除自身，称为`drop()`:

```js
> db.employees.drop()

```

这应该会产生如下输出:

```js
true

```

这不同于删除集合中的所有文档，因为它还会删除集合中的所有索引。

### 创造

在上一节中，您简要地看到了如何插入文档，作为其中的一部分，您发现了 MongoDB 如何自动创建主键，这是一种称为`ObjectID`的特殊数据类型。现在让我们使用自己的 ID，而不是让 MongoDB 自动生成一个 ID。

```js
> db.employees.insertOne({
  _id: 1,
  name: { first: 'John', last: 'Doe' },
  age: 44
})

```

这将导致以下输出:

```js
{ "acknowledged" : true, "insertedId" : 1 }

```

请注意，`insertedId`的值反映了我们为`_id`提供的值。这意味着，我们能够提供自己的价值，而不是一种`ObjectID`类型的价值。让我们尝试创建一个新的相同的文档(您可以使用向上箭头键在 mongo shell 中重复前面的命令)。它将失败，并出现以下错误:

```js
WriteError({
     "index" : 0,
     "code" : 11000,
     "errmsg" : "E11000 duplicate key error collection: issuetracker.employees index: _id_ dup key: { : 1.0 }",
     "op" : {
            "_id" : 1,
            "name" : {
                  "first" : "John",
                  "last" : "Doe"
            },
            "age" : 44
     }
})

```

这表明`_id`字段仍然是主键，并且应该是惟一的，不管它是自动生成的还是在文档中提供的。现在，让我们添加另一个文档，但是使用一个新字段作为名称的一部分，比如中间名:

```js
> db.employees.insertOne({
  name: {first: 'John', middle: 'H', last: 'Doe'},
  age: 22
})

```

这很好，使用`find()`，您可以看到集合中存在两个文档，但是它们不一定是相同的模式。这就是灵活模式的优势:只要发现需要存储的新数据元素，就可以增强模式，而不必显式修改模式。

在这种情况下，任何缺少`name`下的`middle`字段的员工文档都意味着该员工没有中间名。另一方面，如果添加了一个在缺失时没有隐含意义的字段，则必须在代码中处理它的缺失。或者必须运行一个迁移脚本，将该字段的值默认为某个值。

你还会发现两个文档的`_id`字段的格式不一样，甚至数据类型也不一样。对于第一个文档，数据类型是整数。对于第二个，它是类型`ObjectID`(这就是为什么它被显示为`ObjectID(...)`。因此，不仅仅是同一集合中两个文档之间的字段存在差异，甚至同一字段的数据类型也可能不同。

在大多数情况下，将主键的创建留给 MongoDB 就很好了，因为您不必担心保持它的唯一性:MongoDB 会自动做到这一点。但是，这个标识符不是人类可读的。在 Issue Tracker 应用中，我们希望标识符是一个数字，以便于记忆和谈论。但是我们不使用`_id`字段来存储人类可读的标识符，而是使用一个名为`id`的新字段，让 MongoDB 自动生成`_id`。

所以，让我们放弃这个集合，开始用一个名为`id`的新字段创建新文档。

```js
> db.employees.drop()

> db.employees.insertOne({
  id: 1,
  name: { first: 'John', last: 'Doe' },
  age: 48
})

> db.employees.insertOne({
  id: 2,
  name: { first: 'Jane', last: 'Doe'} ,
  age: 16
})

```

该集合有一个方法，可以一次接收多个文档。这种方法叫做`insertMany()`。让我们用它在一个命令中再创建几个文档:

```js
> db.employees.insertMany([
  { id: 3, name: { first: 'Alice', last: 'A' }, age: 32 },
  { id: 4, name: { first: 'Bob', last: 'B' }, age: 64 },
])

```

对这个问题的回答会显示多个`insertedIds`被创建，而不是为`insertOne()`方法创建一个`insertedId`，如下所示:

```js
{
     "acknowledged" : true,
     "insertedIds" : [
            ObjectId("5bc6d80005fb87b8f2f5cf6f"),
            ObjectId("5bc6d80005fb87b8f2f5cf70")
     ]
}

```

### 阅读

现在集合中有多个文档，让我们看看如何检索文档的子集，而不是完整的列表。`find()`方法接受另外两个参数。第一个是应用于列表的过滤器，第二个是投影，即指定要检索的字段。

过滤器规范是一个对象，其中属性名是要过滤的字段，值是它需要匹配的值。让我们获取一个员工的文档，由等于 1 的`id`标识。因为我们知道给定的 ID 只能有一个雇员，所以让我们使用`findOne()`而不是`find()`。方法`findOne()`是方法`find()`的变体，它返回单个对象而不是光标。

```js
> db.employees.findOne({ id: 1 })

```

这将返回我们创建的第一个员工文档，输出如下所示:

```js
{
     "_id" : ObjectId("5bc6d7e505fb87b8f2f5cf6d"),
     "id" : 1,
     "name" : {
            "first" : "John",
            "last" : "Doe"
     },
     "age" : 48
}

```

注意，我们在这里没有使用`pretty()`,但是输出被美化了。这是因为`findOne()`返回单个对象，mongo shell 默认美化对象。

过滤器实际上是{ `id: { $eq: 1 } },`的简写，其中`$eq`是表示字段`id`的值必须等于到 1 的运算符。一般意义上，过滤器中单个元素的格式是`fieldname: { operator: value }`。也可以使用其他运算符进行比较，如`$gt`表示大于等。让我们尝试使用`$gte`(大于或等于)操作符来获取 30 岁或以上的员工列表:

```js
> db.employees.find({ age: { $gte: 30 } })

```

该命令应该返回三个文档，因为我们插入了那些年龄超过 30 岁的人。如果指定了多个字段，那么它们都必须匹配，这与用一个*和*操作符将它们组合起来是一样的:

```js
> db.employees.find({ age: { $gte: 30 }, 'name.last': 'Doe'  })

```

现在返回的文档数量应该减少到只有一个，因为只有一个文档符合这两个标准，姓氏等于`'Doe'`，年龄大于 30。注意，我们使用了点符号来指定嵌套文档中嵌入的字段。这也让我们在字段名两边加上引号，因为它是一个普通的 JavaScript 对象属性。

要匹配同一个字段的多个值，例如，匹配大于 30 的年龄*和小于 60 的年龄*，不能使用相同的策略。这是因为过滤器是一个普通的 JavaScript 对象，一个文档中不能存在两个同名的属性。因此，像`{ age: { $gte: 30 }, age: { $lte: 60 } }`这样的过滤器将不起作用(JavaScript 不会抛出错误，而是只为属性`age`选择一个值)。必须使用一个显式的`$and`操作符，它接受一个指定多个字段值标准的对象数组。您可以在 [`https://docs.mongodb.com/manual/reference/operator/query/`](https://docs.mongodb.com/manual/reference/operator/query/) 的 MongoDB 参考手册的操作符部分阅读到关于`$and`操作符和更多操作符的所有内容。

当在一个字段上进行筛选是常见的情况时，在该字段上创建索引通常是一个好主意。集合上的`createIndex()`方法就是为了这个目的。它接受一个指定构成索引的字段的参数(多个字段将构成一个复合索引)。让我们在年龄字段上创建一个索引:

```js
> db.employees.createIndex({ age: 1 })

```

有了这个索引，任何使用包含字段`age`的过滤器的查询都会快得多，因为 MongoDB 将使用这个索引，而不是扫描集合中的所有文档。但这并不是一个唯一的指数，因为许多人可能年龄相同。

年龄字段可能不是常用的过滤器，但是根据标识符获取文档将会非常频繁。MongoDB 自动在`_id`字段上创建一个索引，但是我们使用了自己的标识符`id`，这个字段更有可能用于获取单个雇员。所以让我们创建一个关于这个领域的索引。此外，它必须是唯一的，因为它标识了雇员:没有两个雇员应该有相同的`id`值。`createIndex()`的第二个参数是一个包含索引各种属性的对象，其中一个属性指定索引是否惟一。让我们用它来创建一个关于`id`的唯一索引:

```js
> db.employees.createIndex({ id: 1 }, { unique: true })

```

现在，当提供了一个带有`id`的过滤器时，不仅`find()`方法的性能会好得多，而且 MongoDB 还会阻止创建带有重复`id`的文档。让我们通过为第一个员工重新运行`insert`命令来尝试一下:

```js
> db.employees.insertOne({
  id: 1,
  name: { first: 'John', last: 'Doe' },
  age: 48
})

```

现在，您应该会在 mongo shell 中看到这样的错误(对于您来说,`ObjectID`会有所不同):

```js
WriteError({
     "index" : 0,
     "code" : 11000,
     "errmsg" : "E11000 duplicate key error collection: issuetracker.employees index: id_1 dup key: { : 1.0 }",
     "op" : {
            "_id" : ObjectId("5bc04b8569334c5ff5bb7e8c"),

            "id" : 1
               ...
     }
})

```

### 规划

与此同时，我们检索到了与过滤器匹配的整个文档。在上一节中，当我们必须只打印文档字段的子集时，我们使用了一个`forEach()`循环。但是这意味着即使我们只需要打印文档的一部分，也要从服务器获取整个文档。当文档很大时，这会占用大量网络带宽。为了将获取限制在某些字段，`find()`方法采用了第二个参数，称为*投影*。投影指定在结果中包括或排除哪些字段。

该规范的格式是一个对象，其中一个或多个字段名称作为关键字，值为 0 或 1，以指示排除或包含。但是 0 和 1 不能组合。您可以从零开始并包含使用 1 的字段，或者从所有内容开始并排除使用 0 的字段。`_id`字段是一个例外；除非您指定 0，否则它将始终包含在内。以下将获取所有雇员，但仅获取他们的名字和年龄:

```js
> db.employees.find({}, { 'name.first': 1, age: 1 })

```

请注意，我们指定了一个空的过滤器，即必须获取所有文档。因为投影是第二个参数，所以必须这样做。前面的请求应该会打印出这样的内容:

```js
{ "_id" : ObjectId("5bbc...797855"), "name" : { "first" : "John" }, "age" : 48 }
{ "_id" : ObjectId("5bbc...797856"), "name" : { "first" : "Jane" }, "age" : 16 }
{ "_id" : ObjectId("5bbc...797857"), "name" : { "first" : "Alice" }, "age" : 32 }
{ "_id" : ObjectId("5bbc...797858"), "name" : { "first" : "Bob" }, "age" : 64 }

```

即使我们只指定了名字和年龄，字段`_id`也会自动包含在内。要禁止包含该字段，需要将其显式排除，如下所示:

```js
> db.employees.find({}, { _id: 0, 'name.first': 1, age: 1 })

```

现在，输出将排除 ID，如下所示:

```js
{ "name" : { "first" : "John" }, "age" : 48 }
{ "name" : { "first" : "Jane" }, "age" : 16 }
{ "name" : { "first" : "Alice" }, "age" : 32 }
{ "name" : { "first" : "Bob" }, "age" : 64 }

```

### 更新

有两种方法可以用来修改单据，分别是`updateOne()`和`updateMany()`。这两种方法的参数是相同的，除了`updateOne()`在找到并更新第一个匹配的文档后停止。第一个参数是一个查询过滤器，与`find()`使用的过滤器相同。第二个参数是更新规范，如果只需要更改对象的某些字段。

使用`updateOne()`时，主键或任何唯一标识符是过滤器中通常使用的，因为过滤器只能匹配一个文档。更新规范是一个具有一系列`$set`属性的对象，这些属性的值指示另一个对象，该对象指定字段及其新值。让我们更新由`id` 2 标识的员工的年龄:

```js
> db.employees.updateOne({ id: 2 }, { $set: {age: 23 } })

```

这应该会产生以下输出:

```js
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

```

`matchedCount`返回了符合过滤器的文档数量。如果过滤器匹配了不止一个，那么就会返回这个数字。但是因为该方法应该只修改一个文档，所以修改的计数应该总是 1，除非修改无效。如果再次运行该命令，您将发现`modifiedCount`将为 0，因为 ID 为 2 的雇员的年龄已经是 23 岁。

要一次性修改多个文档，必须使用`updateMany()`方法。格式与`updateOne()`方法相同，但效果是*所有匹配的*文档都将被修改。让我们使用`updateMany()`方法为所有员工添加一个`organization`字段:

```js
> db.employees.updateMany({}, { $set: { organization: 'MyCompany' } })

```

注意，即使字段`organization`在文档中不存在，新值`MyCompany`也会应用于所有文档。如果你执行命令`find()`在投影中单独显示公司，这个事实将被证实。

还有一种用*替换*的方法叫做`replaceOne()`。如果完整的已修改文档可用，则无需指定要修改的字段，只需用新文档替换现有文档即可。这里有一个例子:

```js
> db.employees.replaceOne({ id: 4 }, {
  id: 4,
  name : { first : "Bobby" },
  age : 66
});

```

该命令将用新文档替换 ID 为 4 的现有文档。事实上，`organization`和`name.last`字段没有被指定，这将导致这些字段在被替换的文档中不存在*，而不是使用`updateOne()`改变*。得到被替换的对象应该证明:**

```js
> db.employees.find({ id: 4 })

```

这应该会产生如下所示的文档:

```js
{ "_id" : ObjectId("5c38ae3da7dc439456c0281b"), "id" : 4, "name" : { "first" : "Bobby" }, "age" : 66 }

```

您可以看到它不再有字段`name.last`和`organization`，因为在提供给命令`replaceOne()`的文档中没有指定这些字段。它只是用提供的文档替换文档，除了字段`ObjectId`。作为主键，该字段不能通过`updateOne()`或`replaceOne()`改变。

### 删除

`delete`操作接受一个过滤器并从集合中删除文档。滤波器格式相同，变量`deleteOne()`和`deleteMany()`都可用，就像在`update`操作中一样。

让我们删除最后一个文档，ID 为 4:

```js
> db.employees.deleteOne({ id: 4 })

```

这将产生以下输出，确认删除仅影响一个文档:

```js
{ "acknowledged" : true, "deletedCount" : 1 }

```

让我们通过查看集合的大小来交叉检查删除。集合上的`count()`方法告诉我们它包含多少个文档。现在执行它应该会返回值 3，因为我们最初插入了四个文档。

```js
> db.employees.count()

```

### 总计

`find()`方法用于返回集合中的所有文档或文档子集。很多时候，我们需要的不是文档列表，而是摘要或集合，例如，符合某个标准的文档的数量。

`count()`方法当然可以带一个过滤器。但是其他的聚合函数呢，比如 sum？这就是`aggregate()`发挥作用的地方。与支持 SQL 的关系数据库相比，`aggregate()`方法执行 GROUP BY 子句的功能。但是它还可以执行其他功能，比如连接，甚至展开(基于数组展开文档)等等。

您可以在位于 [`https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/`](https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/) 的 MongoDB 文档中查找`aggregate()`函数支持的高级特性，但是现在，让我们看看它提供的真正的聚合和分组构造。

`aggregate()`方法在管道中工作。管道中的每个*阶段*从前一阶段的结果中获取输入，并根据其规范进行操作，以产生一组新的修改后的文档。当然，管道的初始输入是整个集合。管道规范采用对象数组的形式，每个元素都是一个对象，具有一个标识管道阶段类型的属性和指定管道效果的值。

例如，通过使用`$match`(滤波器)和`$project`(投影)，可以使用`aggregate()`来复制`find()`方法。要执行实际的聚合，需要使用`$group`阶段。stage 的规范包括由属性`_id`标识的分组关键字和作为关键字的其他字段，其值是聚合规范和需要执行聚合的字段。`_id`可以为空，以对整个集合进行分组。

让我们通过获取整个集合中所有雇员的总年龄来尝试一下。管道数组中只有一个元素，一个具有单一属性`$group`的对象。在值中，`_id`将被设置为`null`，因为我们不想按任何字段分组。我们需要(使用聚合函数`$sum)`将字段`age`求和成一个新的字段`total_age`，如下所示:

```js
> db.employees.aggregate([
  { $group: { _id: null, total_age: { $sum: '$age' } } }
])

```

这应该会产生如下输出:

```js
{ "_id" : null, "total_age" : 103 }

```

相同的函数`$sum`可用于通过简单地对值 1 求和来获得记录的计数:

```js
> db.employees.aggregate([
  { $group: { _id: null, count: { $sum: 1 } } }
])

```

要按字段对聚合进行分组，我们需要指定字段的名称(以`$`为前缀)作为`_id`的值。让我们使用`organization`字段，但是在此之前，让我们插入一个组织不同于其余文档的新文档(它们都被设置为`MyCompany`):

```js
> db.employees.insertOne({
  id: 4,
  name: { first: 'Bob', last: 'B' },
  age: 64,
  organization: 'OtherCompany'
})

```

现在，下面是使用 sum 跨不同组织聚合年龄的命令:

```js
> db.employees.aggregate([
  { $group: { _id: '$organization', total_age: { $sum: '$age' } } }
])

```

这应该会产生如下输出:

```js
{ "_id" : "OtherCompany", "total_age" : 64 }
{ "_id" : "MyCompany", "total_age" : 103 }

```

让我们也尝试另一个聚合函数，比方说 average，使用`$avg`:

```js
> db.employees.aggregate([
  { $group: { _id: '$organization', average_age: { $avg: '$age' } } }
])

```

这应该会产生如下输出:

```js
{ "_id" : "OtherCompany", "average_age" : 64 }
{ "_id" : "MyCompany", "average_age" : 34.333333333333336 }

```

还有其他聚合函数，包括最小值和最大值。关于完整的设置，请参考 [`https://docs.mongodb.com/manual/reference/operator/aggregation/group/#accumulator-operator`](https://docs.mongodb.com/manual/reference/operator/aggregation/group/%2523accumulator-operator) 的文档。

### 练习:MongoDB Crud 操作

1.  编写一个简单的语句来检索所有有中间名的雇员。提示:在 [`https://docs.mongodb.com/manual/reference/operator/query/`](https://docs.mongodb.com/manual/reference/operator/query/) 查找查询操作符的 MongoDB 文档。

2.  过滤器规范是 JSON 吗？提示:考虑字段名称周围的日期对象和引号。

3.  假设某个员工的中间名设置错误，您需要删除它。为此写一个语句。提示:在 [`https://docs.mongodb.com/manual/reference/operator/update/`](https://docs.mongodb.com/manual/reference/operator/update/) 查找更新操作符的 MongoDB 文档。

4.  在索引创建过程中，1 表示什么？还允许哪些有效值？提示:在 [`https://docs.mongodb.com/manual/indexes/`](https://docs.mongodb.com/manual/indexes/) 查找 MongoDB 索引文档。

本章末尾有答案。

## MongoDB Node.js 驱动程序

这是 Node.js 驱动程序，允许您连接 MongoDB 服务器并与之交互。它提供的方法与您在 mongo shell 中看到的非常相似，但又不完全相同。我们可以使用一个名为 Mongoose 的对象文档映射器来代替低级别的 MongoDB 驱动程序，它具有更高的抽象级别和更方便的方法。但是学习低级别的 MongoDB 驱动程序可能会让您更好地处理 MongoDB 本身的实际工作，所以我选择为问题跟踪器应用使用低级别的驱动程序。

首先，让我们安装驱动程序:

```js
$ npm install mongodb@3

```

让我们也启动一个新的 Node.js 程序，尝试一下驱动程序方法的不同使用方式。在下一节中，我们将使用此次试用的一些代码来将驱动程序集成到问题跟踪器应用中。让我们将这个示例 Node.js 程序称为`trymongo.js`，并将其放在一个名为`scripts`的新目录中，以区别于应用中的其他文件。

首先要做的是连接到数据库服务器。这可以通过首先从驱动程序导入对象`MongoClient`，然后使用标识要连接的数据库的 URL 从它创建一个新的客户机对象，最后对它调用`connect`方法来完成，如下所示:

```js
...
const { MongoClient } = require('mongodb');

const client = new MongoClient(url);
client.connect();
...

```

URL 应该以`mongodb://`开头，后跟要连接的服务器的主机名或 IP 地址。可以使用`:`作为分隔符添加一个可选端口，但是如果 MongoDB 服务器运行在默认端口 27017 上，就不需要这个端口。将连接参数分离到一个配置文件中而不是保存在一个签入的文件中是一个好习惯，但是我们将在下一章中这样做。现在，让我们对此进行硬编码。如果您使用了某个云提供商，可以从相应的连接说明中获得 URL。对于本地安装，URL 将是`mongodb://localhost/issuetracker`。请注意，MongoDB Node.js 驱动程序接受数据库名称作为 URL 本身的一部分，最好以这种方式指定它，即使云提供商可能不会明确显示这一点。

让我们将本地安装 URL 添加到`trymongo.js`和云提供商 URL 的注释版本。

```js
...
const url = 'mongodb://localhost/issuetracker';

// Atlas URL - replace UUU with user, PPP with password, XXX with hostname
// const url = 'mongodb+srv://UUU:PPP@cluster0-XXX.mongodb.net/issuetracker?retryWrites=true';

// mLab URL - replace UUU with user, PPP with password, XXX with hostname
// const url = 'mongodb://UUU:PPP@XXX.mlab.com:33533/issuetracker';
...

```

此外，客户机构造函数接受另一个参数，为客户机提供更多设置，其中之一是是否使用新的样式解析器。让我们更改构造函数来传递它，以避免在最新的 Node.js 驱动程序(3.1 版)中出现警告。

```js
...
const client = new MongoClient(url, { useNewUrlParser: true });
...

```

`connect()`方法是一个异步方法，需要一个回调来接收连接结果。回调接受两个参数:错误和结果。结果是客户端对象本身。在回调中，可以通过调用`client`对象的`db`方法来获得到数据库的连接(相对于到服务器的连接)。因此，回调和到数据库的连接可以写成这样:

```js
...
client.connect(function(err, client) {
  const db = client.db();
...

```

到数据库的连接`db`，类似于我们在 mongo shell 中使用的`db`变量。特别是，我们可以用它来获得集合及其方法的句柄。让我们使用 mongo shell 来处理上一节中使用的名为`employees`的集合。

```js
...
  const collection = db.collection('employees');
...

```

有了这个集合，我们可以做我们在上一节中用 mongo shell 的等价物`db.employees`所做的事情。这些方法也非常相似，只是它们都是异步的。这意味着这些方法接受常规参数，但也接受操作完成时调用的回调函数。回调函数中的约定是将错误作为第一个参数传递，将操作结果作为第二个参数传递。在前面的连接方法中，您已经看到了这种回调模式。

让我们插入一个文档并回读它，看看这些方法在 Node.js 驱动程序中是如何工作的。可以使用`insertOne`方法编写插入，传入一个雇员文档和一个回调。在回调中，让我们打印新创建的`_id`。就像在 mongo shell `insertOne`命令中一样，创建的 ID 作为结果对象的一部分返回，位于名为`insertedId`的属性中。

```js
...
  const employee = { id: 1, name: 'A. Callback', age: 23 };
  collection.insertOne(employee, function(err, result) {
    console.log('Result of insert:\n', result.insertedId);
...

```

注意，访问集合和`insert`操作只能在连接操作的回调中调用，因为只有这样我们才知道连接成功了。还需要一些错误处理，但是让我们稍后再处理这个问题。

现在，在`insert`操作的回调中，让我们使用结果的 ID 读回插入的文档。我们可以使用我们提供的 ID(`id`)或者自动生成的 MongoDB ID ( `_id`)。让我们使用`_id`来确保我们能够使用结果值。

```js
...
    collection.find({ _id: result.insertedId})
      .toArray(function(err, docs) {
        console.log('Result of find:\n', docs);
      }
...

```

现在我们已经完成了文档的插入和回读，我们可以关闭到服务器的连接了。如果我们不这样做，Node.js 程序就不会退出，因为连接对象正在等待被使用，并且正在监听一个套接字。

```js
...
      client.close();
...

```

让我们将所有这些放在一个名为`testWithCallbacks()`的函数中。我们很快也将使用一种不同的方法来使用 Node.js 驱动程序。同样，按照惯例，让我们给这个函数传递一个回调函数，一旦所有操作完成，我们将从`testWithCallbacks()`函数调用这个函数。然后，如果有任何错误，可以将它们传递给回调函数。

让我们首先声明这个函数:

```js
...
function testWithCallbacks(callback) {
  console.log('\n--- testWithCallbacks ---');
  ...
}
...

```

并且在作为每个操作结果的每个回调中，在出现错误时，我们需要执行以下操作:

*   关闭与服务器的连接

*   打电话回电

*   从调用中返回，以便不再执行任何操作

当所有操作完成时，我们也需要这样做。错误处理的模式如下:

```js
...
    if (err) {
      client.close();
      callback(err);
      return;
    }
...

```

让我们从主部分引入一个对`testWithCallbacks()`函数的调用，为它提供一个回调函数来接收任何错误，如果有错误就打印出来。

```js
...
testWithCallbacks(function(err) {
  if (err) {
    console.log(err);
  }
});
...

```

引入所有错误处理和回调后，`trymongo.js`文件中的最终代码如清单 6-1 所示。

### 注意

虽然我们不遗余力地确保所有代码清单的准确性，但在本书付印之前，可能会有一些错别字甚至更正没有出现在书中。所以，总是依赖 GitHub 库( [`https://github.com/vasansr/pro-mern-stack-2`](https://github.com/vasansr/pro-mern-stack-2) )作为所有代码清单的经过测试的和最新的源代码，尤其是当某些东西不能按预期工作时。

```js
const { MongoClient } = require('mongodb');

const url = 'mongodb://localhost/issuetracker';

// Atlas URL  - replace UUU with user, PPP with password, XXX with hostname
// const url = 'mongodb+srv://UUU:PPP@cluster0-XXX.mongodb.net/issuetracker?retryWrites=true';

// mLab URL - replace UUU with user, PPP with password, XXX with hostname
// const url = 'mongodb://UUU:PPP@XXX.mlab.com:33533/issuetracker';

function testWithCallbacks(callback) {
  console.log('\n--- testWithCallbacks ---');
  const client = new MongoClient(url, { useNewUrlParser: true });
  client.connect(function(err, client) {
    if (err) {
      callback(err);
      return;
    }
    console.log('Connected to MongoDB');

    const db = client.db();
    const collection = db.collection('employees');

    const employee = { id: 1, name: 'A. Callback', age: 23 };
    collection.insertOne(employee, function(err, result) {
      if (err) {
        client.close();
        callback(err);
        return;
      }
      console.log('Result of insert:\n', result.insertedId);
      collection.find({ _id: result.insertedId})

        .toArray(function(err, docs) {
        if (err) {
          client.close();
          callback(err);
          return;
        }
        console.log('Result of find:\n', docs);
        client.close();
        callback(err);
      });
    });
  });
}

testWithCallbacks(function(err) {
  if (err) {
    console.log(err);
  }
});

Listing 6-1trymongo.js: Using Node.js driver, Using the Callbacks Paradigm

```

在测试之前，让我们清理一下集合。我们可以打开另一个命令 shell，在其中运行 mongo shell，并执行`db.employees.remove({})`。但是 mongo shell 有一种命令行方式，可以使用`--eval`命令行选项执行简单的命令。让我们这样做，并传递要连接的数据库名称；否则，该命令将在默认数据库`test`上执行。对于本地安装，该命令如下所示:

```js
$ mongo issuetracker --eval "db.employees.remove({})"

```

如果您使用来自某个主机提供商的远程服务器，而不是数据库名称，请使用主机提供商建议的包含数据库名称的连接字符串。例如，Atlas 命令可能如下所示(用您自己的主机名、用户名和密码替换):

```js
$ mongo "mongodb+srv://cluster0-xxxxx.mongodb.net/issuetracker" --username atlasUser --password atlasPassword --eval "db.employees.remove({})"

```

现在，我们准备测试我们刚刚创建的试用程序。它可以这样执行:

```js
$ node scripts/trymongo.js

```

这将产生如下输出(您将看到不同的`ObjectID`，否则输出应该是相同的):

```js
--- testWithCallbacks ---
Connected to MongoDB
Result of insert:
 5bbef955580a2c313d4052f6
Result of find:
 [ { _id: 5bbef955580a2c313d4052f6,
    id: 1,
    name: 'A. Callback',
    age: 23 } ]

```

正如你可能感觉到的，回调范式有点笨拙。但好处是它可以在旧版本的 JavaScript)中工作，因此也可以在旧版本的 Node.js 中工作。ES2015 开始支持承诺，Node.js MongoDB 驱动程序也支持承诺，这是对回调的改进。但在 ES2017 和 7.6 版的 Node.js 中，出现了对 async/await 范式的完全支持，这是使用驱动程序的推荐和最方便的方式。

让我们在使用 async/await 范例的`trymongo.js`中实现另一个名为`testWithAsync()`的函数。所有带有回调的异步调用现在都可以被对同一方法的调用所取代，但不提供回调。在方法调用之前使用`await`将模拟一个同步调用，由*等待*调用完成并返回结果。例如，我们可以不将回调传递给`connect()`方法，而是像这样等待它完成:

```js
...
    await client.connect();
...

```

在下一行中，我们可以在操作完成后做任何需要做的事情，在本例中，连接到数据库:

```js
...
    await client.connect();
    const db = client.db();
...

```

相同的模式可以用于其他异步调用，但有一点不同:调用的结果(最初是回调的第二个参数)可以直接赋给一个变量，比如函数调用的返回值。所以，`insertOne()`的结果可以这样捕捉:

```js
...
    const result = await collection.insertOne(employee);
...

```

错误将被抛出并被捕获。我们可以将所有操作放在一个单独的`try`块中，并在一个地方(`catch`块)捕获任何错误，而不是在每次调用之后。函数不需要接受回调，因为如果调用者需要等待结果，可以在调用这个函数之前添加一个`await`，并抛出错误。

在每个操作`connect()`、`insertOne(),`和`find()`之前使用`await`的新功能如清单 6-2 所示。

```js
async function testWithAsync() {
  console.log('\n--- testWithAsync ---');
  const client = new MongoClient(url, { useNewUrlParser: true });
  try {
    await client.connect();
    console.log('Connected to MongoDB');
    const db = client.db();
    const collection = db.collection('employees');

    const employee = { id: 2, name: 'B. Async', age: 16 };
    const result = await collection.insertOne(employee);
    console.log('Result of insert:\n', result.insertedId);

    const docs = await collection.find({ _id: result.insertedId })
      .toArray();
    console.log('Result of find:\n', docs);
  } catch(err) {
    console.log(err);
  } finally {
    client.close();
  }
}

Listing 6-2trymongo.js, testWithAsync Function

```

最后，让我们修改程序的主要部分，在处理来自`testWithCallbacks()`的返回值的回调中调用`testWithAsync()`:

```js
...
testWithCallbacks(function(err) {
  if (err) {
    console.log(err);
  }
  testWithAsync();
});
...

```

如果您如前所述使用`remove()`清除集合并测试这些更改，您将会看到这个结果(您看到的`ObjectIDs`将与这里显示的不同):

```js
--- testWithCallbacks ---
Connected to MongoDB
Result of insert:
 5bbf25dcf50e97340be0f01f
Result of find:
 [ { _id: 5bbf25dcf50e97340be0f01f,
    id: 1,
    name: 'A. Callback',
    age: 23 } ]

--- testWithAsync ---
Connected to MongoDB
Result of insert:
 5bbf25dcf50e97340be0f020
Result of find:
 [ { _id: 5bbf25dcf50e97340be0f020,
    id: 2,
    name: 'B. Async',
    age: 16 } ]

```

测试错误是否被捕获和显示的一个好方法是再次运行程序。会有错误，因为我们在字段`id`上有一个唯一的索引，所以 MongoDB 将抛出一个重复的键冲突。如果在创建索引后删除了集合，可以运行`createIndex()`命令来恢复这个索引。

正如您所看到的，async/await 范式在代码方面要小得多，也清晰易读得多。事实上，虽然我们在这个函数中捕获了错误，但是我们并不需要这样做。我们也可以让打电话的人来处理。

考虑到 async/await 范例的好处，让我们在与数据库交互时在 Issue Tracker 应用中使用它。

## 模式初始化

mongo shell 不仅是一个交互式 shell，而且还是一个脚本环境。利用这一点，可以编写脚本来执行各种任务，例如模式初始化和迁移。因为 mongo shell 实际上是构建在 JavaScript 引擎之上的，所以 JavaScript 的强大功能在脚本中是可用的，就像在 shell 本身中一样。

交互式和非交互式工作模式之间的一个区别是，非交互式 shell 不支持非 JavaScript 快捷方式，例如`use <db>`和`show collections`命令。该脚本必须是遵循正确语法的常规 JavaScript 程序。

让我们在`script`目录中创建一个名为`init.mongo.js`的模式初始化脚本。因为 MongoDB 不强制模式，所以实际上不存在像在关系数据库中创建表那样的模式初始化。唯一真正有用的是创建索引，这是一次性任务。同时，让我们用一些样本文档来初始化数据库，以便于测试。我们将使用我们用来测试 mongo shell 的同一个数据库`issuetracker`,来存储所有与问题跟踪器应用相关的集合。

让我们复制来自`server.js`的问题数组，并使用同一个数组在名为`issues`的集合上使用`insertMany()`来初始化集合。但是在此之前，让我们通过在同一个集合上调用一个带有空过滤器的`remove()`(它将匹配所有文档)来清除现有的问题。然后，让我们在有用的字段上创建一些索引，我们将使用这些索引来搜索集合。

清单 6-3 显示了初始化脚本`init.mongo.js`的完整内容。文件开头的注释说明了如何为不同类型的数据库运行这个脚本——local、Atlas 和 mLab。

```js
/*
 * Run using the mongo shell. For remote databases, ensure that the
 * connection string is supplied in the command line. For example:
 * localhost:
 *   mongo issuetracker scripts/init.mongo.js
 * Atlas:
 *   mongo mongodb+srv://user:pwd@xxx.mongodb.net/issuetracker
     scripts/init.mongo.js
 * MLab:
 *   mongo mongodb://user:pwd@xxx.mlab.com:33533/issuetracker
     scripts/init.mongo.js
 */

db.issues.remove({});

const issuesDB = [
  {
    id: 1, status: 'New', owner: 'Ravan', effort: 5,
    created: new Date('2019-01-15'), due: undefined,
    title: 'Error in console when clicking Add',
  },
  {
    id: 2, status: 'Assigned', owner: 'Eddie', effort: 14,
    created: new Date('2019-01-16'), due: new Date('2019-02-01'),
    title: 'Missing bottom border on panel',
  },
];

db.issues.insertMany(issuesDB);
const count = db.issues.count();
print('Inserted', count, 'issues');

db.issues.createIndex({ id: 1 }, { unique: true });
db.issues.createIndex({ status: 1 });
db.issues.createIndex({ owner: 1 });
db.issues.createIndex({ created: 1 });

Listing 6-3init.mongo.js: Schema Initialization

```

如果您像这样使用 MongoDB 的本地安装，您应该能够使用 mongo shell 运行这个脚本，在命令行中将文件名作为参数:

```js
$ mongo issuetracker scripts/init.mongo.js

```

对于使用 MongoDB 的其他方法，在脚本的顶部有作为注释的说明。实际上，必须在命令行中指定整个连接字符串，包括用于连接托管服务的用户名和密码。在连接字符串之后，您可以键入脚本的名称`scripts/init.mongo.js`。

您可以在任何希望将数据库重置为原始状态的时候运行该命令。您应该会看到一个输出，表明插入了两个问题，以及 MongoDB 版本和 shell 版本。请注意，在索引已经存在的情况下创建索引没有任何效果，因此多次创建索引是安全的。

### 练习:模式初始化

1.  使用 Node.js 脚本和 MongoDB 驱动程序可以完成相同的模式初始化。使用 mongo shell 和 Node.js MongoDB 驱动程序这两种方法各有什么优缺点？

2.  还有其他可能有用的索引吗？提示:如果我们在应用中需要一个搜索栏呢？在 [`https://docs.mongodb.com/manual/indexes/#index-types`](https://docs.mongodb.com/manual/indexes/%2523index-types) 阅读 MongoDB 索引类型。

本章末尾有答案。

## 从 MongoDB 读取

在上一节中，您看到了如何使用 Node.js 驱动程序来执行基本的 CRUD 任务。有了这些知识，现在让我们将 List API 改为从 MongoDB 数据库中读取，而不是从服务器中的内存数组中读取。因为我们已经用相同的初始问题集初始化了数据库，所以在测试时，您应该在 UI 中看到相同的问题集。

在我们为驱动程序做的试验中，我们在一系列操作中使用了到数据库的连接，并关闭了它。相反，在应用中，我们将维护连接，以便我们可以在许多操作中重用它，这些操作将从 API 调用中触发。因此，我们需要将与数据库的连接存储在一个全局变量中。除了`import`语句和其他全局变量声明之外，我们还可以调用全局数据库连接变量`db`:

```js
...
const url = 'mongodb://localhost/issuetracker';

// Atlas URL  - replace UUU with user, PPP with password, XXX with hostname
// const url = 'mongodb+srv://UUU:PPP@cluster0-XXX.mongodb.net/issuetracker?retryWrites=true';

// mLab URL - replace UUU with user, PPP with password, XXX with hostname
// const url = 'mongodb://UUU:PPP@XXX.mlab.com:33533/issuetracker';

let db;
...

```

接下来，让我们编写一个连接数据库的函数，它初始化这个全局变量。这是我们在`trymongo.js`中所做的一个小变化。我们不要在这个函数中捕捉任何错误，而是让调用者来处理它们。

```js
...
async function connectToDb() {
  const client = new MongoClient(url, { useNewUrlParser: true });
  await client.connect();
  console.log('Connected to MongoDB at', url);
  db = client.db();
}
...

```

现在，我们必须更改服务器的设置，首先连接到数据库，然后启动 Express 应用。由于`connectToDb()`是一个异步函数，我们可以使用`await`等待它完成，然后调用`app.listen()`。但是由于`await`不能用在程序的主要部分，我们必须将它放在一个`async`函数中，并立即执行该函数。

```js
...
(async function () {
  await connectToDb();
  app.listen(3000, function () {
    console.log('App started on port 3000');
  });
})();
...

```

但是我们也必须处理错误。因此，让我们将这个匿名函数的内容包含在一个`try`块中，并在控制台的`catch`块中打印任何错误:

```js
...
(async function () {
  try {
    ...
  } catch (err) {
    console.log('ERROR:', err);
  }
})();
...

```

现在我们已经连接到在名为`db`的全局变量中设置的数据库，我们可以在列表 API 解析器`issueList()`中使用它，通过调用`issues`集合上的`find()`方法来检索问题列表。我们需要从这个函数返回一系列问题，所以让我们像这样对`find()`的结果使用`toArray()`函数:

```js
...
  const issues = await db.collection('issues').find({}).toArray();
...

```

清单 6-4 中显示了对`server.js`的更改。

```js
...
const { Kind } = require('graphql/language');

const { MongoClient } = require('mongodb');

const url = 'mongodb://localhost/issuetracker';

// Atlas URL  - replace UUU with user, PPP with password, XXX with hostname

// const url = 'mongodb+srv://UUU:PPP@cluster0-XXX.mongodb.net/issuetracker?retryWrites=true';

// mLab URL - replace UUU with user, PPP with password, XXX with hostname

// const url = 'mongodb://UUU:PPP@XXX.mlab.com:33533/issuetracker';

let db;

let aboutMessage = "Issue Tracker API v1.0";
...

async function issueList() {
  return issuesDB;
  const issues = await db.collection('issues').find({}).toArray();
  return issues;
}
...

async function connectToDb() {

  const client = new MongoClient(url, { useNewUrlParser: true });
  await client.connect();
  console.log('Connected to MongoDB at', url);
  db = client.db();

}

const server = new ApolloServer({
...

(async function () {

  try {
    await connectToDb();
    app.listen(3000, function () {
      console.log('App started on port 3000');
    });
  } catch (err) {
    console.log('ERROR:', err);
  }

})();

Listing 6-4server.js: Changes for Reading the Issue List from MongoDB

```

### 注意

我们不需要做任何特殊的事情，因为解析器`issueList()`现在是一个异步函数，它不会立即返回值。`graphql-tools`库自动处理这个问题。解析器可以立即返回值或返回承诺(这是异步函数立即返回的内容)。两者都是解析程序可接受的返回值。

由于来自数据库的问题现在除了包含`id`字段之外还包含一个`_id`，让我们将它包含在`Issue`类型的 GraphQL 模式中。否则，调用 API 的客户端将无法访问该字段。让我们使用`ID`作为它的 GraphQL 数据类型，并使它成为强制的。这一变化如清单 6-5 所示。

```js
...
type Issue {
  _id: ID!
  id: Int!
  ...
}
...

Listing 6-5schema.graphql: Changes to add _id as a Field in Issue

```

现在，假设服务器仍在运行(或者您已经重新启动了服务器和编译)，如果您刷新浏览器，您会发现两个初始问题集列在一个表中，和以前一样。UI 本身不会显示任何变化，但是为了让自己相信数据确实来自数据库，您可以使用 mongo shell 和集合上的`updateMany()`方法修改集合中的文档。例如，如果您将所有文档的工作量更新为 100 并刷新浏览器，您应该会看到表中所有行的工作量都显示为 100。

### 练习:从 MongoDB 中读取

1.  我们将连接保存在一个全局变量中。当连接丢失时会发生什么？停止 MongoDB 服务器，然后再次启动它，看看会发生什么。连接还能用吗？

2.  关闭 MongoDB 服务器，等待一分钟或更长时间，然后再次启动服务器。现在，刷新浏览器。会发生什么？你能解释这个吗？如果您希望即使在数据库服务器关闭的情况下，连接也能工作更长时间，该怎么办？提示:在 [`http://mongodb.github.io/node-mongodb-native/3.1/reference/connecting/connection-settings/`](http://mongodb.github.io/node-mongodb-native/3.1/reference/connecting/connection-settings/) 查找连接设置参数。

3.  我们使用`toArray()`将问题列表转换成一个数组。如果列表太大，比如说一百万个文档，该怎么办？你会怎么处理这件事？提示:在 [`http://mongodb.github.io/node-mongodb-native/3.1/api/Cursor.html`](http://mongodb.github.io/node-mongodb-native/3.1/api/Cursor.html) 查找 MongoDB Node.js 驱动的`Cursor`的文档。注意，`find()`方法返回一个`Cursor`。

## 写入 MongoDB

为了完全替换服务器上的内存数据库，我们还需要更改 Create API 以使用 MongoDB 数据库。正如您在 MongoDB CRUD 操作一节中看到的，创建新文档的方法是对集合使用`insertOne()`方法。

我们使用内存数组的大小来生成新文档的`id`字段。我们可以做同样的事情，使用集合的`count()`方法来获取下一个 ID。但是当有多个用户使用这个应用时，在我们调用`count()`方法和调用`insertOne()`方法之间有一个小的机会创建一个新文档。我们真正需要的是一种可靠的方法来生成一个不会重复的数字序列，就像流行的关系数据库中的序列一样。

MongoDB 没有直接提供这样的方法。但是它支持原子更新操作，可以返回更新的结果。这种方法叫做`findOneAndUpdate()`。使用这种方法，我们可以更新一个计数器并返回更新后的值，但是我们可以使用增加当前值的`$inc`操作符，而不是使用`$set`操作符。

让我们首先创建一个包含计数器的集合，该计数器保存最新生成的问题 ID 的值。为了使它更通用，让我们假设我们可能有其他这样的计数器，并使用一个集合，该集合的 ID 设置为计数器的名称，一个名为`current`的值字段保存计数器的当前值。将来，我们可以在同一个集合中添加更多的计数器，并且这些将转化为每个计数器一个文档。

首先，让我们修改模式初始化脚本，以包含一个名为`counters`的集合，并用一个针对问题计数器的文档填充它。因为有些插入会产生一些样本问题，所以我们需要将计数器的值初始化为插入文档的计数。变化在`init.mongo.js`中，清单 6-6 显示了这个文件。

```js
...
print('Inserted', count, 'issues');

db.counters.remove({ _id: 'issues' });

db.counters.insert({ _id: 'issues', current: count });

...

Listing 6-6init.mongo.js: Initialize Counters for Issues

```

让我们再次运行模式初始化脚本，使更改生效:

```js
$ mongo issuetracker scripts/init.mongo.js

```

现在，对增加字段`current`的`findOneAndUpdate()`的调用保证返回序列中下一个唯一值。让我们在`server.js`中创建一个函数来做这件事，但是以一种通用的方式。我们将让它获取计数器的 ID 并返回下一个序列。在这个函数中，我们要做的就是调用`findOneAndUpdate()`。它使用提供的 ID 标识要使用的计数器，递增名为`current`的字段，并返回新值。默认情况下，`findOneAndUpdate()`方法的结果返回原始文档。要使它返回新的、修改过的文档，选项`returnOriginal`必须设置为`false`。

方法`findOneAndUpdate()`的参数是(a)过滤器或匹配，我们使用了 _ `id`，然后是(b)更新操作，我们使用了值为 1 的`$inc`操作符，最后是(c)操作的选项。下面是完成必要工作的代码:

```js
...
async function getNextSequence(name) {
  const result = await db.collection('counters').findOneAndUpdate(
    { _id: name },
    { $inc: { current: 1 } },
    { returnOriginal: false },
  );
  return result.value.current;
}
...

```

### 注意

返回当前值或新值的选项在 Node.js 驱动程序和 mongo shell 中的调用是不同的。在 mongo shell 中，该选项被称为`returnNewDocument`，默认为`false`。在 Node.js 驱动中，该选项被称为`returnOriginal`，默认为`true`。在这两种情况下，默认行为都是返回原始文档，因此必须指定选项来返回新文档。

现在，我们可以使用这个函数生成一个新的 ID 字段，并在解析器`issueAdd()`中的提供的`issue`对象中设置它。然后，我们可以使用`insertOne()`写入名为`issues`的集合，然后使用`findOne()`读回新创建的问题。

```js
...
  issue.id = await getNextSequence('issues');

  const result = await db.collection('issues').insertOne(issue);
  const savedIssue = await db.collection('issues')
    .findOne({ _id: result.insertedId });
  return savedIssue;
...

```

最后，我们可以消除服务器中的内存问题。包括这一变化，清单 6-7 中显示了`server.js`中的全部变化。

```js
...

const issuesDB = [

  {
    id: 1, status: 'New', owner: 'Ravan', effort: 5,
    ...
  },
  ...
  },

];

...

async function getNextSequence(name) {

  const result = await db.collection('counters').findOneAndUpdate(
    { _id: name },
    { $inc: { current: 1 } },
    { returnOriginal: false },
  );
  return result.value.current;

}

async function issueAdd(_, { issue }) {
  const errors = [];
  ...
  issue.created = new Date();

  issue.id = issuesDB.length + 1;
  issue.id = await getNextSequence('issues');

  issuesDB.push(issue);
  const result = await db.collection('issues').insertOne(issue);

  return issue;
  const savedIssue = await db.collection('issues')
    .findOne({ _id: result.insertedId });
  return savedIssue;
...

Listing 6-7server.js: Changes for Create API to Use the Database

```

测试这组更改将显示可以添加新的问题，即使重新启动 Node.js 服务器或数据库服务器，新添加的问题仍然存在。作为交叉检查，您可以使用 mongo shell 在 UI 每次更改后查看集合的内容。

### 练习:写入 MongoDB

1.  我们是否可以将`_id`添加到传入的对象中并返回，而不是对插入的对象执行`find()`操作？

本章末尾有答案。

## 摘要

在本章中，您了解了 MongoDB 中数据库实例的安装和其他访问方法。您看到了如何使用 mongo shell 和 Node.js 驱动程序来访问 MongoDB 中的基本操作:CRUD 操作。然后，我们修改了问题跟踪器应用，使用其中的一些方法来读写 MongoDB 数据库，从而使问题列表持久化。

我只讲述了 MongoDB 的基础知识，只讲述了对构建 Issue Tracker 应用有用的功能和特性，这是一个相当简单的 CRUD 应用。实际上，数据库、Node.js 驱动程序和 mongo shell 的功能非常强大，复杂的应用可能需要 MongoDB 的更多功能。我鼓励您看一看 MongoDB 文档( [`https://docs.mongodb.com/manual/`](https://docs.mongodb.com/manual/) )和 Node.js 驱动程序文档( [`http://mongodb.github.io/node-mongodb-native/`](http://mongodb.github.io/node-mongodb-native/) )，以熟悉数据库和 Node.js 驱动程序还能做什么。

既然我们已经使用了 MERN 堆栈的基本要素，并且有了一个可以工作的应用，那么让我们暂时停止实现特性，而是稍微组织一下。在应用变得更大、更笨拙之前，让我们将代码模块化，并使用工具来提高我们的生产率。

我们将在下一章通过使用 Webpack 来实现这一点，web pack 是可用于模块化前端和后端代码的最佳工具之一。

## 练习答案

### 练习:MongoDB 基础知识

1.  根据“访问 mongo shell 帮助”下的 mongo shell 文档，您可以发现在许多对象上都有一个名为`help()`的方法，包括`cursor`对象。获得帮助的方法是使用`db.collection.find().help()`。

    但由于这也是一个类似 Node.js 的 JavaScript shell，按 Tab 将自动完成，双 Tab 将显示可能完成的列表。因此，如果您将光标指定给一个变量，并在键入变量名和其后的点之后按 Tab 键两次，shell 将列出可能的完成，这是光标上可用方法的列表。

### 练习:MongoDB CRUD 操作

1.  这可以使用如下的`$exists`操作符来完成:

    `> db.employees.find({ "name.middle": { $exists: true } })`

2.  过滤器规范不是 JSON 文档，因为它不是字符串。它是一个常规的 JavaScript 对象，这就是为什么您可以跳过属性名两边的引号。与 JSON 字符串不同，您还可以将真正的`Date`对象作为字段值。

3.  The `$unset` operator in an update can be used to unset a field (which is actually different from setting it to null). Here is an example:

    ```js
    > db.employees.update(({_id: ObjectId("57b1caea3475bb1784747ccb")},
    {"name.middle": {$unset: null}})

    ```

    尽管我们提供了`null`作为`$unset`的值，但是这个值被忽略了。它可以是任何东西。

4.  1 表示遍历索引的升序排序。`-1`用于表示降序排序。这只对复合索引有用，因为一个字段的简单索引可以用来双向遍历集合。

### 练习:模式初始化

1.  使用 Node.js 驱动程序的优点是有一种跨应用和脚本的方式，这种熟悉有助于防止错误。但是运行这个程序需要一个合适的 Node.js 环境，包括安装的 npm 模块，而 mongo shell 脚本可以从任何地方运行，只要机器安装了 mongo shell。

2.  搜索栏在搜索问题时非常有用。在这种情况下，标题字段上的文本索引(基于单词的索引)会很有用。我们将在书的结尾实现一个文本索引。

### 练习:从 MongoDB 中读取

1.  连接对象实际上是一个连接池。它会自动确定最佳做法:重用现有的 TCP 连接，在连接断开时重新建立新的连接，等等。建议使用全局变量(至少重用连接对象)。

2.  如果数据库在短时间内(不到 30 秒)不可用，当数据库再次可用时，驱动程序会重试并重新连接。如果数据库长时间不可用，读取将引发错误。还原数据库时，驱动程序也无法重新建立连接。在这种情况下，需要重启应用服务器。

    使用连接设置`reconnectTries`或`reconnectInterval`可以更改默认的 30 秒间隔。

3.  一种选择是对结果使用`limit()`来限制返回值的最大记录数。例如，`find().limit(100)`返回前 100 个文档。如果要对 UI 中的输出进行分页，也可以使用`skip()`方法来指定列表的起始位置。

    另一方面，如果您认为客户端可以处理大型列表，但是您不希望在服务器上花费那么多内存，那么您可以使用`hasNext()`和`next()`一次处理一个文档，并将结果返回给客户端。

### 练习:写入 MongoDB

1.  添加`_id`并返回传入的对象本来是可行的，只要您确实知道写操作是成功的，并且对象被原样写入数据库。在大多数情况下，这是正确的，但是从数据库中获得结果是一个好的实践，因为这是最终的真理。**