# 2.识别模式

在这一章中，我将用简单的例子来展示基本的技术。这对于日常使用来说可能不够，但是对于你自己的实验来说是一个很好的基础。

## 基础

如果一个表达式被求值，会发生什么？实际上，我们的目标总是在另一个更大的文本中搜索一个文本部分。搜索的文本可能来自公式、文件、数据库，也可能只是一个字符串。但这不是重点。你可以使用一个简单的搜索功能，通常，这样一个简单的搜索更有效。正则表达式定义搜索文本中的属性。这样，你就不需要一次又一次地改变搜索词，而是给出一个变化范围。搜索和替换可能会达到一个全新的水平。

![A434767_1_En_2_Figa_HTML.jpg](A434767_1_En_2_Figa_HTML.jpg) Pattern

正则表达式通过使用模式来识别包含文本的字符串。

搜索时，表达式用于解析字符串之间的比较。根据结果，比较分为`true`或`false`。为了获得搜索模式的部分以供进一步检查，这种模式识别任务可以返回已经找到的部分的组。表达式中还有重复使用的组，以创建更复杂的属性。稍后，我将展示如何使用它。现在，我将展示几个例子来解释模式中属性的创建。

### 字符、行和文本

我已经使用了字符和文本等术语。在正则表达式的上下文中，术语行也很重要。行以换行符结束(在文本处理程序中，这是你按回车键的地方)。许多终止字符使用换行符。文件通常是逐行读取的。这就是正则表达式显式处理行的原因。您需要这些知识来搜索行尾以外的内容。

![A434767_1_En_2_Figb_HTML.jpg](A434767_1_En_2_Figb_HTML.jpg) Line Breaks

如果文本不包含任何换行符，则不需要元字符作为行开始和行结束。他们什么都不做。

## 正则表达式术语

这里我来解释一下比较特殊的术语。

### 元字符

在正则表达式中，可以用元字符定义特殊属性。其中一些你已经知道了——特别是搜索文本中开始位置的`ˆ`和结束位置的`$`。

`ˆ`和`$`称为元字符。如果您想将元字符作为常规字符来查找，您必须在它前面加一个反斜杠:

```
\$, \ˆ

```

反斜杠破坏了特殊含义。因此，反斜杠本身也是元字符。如果你特别寻找反斜杠，你写`\\`。

下面是对所有元字符的更全面的解释。

### 文字

任何编程语言都有几种文字来表达除关键字以外的东西，如数字、运算符或文本。JavaScript 在这里也不例外。JavaScript 中的正则表达式使用`/`(正斜杠)作为文字字符。

```
/[abc]/

```

表达式可以赋给变量，也可以直接用作参数。

```
1   var patt = /abc/;
2   var s = /abc/.toString();
3   console.log(s);

```

### 字符类别

如果您要查找字符串或单个字符，使用字符类通常非常有效。字符类写在方括号里，比如`[abc]`。整个表达式代表该类中的一(1)个字符。在这个例子中，它或者是`a`，或者是`b`，或者是`c`。既不是`ab`也不是`bc`。您必须使用重复运算符来告诉表达式引擎从这样的类中寻找字符的更多外观。

你可以一个接一个地写出你要找的任何字符，或者用破折号来分组。表达式`[a-c]`也会碰到字母`b`。

### 参考

成功找到的文本部分的一部分存储在临时存储单元中。您可以稍后在同一个表达式中引用它们。引用使用一个反斜杠，后跟存储位置。比如看起来像`\4`。

## 元字符概述

下面是 JavaScript 正则表达式中可用的元字符的完整列表。

### 起点、终点和边界

您已经从简介章节中了解到的最重要的几个:

*   `ˆ`是开始(或开始)
*   `$`是结束了
*   `\b`定义一个单词的边界
*   `\B`没有定义边界

这是什么意思？如果你找“auto”这个词，“a”一定是开头，而“o”是结尾。要精确地搜索这个字符串(前后都没有)，您的表达式是`ˆauto$`。如果您要查找的单词在文本中的任何地方，表达式就是简单的`auto`。

```
1   var patt = /^auto$/;
2   console.log(patt.test("auto"));
3   console.log(patt.test("automatic"));
4   
5   var patt2 = /auto/;
6   console.log(patt.test("That's our automobile, it's an BMW."));

```

输出显示结果，如图 [2-1](#Fig1) 所示。

![A434767_1_En_2_Fig1_HTML.jpg](A434767_1_En_2_Fig1_HTML.jpg)

图 2-1。

Output of the script

结尾大多是一行的结尾。如果设置了一些额外的开关，情况可能不是这样。开关在表达式之外，控制正则表达式引擎。你可以在第 [3](3.html) 章找到更多关于他们的信息。

单词边界是从单词到周围部分的过渡。拉丁语文本中的单词以空格或标点符号结尾，如逗号、分号或句号。特殊符号`\b`寻找这样的过渡。它并不完全代表一个字符；更多的是介于两者之间。这就是我在导言中对财产一词的意思。正则表达式描述了搜索文本的属性，而不是实际的搜索词。

表达式`/\bco`在句子“这很复杂”中识别“co”“co…”前面的空格构成了单词 boundary。该表达式在“肿瘤学很难”这句话中找不到任何内容。—即使“co”也在文本中。

### 任何字符

通常你会在一个特定的位置寻找一个角色，但是哪个角色并不重要。在类中处理所有的字符是很痛苦的。这就是为什么有另一个元字符:

*   `.`是任何字符，确切地说

现在，您可以在不同的上下文中查找“auto ”:

*   `.uto`查找“自动”、“自动”、“自动”等，也查找“分配器”。后者可能是不期望的。

```
1   var patt = /.uto/;
2   console.log(patt.test("auto"));
3   console.log(patt.test("automatic"));
4   console.log(patt.test("distributor"));

```

输出显示结果，如图 [2-2](#Fig2) 所示。

![A434767_1_En_2_Fig2_HTML.jpg](A434767_1_En_2_Fig2_HTML.jpg)

图 2-2。

Output of the script

### 没有字符

如果你不寻找任何东西，正则表达式似乎没有用。但事实如此。想象你在一个文件中寻找空行。这就是只使用结束字符的结果:

```
ˆ$

```

是的，就是这么简单，因为表达式定义了唯一的字符是行的开始和结束。因此，该行必须为空。这就是你要找的。空在这里的意思是“中间没有东西”

单个`ˆ`作为搜索模式没有任何意义。它只是宣告了必须有一个开始。这是任何线都具有的属性。任何文本都将匹配此模式。

## 字符类别

字符类定义了类组。

### 众多中的一个

字符类写在方括号中。如果没有其他运算符，它始终只是模式中的一个位置。组由一个破折号组成，多个组简单地写在一起。该类中的任何字符都将被“按原样”处理，并失去其作为元字符的特殊意义。

*   `[aeiou]`定义英语中的元音
*   `[a-f]`定义字母 a、b、c、d、e、f(仅小写)
*   `[a-fA-F0-9]`定义十六进制数的所有数字

顺序只在群体中重要。简单来说，表达式`[a-fA-F]`和`[A-Fa-f]`是相同的。

```
1   var patt = /[a-f]+/;
2   console.log(patt.test("Auto"));
3   console.log(patt.test("42"));
4   console.log(patt.test("12 Days"));
5   console.log(patt.test("borrow"));

```

输出显示结果，如图 [2-3](#Fig3) 所示。

![A434767_1_En_2_Fig3_HTML.jpg](A434767_1_En_2_Fig3_HTML.jpg)

图 2-3。

Output of the script

### 否定

通过使用元字符`ˆ`，一个完整的字符类可以被全部字符否定。它与使用相同符号的起始行元字符有不同的含义，也没有共同之处。这只是一个不同的背景。一些字符根据上下文有不同的含义。这就是为什么小心地分离正则表达式的各个部分是至关重要的。你必须了解人物的背景。

*   `[ˆ0-9]`包括除数字以外的所有内容(包括诸如`#`、`*`或`%`之类的字符)。
*   `[ˆaeiou]`定义了所有辅音，还有更多的，比如数字。

`ˆ`的特殊含义只有在它是左括号后的第一个字符时才起作用。如果它在类中的其他地方，它只是它自己的一个普通字符:

*   `[!"@§$%ˆ&/()=]`定义键盘数字键上的所有字符在 Shift 级别。

### 数字

寻找数字是一项常见的任务。数字由数字组成，使用前导符号、小数点和千位标记。以下表达式可能会有所帮助:

*   `[0-7]`是八进制数的数字(基数为 8)
*   `[0-9+-.] are`带符号和小数点的十进制数字
*   `[a-fA-F0-9]`是十六进制数字

### 日期和时间

以下表达式显示了如何识别文本中的日期和时间片段:

*   `[0-9/]`日期(美国格式，如 2016 年 4 月 22 日)。
*   `[0-9:]`时间，如 7:44
*   `[0-9:amp]`带有“上午”或“下午”的时间

最后一个例子往往过于简单，因为它允许“a9”或“p0m”。

其他的很弱，因为时间 26:99 也会被找到。

```
1   var patt = /[0-9:amp]/;
2   console.log(patt.test("12am"));
3   console.log(patt.test("4:17"));

```

输出显示结果，如图 [2-4](#Fig4) 所示。

![A434767_1_En_2_Fig4_HTML.jpg](A434767_1_En_2_Fig4_HTML.jpg)

图 2-4。

Output of the script ![A434767_1_En_2_Figc_HTML.jpg](A434767_1_En_2_Figc_HTML.jpg) Limitations

这些例子表明简单的正则表达式有明显的局限性。虽然可以编写与复数值范围完全匹配的表达式，但工作量可能会很大。你可以在附录中找到更好的例子。

### 用线串

通过使用字符类，您可以轻松区分小写字母和大写字母:

*   `[gG]reen, [rR]ed`

如果一个名字不能以独特的方式书写，你可以使用类:

*   `M[ae][iy]er`匹配“迈耶”、“迈耶”、“迈尔”、“迈尔”。

## 缩写

元字符通常形成缩写，如表 [2-1](#Tab1) 中所列和所述。

表 2-1。

Metacharacter Abbreviations

<colgroup><col> <col></colgroup> 
| 缩写 | 描述 |
| --- | --- |
| `\t` | 制表机 |
| `\n` | 换行 |
| `\r` | 回车(回车) |
| `\f` | 换页 |
| `\v` | 垂直制表机 |
| `\s` | 空白(打印时不可见，包括`\t`、空格、`\n`、`\r`、`\f`) |
| `S` | \s 的否定 |
| `\w` | 单词字符(组成单词的字母，例如在`[_a-zA-Z0-9]`中) |
| `W` | `\w`的否定 |
| `\d` | 数字，如`[0-9]` |
| `D` | `\d`的否定 |
| `\b` | 单词的边界、开头或结尾；都不在\w 定义中。 |
| `B` | `\b`的否定 |
| `\0` | Nul ( `nil`)字符(物理 0) |
| `\xxx` | 字符值，写成八进制数 |
| `\xdd` | 字符值，写成十六进制数 |
| `\uxxxx` | Unicode 字符，写成十六进制数 |
| `\cxxx` | 控制，ASCII 值 |

## 重复运算符

到目前为止显示的所有元字符都有一个共同点:它们只处理一个字符。如果需要多次出现，可以使用重复运算符。介绍中提到了一些特色菜。这里我会给出更完整的描述。但是让我们从一些简单的例子开始:

*   `a*`定义`"a"`不出现或出现，如`"a"`、`"aaaa"`等。
*   `a+`定义一个或任意数量的`"a"`，如`"a"`、`"aa"`等。
*   `a?`定义无或有一个`"a"`，如`""`或“a”确切。

### 常见运算符

通用运算符使用一定范围内的多个字符。以下表达式使用通用运算符:

*   `{min, max}`声明必需的`min`字符和允许的`max`字符
*   `{wert}`确切的数字
*   `{,max}`最小值可以省略(零到`max`)
*   `{min,}`最大值也可以省略；`min`任意数字
*   两个范围都可以省略(关于这个结构的更多信息，见下一段)

当然，你总是可以用这个表达式来代替简写的*、+和？。详细格式如下所示:

*   `{,}`表示*
*   `{0,1}`表示`?`
*   `{1,}`表示`+`

这些运算符非常适用于长度定义明确的文本，例如邮政编码:

```
1   <form>
2     <input type="text" name="zip" value="">
3     <input type="submit">
4   </form>

```

以下脚本检查用户输入的邮政编码是否有意义:

```
 1   <script>
 2   var re = /^[0-9]{5}$/;
 3   var field = "12683";
 4   var checkzip = re.exec(feld);
 5   if(!checkzip) {
 6     alert("The zip code " + checkplz + " is not correct.");
 7   } else {
 8       console

.log(checkplz)
 9   }
10   </script>

```

输出显示结果，如图 [2-5](#Fig5) 所示。

![A434767_1_En_2_Fig5_HTML.jpg](A434767_1_En_2_Fig5_HTML.jpg)

图 2-5。

Output of the script

### 摘要

表 2-2。

Repetition Operators

<colgroup><col> <col> <col></colgroup> 
| 操作员 | 意义 | 描述 |
| --- | --- | --- |
| `?` | 0 – 1 | 没有或一个 |
| `*` | 0 – ∞ | 没有或任何 |
| `+` | 1 – ∞ | 一个或任何 |
| `{num}` | 数字 | 准确数字 |
| `{min,}` | 最小 – ∞ | 最小最小值 |
| `{,max}` | 0–最大值 | 无或最大值为 max |
| `{min, max}` | 最小最大值 | 最小最小值和最大值中的最大值 |

### 特殊操作员

“或”运算符是一个特殊的运算符，写作`|`。例如，`/green|red/`匹配“绿色苹果”中的“绿色”和“红色苹果”中的“红色”，但不匹配“红色或绿色苹果”。

## 参考

到目前为止显示的元素看起来很简单，对吗？元字符和类的更复杂的组合还不够灵活。(与传统编程语言相比)真正缺少的是循环。特别是在研究字符串时，连续的逐字符搜索非常有用。

要在正则表达式中得到类似的东西，可以使用引用。那是某种特殊的元字符，比如`\1`、`\2`等等。这些编号部分引用了在搜索文本中较早找到的字符组。重要的组写在括号(…)中。

有时很难以正确的方式阅读括号，因为现在你有各种各样的括号，甚至可以出现嵌套。最好的方法是一种简单实用的方法:只需计算左括号。这才是最重要的。第一个的块由`\1`引用，第二个由`\2`引用，依此类推。JavaScript 最多支持九个引用。其他语言可能支持更多。

![A434767_1_En_2_Figd_HTML.jpg](A434767_1_En_2_Figd_HTML.jpg) Be careful

在字符类中，不能使用引用。这是因为反斜杠在这里没有特殊的含义。但是，由字符类形成的部分可以放在括号中，作为参考。

表达式`/apple(,)\sorange\1/`将匹配字符串“苹果，橘子，樱桃，桃子”中的“苹果，橘子”。逗号在第一组中是有界的，因此它也出现在“orange”之后。也注意中间的`\s`。这是空格元字符。

## 组

用于引用的组也可以用于重复操作符。使用组作为参考仅仅是一个副作用。

### 简单组

如果要重复一组字符，只需使用括号:`(ab)+`在`abc`、`abcabc`等中找到匹配，而在`aacbb`中没有。

```
1   var patt = /(ab)+/;
2   console.log(patt.test("abc"));
3   console.log(patt.test("abcabc"));
4   console.log(patt.test("aacbb"));

```

输出显示结果，如图 [2-6](#Fig6) 所示。

![A434767_1_En_2_Fig6_HTML.jpg](A434767_1_En_2_Fig6_HTML.jpg)

图 2-6。

Output of the script

### 封闭字符

表达式是一种常用的搜索模式，其中文本由一对相同的字符括起来。这通常是编程语言中字符串或 HTML 中标记的字面外观。观看这些文本片段:

*   “单词单词”应被发现
*   “‘词词’不得发现
*   应找到“单词单词”

正则表达式的一个可能的解决方案如下所示:

```
/ˆ(["']){1}.*\1$/

```

这是怎么回事？表达式以`ˆ`开始，然后跟一个“(双引号)或一个’(单引号)`["']`。整个部分被括在括号内，因此它作为一个参考，应该出现一次`{1}`。然后，任何数量的字符都可以跟在`.*`后面，直到紧接在`$`后面，这时必须出现完全相同的引用。那是`\1`写的。这清楚地表明了引用的性质。

他们没有重复定义；他们重复参考组找到的零件。

```
1   var patt = /^(["']){1}.*\1$/;
2   console.log(patt.test("\"Word Word\""));
3   console.log(patt.test("\"Word Word\'"));
4   console.log(patt.test("\'Word Word\'"));

```

输出显示结果，如图 [2-7](#Fig7) 所示。

![A434767_1_En_2_Fig7_HTML.jpg](A434767_1_En_2_Fig7_HTML.jpg)

图 2-7。

Output of the script

因为这个非常结构化的示例通过重复一个单词两次来查找引用的单词，所以准确地处理这个问题是一个很好的练习。我们要找的不是引号，而是两个相同的词:

```
:/\b((\w+)\s+\2)+/

```

因为单词有单词边界，所以表达式以一个`\b`开始。

然后一个组开始，在这个组中，另一个组寻找必须出现一次或多次的单词字符(`\w`)。后跟一个或多个空格(`\s+`)。整个组再重复一次(`\2`)。重复的部分是内部组，因为`2`指的是第二个左括号。

```
_ var patt = /\b((\w+)\s+\2)+/;
console.log(patt.test("Script Script istdoppelt"));

```

### 非计数组

有时很难读懂一个有很多括号的表达式，其中只有几个(或者只有一个)被用作参考。对此，可以写`(:…)`组成不计数组。

## 前瞻参考

回顾参考只是交易的一部分。有时一个匹配是有效的，如果另一个字符跟在后面。这可以通过前瞻参考来实现。两种元字符组合对此很有用:

*   积极的前瞻；以下字符必须匹配
*   消极的前瞻；以下字符不得匹配

```
1   var patt = /(\d{1,3})(?=d)/;
2   var text = "Duration: 16d";
3   var test = patt.exec(text);
4   console.log("Days: " + test[0]);

```

输出显示结果，如图 [2-8](#Fig8) 所示。

![A434767_1_En_2_Fig8_HTML.jpg](A434767_1_En_2_Fig8_HTML.jpg)

图 2-8。

Output of the script

本示例查找一至三位数的数字，这些数字后面紧跟字母“d”。字母“d”本身不是匹配的一部分——它只是必须在那里使数字匹配。

lookahead and lookbehind

你可以想象，如果有什么东西在向前看，它也可能在向后看。几种语言和平台的正则表达式都有这个特性。但是，JavaScript 不支持后视引用。